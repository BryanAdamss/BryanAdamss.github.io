[{"title":"bem-suit","date":"2019-03-11T15:18:16.000Z","path":"2019/03/11/bem-suit/","text":"样式类的命名BEM基本组成 B(block)-每个模块可视为一个 block E(element)-代表.block 的后代，用于形成一个完整的.block 的整体 M(modifer)-代表.block 的不同状态或不同版本。如 current active 等特殊样式 命名约定12345678.block-name &#123;&#125;.block-name__element-name &#123;&#125;.block-name--modifier-name &#123;&#125; 长单词采用-分隔,如 siteName 用 site-name BE 之间采用__(双下划线)分隔 M 用--标识 注意事项 注意:并非所有类都必须采用 bem 命名方式 当一个元素 element 总是固定出现在某块下面，则可采用 bem 命名方式。若只是恰巧此次出现在某块下面，则不必采用 bem。如 logo 可直接使用.logo 而不必采用.header{} .header__logo{}来标识。因为 logo 只是恰巧出现在 header 中,logo 还可以出现在 footer 等其它地方； 单独的css 样式，可不用bem命名方式如 .fr{float:right;}不必采用 bem SUITBEM 的改进 BEM采用-以及__来分隔容易造成混乱,SUIT对其改进，思想是一样的，但是命名约定稍有改变，SUIT多采用帕斯卡,驼峰命名方法 基本组成 Utilities(公用样式)-如 clearfix Component(公用组件)-类似 BEM 中的 block Descendants(后代)-类似 BEM 中的 element Status(状态)-组件的各种状态，如有需要也可用在后代上，不可单独使用(添加样式) Modifer(修饰符)-类似 BEM 中的 M,不过它只能用在 Components 上不能用在 Descendants 上,也不能表示组件状态，状态由 Status 标识 命名约定1234567891011121314.u-utility &#123;&#125;.ComponentName &#123;&#125;.ComponentName-descendantName &#123;&#125;.ComponentName--modifierName &#123;&#125;.ComponentName.is-someState &#123;&#125; 公用样式 添加 u-前缀,并采用驼峰命名，如 u-clearFix{},u-floatRight{}，还可以添加 sm、md、lg 等响应式如.u-sm-floatR 组件 采用帕斯卡命名，如.SearchForm{} 避免冲突可添加命名空间，如.cgh-SearchForm{}；组件后只能跟一个后代、不能跟多个 后代 采用-分隔，驼峰命名。如.SearchForm-submitBtn{} 修饰符 采用–标识，只能跟在组件后，不能跟在后代后面。.SearchForm–advanced{} 状态 用驼峰命名，并在驼峰上添加.is-前缀。用在组件后面，如有需要也可以跟在后代后面； 不要单独使用这些状态类(添加样式)，配合组件/后代来实现某种样式如.is-mouseOver{} 使用时.SearchForm.is-mouseOver{} 注意：中间无空格，不是.SearchForm 空格.is-mouseOver{}；它是表示同时拥有.SearchForm 和.is-mouseOver{}类的标签;通过这种方式能确定处于特定状态下的标签,等于将 is-mouseOver 绑定到 SearchForm 上了 示例 好的 错误 原因 .u-clearfix{}、.u-sm-clearfix{}、.u-floatL{} .Tree、.cgh-Tree .tree、.cgh_Tree 组件首字母应大写；命名空间应用-连接 .Tree-list、.Tree-listHd .Tree-list-item、.Tree-listhd 组件后面只能跟一个后代，不能跟多个；后代应该用驼峰 .Tree–large .Tree-list–large 修饰符应只跟在组件后面 .Tree.is-active{display:block;}、.Tree-item.is-active{display:block; } is-active{display:block; } 不要给状态单独添加样式面","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"bem","slug":"bem","permalink":"http://yoursite.com/tags/bem/"},{"name":"suit","slug":"suit","permalink":"http://yoursite.com/tags/suit/"}]},{"title":"vue-swiper-virtual","date":"2019-03-11T15:16:54.000Z","path":"2019/03/11/vue-swiper-virtual/","text":"在 vue 中使用 swiper 的 virtual 特性swiper 介绍 前端开发中，经常会碰到轮播、翻页等需求。swiper就是用来解决此类需求的。 功能全、覆盖场景多，可适配移动端等特点，让它成为实现此类需求的最好选择。 它有专门的vue版本，vue-awesome-swiper 背景 项目是基于vue全家桶开发的，有轮播需求，轮播的 slides 数量较多，slide 的 DOM 结构比较复杂。 问题 项目中使用的是vue-awesome-swiper，它基于swiper做了相关封装 使用时并没有使用virtual slides特性，初始化时会渲染所有slide，导致初始渲染速度较慢。在DOM结构复杂，slide 数量为 100 时，初始渲染大概需要 2~3s。 数据改变触发更新时，vue-awesome-swiper会频繁触发update操作。容易页面卡死。 类似问题https://github.com/surmon-china/vue-awesome-swiper/issues/424 见源码 1234567891011121314151617181920212223242526272829303132333435363738// vue-awesome-swiper/src/slide.vue&lt;template&gt;&lt;div :class=\"slideClass\"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'swiper-slide', data() &#123; return &#123; slideClass: 'swiper-slide' &#125; &#125;, ready() &#123; this.update() &#125;, mounted() &#123; this.update() if (this.$parent &amp;&amp; this.$parent.options &amp;&amp; this.$parent.options.slideClass) &#123; this.slideClass = this.$parent.options.slideClass &#125; &#125;, updated() &#123; this.update() &#125;, attached() &#123; this.update() &#125;, methods: &#123; update() &#123; if (this.$parent &amp;&amp; this.$parent.swiper) &#123; this.$parent.update() &#125; &#125; &#125;&#125;&lt;/script&gt; - 使用 swiper 的 virtual 特性 virtual官方介绍 -虚拟Slide会在Dom结构中保持尽量少的Slide，只渲染当前可见的slide和前后的slide，而隐藏其他不可见的Slide，每次切换时就渲染新的Slide。当你的Slide很多的时候，尤其是Slide中有复杂的Dom树结构时，性能会有很大的提升。 由于使用vue-awesome-swiper出现了一些性能问题，所以我们决定直接使用swiper版本并开启virtual特性（注意使用 4.0 版本） 中文文档中，并没有详细介绍如何在vue中使用virtual特性。 英文文档 http://idangero.us/swiper/api/#virtual中详细介绍了如何在vue、react中使用virtual特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt;&lt;!-- ... --&gt;&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;!-- 必须在每个slide上设置left --&gt; &lt;!-- 勿直接将v-for的index做为key，会出现key重复的问题 --&gt; &lt;div class=\"swiper-slide\" v-for=\"(slide, index) in virtualData.slides\" :key=\"slide.id\" :style=\"&#123;left: `$&#123;virtualData.offset&#125;px`&#125;\" &gt; &#123;&#123;curIndex&#125;&#125; &lt;br/&gt; &#123;&#123;slide&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- ... --&gt;&lt;/template&gt;&lt;script&gt;import Swiper from 'swiper/dist/js/swiper.esm.bundle' // 导入swiperimport 'swiper/dist/css/swiper.min.css' // 记得导入样式export default &#123; data() &#123; return &#123; curIndex:0, // 当前翻页索引 // 声明virtualData，供swiper使用 virtualData: &#123; slides: [], &#125;, &#125; &#125;, mounted() &#123; Api.getSomeSlides().then(res=&gt;&#123; const self = this; const swiper = new Swiper('.swiper-container', &#123; // ... virtual: &#123; slides: res.slides, // 需要添加的虚拟slide的内容 renderExternal(data) &#123; console.log(data) // 返回一个经过swiper计算后的当前需要渲染的slides相关信息 // offset - slides偏移值 // from - 首个需要渲染的slide索引 // to - 最后一个需要渲染的slide索引 // slides - 需要渲染的slides self.virtualData = data &#125;, &#125;, on:&#123; slideChange()&#123; // 更新index self.curIndex=this.activeIndex &#125; &#125; &#125;); &#125;) &#125;,&#125;;&lt;/script&gt; 使用后每次仅渲染当前页及前后页 每次渲染时，会重新触发vue的生命周期 其他使用基本和不使用virtual特性保持一致 若有swiper嵌套需求，可在子组件中直接实例化一个swiper并设置nested选项为true 总结 vue-awesome-swiper有坑，会频繁调用update，导致一定性能问题 可直接使用swiper替换vue-awesome-swiper 相关链接 vue-awesome-swiper https://github.com/surmon-china/vue-awesome-swiper/issues/424 http://idangero.us/swiper/api/#virtual","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"swiper","slug":"swiper","permalink":"http://yoursite.com/tags/swiper/"},{"name":"virtual","slug":"virtual","permalink":"http://yoursite.com/tags/virtual/"}]},{"title":"array-flat","date":"2019-03-11T15:14:43.000Z","path":"2019/03/11/array-flat/","text":"数组扁平化前置知识浅扁平化 浅扁平化就是只扁平化一层数组 深扁平化 实现无线层级的多维数组扁平化 方法原始数组1var needFlatArr = [1, 2, [3, 4], [[5, 6, 7]], [8, [9, 10], [[11]]]] 浅扁平化实现 concat + apply 12345678// 1.concat + apply - 浅扁平化// concat在拼接数组时，若入参中有数组时，则遍历此数组每项(不会递归遍历，仅会遍历一层)，并将其依次拼接到尾部// [].concat(1,[2,3],[4,5],[[6,7]]) 结果[1,2,3,4,5,[6,7]]// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concatfunction flatConcatApply(arr) &#123; // 相当于[].concat.(arr[0],arr[1],arr[2],...) return Array.prototype.concat.apply([], arr)&#125; concat + reduce 1234// concat + reduce - 浅扁平化function flatConcatReduce(arr) &#123; return arr.reduce((a, b) =&gt; a.concat(b), [])&#125; 深扁平化实现 递归实现 - 常规实现 - 深扁平化 1234567891011function flatRecursion(arr) &#123; var result = [] for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Object.prototype.toString.call(arr[i]) === '[object Array]') &#123; result = result.concat(flatRecursion(arr[i])) &#125; else &#123; result = result.concat(arr[i]) &#125; &#125; return result&#125; 递归实现 es6 - 常规实现 - 深扁平化 12345678910function flatRecursionEs6(arr, result = []) &#123; for (let item of arr) &#123; if (Array.isArray(item)) &#123; flatRecursionEs6(item, result) &#125; else &#123; result.push(item) &#125; &#125; return result&#125; 递归实现 es6 - 简化 - 深扁平化 - 推荐 12345678const flatten = arr =&gt; arr.reduce( (result, shouldFlatten) =&gt; result.concat( Array.isArray(shouldFlatten) ? flatten(shouldFlatten) : shouldFlatten ), [] ) 循环实现 - 循环调用浅扁平化函数实现 - lodash 思路 - 深扁平化 1234567function flatIterationShallowFlat(arr, deep = 1) &#123; let result = arr while (deep--) &#123; result = flatConcatApply(result) &#125; return result&#125; toString - 仅支持元素全部为 number 的场景 - 深扁平化 123456function flatToString(arr) &#123; return arr .toString() .split(',') .map(item =&gt; +item) // 转换为数字类型&#125; 字符串过滤 - 将输入数组转换为字符串并删除所有括号（[]）并将输出解析为数组 - 深扁平化 12const flatStringFilter = arr =&gt; JSON.parse(`[$&#123;JSON.stringify(arr).replace(/\\[|]/g, '')&#125;]`) Generator - 定义生成器函数，并依次调用 1234567891011121314151617function* flatG(arr) &#123; for (let item of arr) &#123; if (Array.isArray(item)) &#123; yield* flat(item) &#125; else &#123; yield item &#125; &#125;&#125;function flatGenerator(arr) &#123; let result = [] for (let val of flatG(arr)) &#123; result.push(val) &#125; return result&#125; 原生 flat - 兼容有问题 chrome 高版本不支持 - 深扁平化 1234;[1, 2, [3]] .flat(1) // [1, 2, 3] [(1, 2, [3, [4]])].flat(2) // [1, 2, 3, 4] [(1, 2, [3, [4, [5]]])].flat(Infinity) // [1, 2, 3, 4, 5] 无线层级 原生 flatMap - 等于 map + flat 123// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat();[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] 参考 https://www.jianshu.com/p/b1fb3434e1f5 http://www.cnblogs.com/front-end-ralph/p/4871332.html https://juejin.im/post/5c6b63f6f265da2da53ec057","tags":[{"name":"扁平化","slug":"扁平化","permalink":"http://yoursite.com/tags/扁平化/"},{"name":"flat","slug":"flat","permalink":"http://yoursite.com/tags/flat/"}]},{"title":"number-to-chinese","date":"2019-03-11T15:09:42.000Z","path":"2019/03/11/number-to-chinese/","text":"浮点数转中文 链接：https://github.com/BryanAdamss/VueTemplate/blob/master/src/common/js/NumberToChinese.js 背景 项目有整数转中文的需求，本想直接搜索个简单的实现。 但发现网络上的有一些问题 有些无法处理浮点数 有些存在生硬翻译问题，无法翻译成满足日常习惯的中文；如 11 翻译成了 一十一，应翻译成 十一 有些翻译范围有限 造轮子 决定自己实现一个浮点数转中文的工具方法 支持浮点数 支持正负数 符合日常口语习惯 能支持翻译 js 数字范围内的所有数字 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309/** * 浮点数转中文 * * @author:GuangHui * @email:adamssbryan@foxmail.com * @export * @class NumberToChinese */export default class NumberToChinese &#123; // - 90989002.0384 // 符号 整数 点号 小数 // 符号、点号、小数部分直接查找引射表进行翻译即可 // 整数部分每个计数数字都跟着一个权位，权位有：''(个位，默认不翻译),十、百、千、万、亿。 // 整数部分以“万”为小节(整数部分从右至左数每四位为一小节)，对应一个节权位，万以下没有节权位(最小节权位为万)，节权位有：万, 亿, 万亿, 亿亿；例:1 2345 . 3；1属于首小节， 2345为第二小节 // 每个小节内部以“十百千”为权位独立计数。 // “十百千”不能连续出现，而“万”和“亿”作为节权位时可以和其他权位连用，如：“二十亿”。 // 整数小节内“零”的使用要满足以下规则： // 0对应的权位不翻译。例：203应翻译为'二百 零 三'而不是'二百 零十 三' // 小节的末位是0，可不翻译。例：小节为230，逐位翻译，应为'二百 三十 零'，根据此规则，结尾零应该舍弃，为'二百 三十' // 小节内两个非0数字之间若出现0要使用“零”。例：小节为203，应翻译为'二百 零 三' // 小节内多个连续的零应合并。例：小节为2003，应翻译为二千零三，而非二千零百零十三 // 当小节的“千”位是0时（即：1~999），只要不是首小节，都要前补“零”。非首小节不足四位时，需要前补零，首小节无需前补零。例: 10234，首小节为1，第二小节为234不足四位，翻译时第二小节需要前补零，即零二百三十四，再prepend第一小节的翻译一万，最终结果为'一万 零 二百 三十 四' // 正负0不做区分 constructor(&#123; unitChars, sectionUnitChars, numChars, dotChar, signChar &#125; = &#123;&#125;) &#123; this.unitChars = unitChars || ['', '十', '百', '千'] // 节内权位 this.sectionUnitChars = sectionUnitChars || ['', '万', '亿', '万亿', '亿亿'] // 节权位 this.numChars = numChars || [ '零', '一', '二', '三', '四', '五', '六', '七', '八', '九' ] // 数字映射表 this.dotChar = dotChar || '点' this.signChar = signChar || '负' &#125; /** * 判断数字是否在安全范围内 * @param &#123;Number&#125; n 数字 */ isSafeNumber(n) &#123; return typeof n === 'number' &amp;&amp; !isNaN(n) &amp;&amp; Math.abs(n) &lt;= Math.pow(2, 53) &#125; /** * 填充字符串 * * @param &#123;String&#125; str 原始字符串 * @param &#123;Number&#125; padNum 填充数量 * @param &#123;String&#125; padChar 填充字符 * @param &#123;Boolean&#125; [before=true] 前填充 * @returns 填充后的字符串 * @memberof NumberToChinese */ padStr(str, padNum, padChar, before = true) &#123; if ( typeof str !== 'string' || typeof padNum !== 'number' || isNaN(padNum) || padNum === 0 || typeof padChar !== 'string' ) &#123; return str &#125; while (padNum) &#123; if (before) &#123; str = padChar + str &#125; else &#123; str += padChar &#125; padNum-- &#125; return str &#125; /** * 获取数字对应中文 * * @param &#123;Number&#125; i 数字 * @returns 对应数字的中文 * @memberof NumberToChinese */ getNumChar(i) &#123; return this.numChars[i] &#125; /** * 获取节内权位 * @param &#123;Number&#125; i 索引 */ getUnitChar(i) &#123; return this.unitChars[i] &#125; /** * 获取节权位 * @param &#123;Number&#125; i 索引 */ getSectionUnitChar(i) &#123; return this.sectionUnitChars[i] &#125; /** * 获取浮点数各组成部分 * * @param &#123;Number&#125; n 需要分解的数字 * @returns 数字各组成部分 * @memberof NumberToChinese */ getParts(n) &#123; const num = parseFloat(n) if (!this.isSafeNumber(num)) return '无法解析' const reg = /^([-+]?)(0|[1-9]\\d*)(\\.?)(\\d*)$/ const &#123; 1: sign, 2: interger, 3: dot, 4: decimal &#125; = reg.exec( num.toString() ) return &#123; sign, interger, dot, decimal &#125; &#125; /** * 获取点号对应中文 * * @param &#123;String&#125; dotPart 点号部分 * @returns 点号对应中文 * @memberof NumberToChinese */ getDotPartChn(dotPart) &#123; if (typeof dotPart !== 'string') return '无法解析' return dotPart === '.' ? this.dotChar : '' &#125; /** * 获取符号对应中文 * * @param &#123;String&#125; signPart 符号部分 * @returns 符号对应中文 * @memberof NumberToChinese */ getSignPartChn(signPart) &#123; if (typeof signPart !== 'string') return '无法解析' return signPart === '-' ? this.signChar : '' &#125; /** * 获取小数部分的中文表示 * * @param &#123;Number | String&#125; deci 小数部分 * @returns 小数部分的中文表示 * @memberof NumberToChinese */ getDecimalPartChn(n) &#123; if (!this.isSafeNumber(parseInt(n)) || typeof n !== 'string') return '参数为无法解析' return n .toString() .split('') .map(item =&gt; this.getNumChar(item)) .join('') &#125; /** * 获取整数部分小节 * * @param &#123;String|Number&#125; n 整数 * @returns 小节数组 * @memberof NumberToChinese */ getIntergerSections(n) &#123; let num = parseInt(n) if (!this.isSafeNumber(num) || num &lt; 0) &#123; return '参数无法解析或小于0' &#125; if (num === 0) return [0] let temp = [] while (num &gt; 0) &#123; temp.push(num % 10000) num = Math.floor(num / 10000) &#125; return temp.reverse() &#125; /** * 翻译小节 * @param &#123;Number|String&#125; section 4位长度的小节 * @returns 小节对应中文 */ getSectionsChn(section) &#123; let num = parseInt(section) if (!this.isSafeNumber(num) || num &gt;= 10000 || num &lt; 0) &#123; return '节无法解析成数字或位数超过4位或小于0' &#125; let str = '' let needPadStartZero = false let unitCount = 0 while (num &gt; 0) &#123; let g = num % 10 // 取个位数 if (g === 0) &#123; if (needPadStartZero) &#123; needPadStartZero = false // 当前为0，已经补过零，下次若还为0则不需补 str = this.padStr(str, 1, this.getNumChar(0)) &#125; &#125; else &#123; // 当前数不为0，默认下次为0，需要进行补零操作。 needPadStartZero = true str = this.getNumChar(g) + this.getUnitChar(unitCount) + str &#125; unitCount++ num = Math.floor(num / 10) &#125; return str &#125; /** * 获取整数部分对应中文 * * @param &#123;String|Number&#125; intergerPart 整数部分 * @returns 整数部分对应中文 * @memberof NumberToChinese */ getIntergetPartChn(intergerPart) &#123; const originNum = parseInt(intergerPart) if (!this.isSafeNumber(originNum) || originNum &lt; 0) &#123; return '无法解析成数字或超出范围或不是正数' &#125; if (originNum === 0) return this.getNumChar(0) let sectionsArr = this.getIntergerSections(originNum) let transformedSectionsArr = sectionsArr .reverse() // 翻转小节，从最后一个小节开始翻译 .reduce((acc, cur, index, arr) =&gt; &#123; if (cur === 0) return acc // 非首小节并小于1000的需要前补零 let sectionChn = index !== arr.length - 1 &amp;&amp; cur &lt; 1000 ? this.padStr(this.getSectionsChn(cur), 1, this.getNumChar(0)) : this.getSectionsChn(cur) // 处理首小节为10~19的特殊场景 // 一十一，需要转换成十一 if (index === arr.length - 1 &amp;&amp; cur &gt;= 10 &amp;&amp; cur &lt; 20) &#123; sectionChn = sectionChn.replace(/^一/, '') &#125; sectionChn += this.getSectionUnitChar(index) return acc.concat(sectionChn) &#125;, []) return transformedSectionsArr.reverse().join('') &#125; /** * 浮点数转中文数字 * @param &#123;String|Number&#125; n 需要转换的数字 * @returns 中文数字 */ transform(n) &#123; const num = parseFloat(n) if (!this.isSafeNumber(num)) return '无法解析成数字或超出范围' const &#123; sign, interger, dot, decimal &#125; = this.getParts(num) const signChn = sign ? this.getSignPartChn(sign) : '' const intergerChn = this.getIntergetPartChn(interger) const dotChn = dot ? this.getDotPartChn(dot) : '' const decimalChn = decimal ? this.getDecimalPartChn(decimal) : '' return `$&#123;signChn&#125;$&#123;intergerChn&#125;$&#123;dotChn&#125;$&#123;decimalChn&#125;` &#125;&#125; 调用1234567891011121314151617181920212223242526272829303132333435363738394041const numberToChn = new NumberToChinese()// 整数console.log(numberToChn(1))console.log(numberToChn(2))console.log(numberToChn(11))console.log(numberToChn(19))console.log(numberToChn(123))console.log(numberToChn(103))console.log(numberToChn(1003))console.log(numberToChn(21234))console.log(numberToChn(21003))console.log(numberToChn(123456789))console.log(numberToChn(1000))console.log(numberToChn(10000))console.log(numberToChn(100000))console.log(numberToChn(1000000))console.log(numberToChn(10000000))// 浮点数console.log(0.123)console.log(0.003)console.log(1.003)console.log(10.003)// 零的情况console.log(numberToChn(0))console.log(numberToChn('0'))console.log(numberToChn(0.0))console.log(numberToChn(0.1))console.log(numberToChn(0.01))console.log(numberToChn(0.123456))// 负数情况console.log(numberToChn(-0))console.log(numberToChn(-2))console.log(numberToChn(-10))console.log(numberToChn(-1000))// 内部方法调用console.log(numberToChn.getPars(-1.234)) 参考 https://www.cnblogs.com/liquanjiang/p/8655075.html","tags":[{"name":"库","slug":"库","permalink":"http://yoursite.com/tags/库/"}]},{"title":"v-model-sync","date":"2019-02-22T13:34:48.000Z","path":"2019/02/22/v-model-sync/","text":"v-model、.sync 的异同v-model 实现双向数据绑定(数据 model 改变会自动反映到视图 view 上，视图 view 的数据变化也会同步到数据 model 中)，一般用在表单的双向数据绑定约定俗成的用在表单相关组件上 v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。在调试工具中直接修改这 3 个特性值都不会生效； 语法糖:默认形况下会绑定表单的 value 以及监听 input 事件；可通过 model 选项，配置 v-model 的触发机制 1234567891011121314151617181920212223242526272829303132333435363738&lt;input v-model=\"searchText\"&gt;// 等价于：&lt;input v-bind:value=\"searchText\" v-on:input=\"searchText = $event.target.value\"&gt;// 用在组件上时&lt;custom-input v-bind:value=\"searchText\" v-on:input=\"searchText = $event\" // $event为组件内部派发出来的值&gt;&lt;/custom-input&gt;// custom-input组件必须接受value 以及在 派发input事件；即v-model默认情况下无论是用在原生表单组件还是自定义组件上，都必须绑定value以及监听input事件Vue.component('custom-input', &#123; props: ['value'], template: ` &lt;input v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; `&#125;)// 自定义v-model的触发机制Vue.component('base-checkbox', &#123; model: &#123; // 将v-model的机制调整为 绑定checked和监听change事件 prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;) .sync 修饰符 主要用来实现父子组件间数据的双向传递 单向数据传递为:props down,events up vue 中是不推荐使用双向数据传递的，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源，会带来维护上的问题 但在特殊情况下，有一定实用价值，所以 vue 在 2.3 版本中又添加回来了 本质还是个语法糖 123456789101112131415161718192021222324252627// 在没有.sync时，vue推荐使用下面方式实现子组件修改父组件的数据&lt;text-document v-bind:title=\"doc.title\" v-on:update:title=\"doc.title = $event\"&gt;&lt;/text-document&gt;Vue.component('text-document', &#123; props: &#123; title : String &#125;, template: ` &lt;div v-text=\"title\" @click=\"$emit('update:title','我是新title')\"&gt; &lt;/div&gt; `&#125;)// 为了简化上述流程，推出了.sync修饰符&lt;text-document v-bind:title.sync=\"doc.title\" // 无需再监听update:title事件,但子组件仍需要派发对应自定义事件&gt;&lt;/text-document&gt;Vue.component('text-document', &#123; props: &#123; title : String &#125;, template: ` &lt;div v-text=\"title\" @click=\"$emit('update:title','我是新title')\"&gt; &lt;/div&gt; `&#125;) 二者异同 v-model 默认情况下为 value+input 的组合；.sync 为任意组合 v-model 常用在表单中；.sync 主要用在父子组件通信中，子组件需要修改父组件数据时 可以将 v-model 理解成.sync 的一种特殊情况，二者底层的实现机制类似；v-model 做了数据传递+修改的工作；.sync 更多的是数据传递，修改需要交给用户自己 可以参考 https://blog.csdn.net/Qin_Shuo/article/details/82693919","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-high-level-component","date":"2019-02-22T13:24:37.000Z","path":"2019/02/22/vue-high-level-component/","text":"Vue inheritAttrs、$attrs、$listeners、provide、inject、slot、slotScope不使用 vuex、eventBus 在高层级组件中传递数据 组件调用关系 A-&gt;B-&gt;C （A 调用 B，B 调用 C） 基本概念 inheritAttrs 默认情况下父作用域中的不被子组件认作为 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。 通过设置 B 组件的 inheritAttrs 为 false，可屏蔽掉这种默认行为。B 组件仍可通过$attrs 访问这些不被认作 props的特性 例子 1 例如 A 组件传递了 a,b,c,d 四个参数给 B 组件，但 B 组件实际通过 props 只接收了 a、b 两个个，那么两外两个 c、d 将做为普通 html 特性应用到子组件的根元素上。 通过将 B 的inheritAttrs设置为 false，则可屏蔽这种行为(c、d 将不会做为普通 html 特性应用到子组件的根元素上，但 B 组件仍能接收 a、b)。B 组件仍可通过 this.$attrs 访问到这些不被认作 props 的特性 c、d。 $attrs 包含了父作用域中不被当前组件认作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。 场景如例子 1 B 组件设置了inheritAttrs为 false 后，仍可通过this.$attrs访问到那些不被认作 props 的特性 c、d。 B 组件可在调用 C 组件时，通过在 C 组件上编写v-bind=&quot;$attrs&quot;将这些参数传递到 C 组件中。(这样就可以避免在 B 组件调用 C 组件时，需要在 B 组件的 data 中事先声明 C 组件需要的参数，让 B 组件尽可能的保持 Dry) 通过上述流程其实就完成了 A 组件的参数传递到了更深层次的 C 组件中。 $listeners 包含了父作用域中的 (不含 .native 修饰器的) 挂载在当前组件上的 v-on 事件监听器。 在 B 组件中访问$listeners，将会得到 A 组件写在 B 组件上的所有监听器。 例子 2 A 调用 B 组件，A 在 B 组件上通过@监听了click、enter两个事件，则在 B 组件访问$listeners将会得到click、enter这两个事件监听器，并能直接调用他们。 B 组件调用 C 组件时，可通过在 C 组件上编写v-on=&quot;$listeners&quot;将这些事件监听器传递到 C 组件中。 通过上述流程就实现了 A 组件监听 C 组件触发的事件效果这样就避免了 B 组件需要监听 C 组件的事件，然后做一层转发，进而传递给 A 组件。 provide/inject 以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效 可以理解为一个加强版的 props props 只能完成父向子传递数据，无法完成更深层级组件间的数据传递。 provide/inject二者通常配套使用 provide/inject提供的数据是不可响应的，并且是单向的（祖先-&gt;子孙）。 例子 3123456789101112131415161718192021222324252627282930313233343536373839// 父级A组件提供 'foo'var Provider = &#123; provide: &#123; foo: 'bar' &#125; // ...&#125;// 子孙组件B和C都可以注入 'foo'var Child = &#123; inject: ['foo'], created() &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125;// 设置inject默认值const Child = &#123; inject: &#123; foo: &#123; default: 'foo' &#125; &#125;&#125;// 如果它需要从一个不同名字的属性注入，则使用 from 来表示其源属性const Child = &#123; inject: &#123; foo: &#123; from: 'bar', default: 'foo' &#125; &#125;&#125;// 与 prop 的默认值类似，你需要对非原始值使用一个工厂方法const Child = &#123; inject: &#123; foo: &#123; from: 'bar', default: () =&gt; [1, 2, 3] &#125; &#125;&#125; 在深层级组件中传递 slot slot 元素可通过设置 name 来标识其为一个具名插槽，其本身还可以设置一个 slot 特性用来表示它将应用到子组件的哪个插槽中。 利用上述特性就可以实现在深层级组件中传递 slot 例子 4 A-&gt;B-&gt;C （A 调用 B，B 调用 C） C 中有一个名为 cHd 的具名插槽 B 中有一个名为 bHd 的具名插槽，并设置了 slot 特性为 cHd A 在调用 B 组件时，传入了一个 h1 并设置 slot 特性为 bHd 最终此 h1 将会传递到 C 组件的 cHd 插槽中 slotScope 可参考https://www.jianshu.com/p/0645bc9033a5、https://segmentfault.com/a/1190000015884505 slot-scope 是应用在组件封装者不知道调用者如何使用组件的情况下，开放了一个接口给调用者让其 DIY（自定义样式、业务逻辑）","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"flip","date":"2019-02-21T14:41:40.000Z","path":"2019/02/21/flip/","text":"flip 动画技术前言 尺寸、位置动画会触发重排，导致动画不流畅、动画启动慢 flip 技术主要的目的是将常见的尺寸(width、height)、位置(top、left...)动画映射为性能开销小的transform动画 基本概念 First: 元素的初始状态 Last：元素的最终状态 Invert：反转 Play：开启动画 基本思路 First：获取元素的初始状态 Last：设置元素的状态为运动结束的最终状态 Invert：通过设置相反的transform值将元素从最终状态反转为初始状态 Play：设置元素transition运动属性(缓动、时长等)，再清空transform动画来启动动画 可选的 Clean：动画结束，清除操作 例子12345678910111213141516171819202122// 获取初始位置var first = el.getBoundingClientRect()// 为元素指定一个样式，让元素在最终位置上el.classList.add('end')// 获取最终位置var last = el.getBoundingClientRect()// 如果有必要也可以对其他样式进行计算，但最好坚持只进行 transform 和 opacity 相关的计算var invert = first.top - last.top// 反转el.style.transform = 'translateY(' + invert + 'px)'// 等到下一帧，也就是其他所有的样式都已经被应用requestAnimationFrame(function() &#123; // 添加动画相关的设置 el.classList.add('on-moving') // 开始动画 el.style.transform = ''&#125;)// 结束时清理el.addEventListener('transitionend', clean, false) 实际 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; border: 1px solid red; position: absolute; &#125; .start &#123; left: 100px; top: 50px; &#125; .end &#123; left: 800px; top: 400px; &#125; .on-moving &#123; transition: transform 0.3s linear; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box start\"&gt;box&lt;/div&gt; &lt;script&gt; window.onload = function() &#123; var $el = document.querySelector('.box') $el.addEventListener('click', boot, false) function boot(e) &#123; var that = this // Last this.classList.add('end') // Invert this.style.transform = 'translate3d(-700px,-350px,0)' // -700为 100-800； -350为 50-400 // Play requestAnimationFrame(function() &#123; that.classList.add('on-moving') that.style.transform = '' &#125;) // Clean $el.addEventListener('transitionend', clean, false) function clean(e) &#123; var target = e.target target.classList.remove('on-moving') target.removeEventListener('transitionend', clean, false) &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 其他 demohttp://vuejs.github.io/vue-animated-list/example.htmlhttps://codepen.io/davidkpiano/pen/305a618d4dd75cbe8423183c70d6a43e 参考链接 https://www.w3cplus.com/animation/high-performance-animations.html &gt; https://www.w3cplus.com/javascript/animating-layouts-with-the-flip-technique.html &gt; http://luchun.github.io/animating-layouts-with-the-flip-technique/ &gt; https://codepen.io/davidkpiano/pen/305a618d4dd75cbe8423183c70d6a43e","tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/动画/"},{"name":"flip","slug":"flip","permalink":"http://yoursite.com/tags/flip/"}]},{"title":"vue-analysis-note","date":"2019-01-20T08:57:33.000Z","path":"2019/01/20/vue-analysis-note/","text":"学习黄奕老师的《vue 源码分析》视频的相关笔记仓库地址：https://github.com/BryanAdamss/vue-for-analysis Vue-analysis-note版本 vue 2.5.17-beta.0 Flow静态类型检查器检查方式 类型推断 根据调用的方法，推断入参的类型 类型注释 主动添加入参及返回值的类型 在 vue 中的配置 通过根目录下的.flowconfig进行相关配置 [libs] \\n flow字段指名了flow 自定义类型定义文件的目录为根目录下的flow文件夹12345678flow |--- compiler.js # 编译相关 |--- component.js # 组件数据结构 |--- global-api.js # Global API 结构 |--- modules.js # 第三方库定义 |--- options.js # 选项相关 |--- ssr.js # 服务端渲染相关 |--- vnode.js # virtual node 相关 目录结构src 目录结构 vue 源码存放在 vue 项目的 src 目录下 src 目录结构如下1234567src|--- compiler # 编译相关代码|--- core # 核心代码|--- platforms # 平台相关代码(web/weex)|--- server # 服务端渲染代码|--- sfc # .vue单文件编译成js对象代码|--- shared # 辅助方法及常量 源码构建基于 rollup 构建构建命令123456789// package.json\"scripts\":&#123; ..., \"build\": \"node scripts/build.js\", // 构建web平台 \"build:ssr\": \"npm run build -- web-runtime-cjs,web-server-renderer\", // 构建成服务端渲染 \"build:weex\": \"npm run build -- weex\",// 构建成weex平台 ...&#125; 生成目录12345678910dist|--- vue.common.js|--- vue.esm.browser.js|--- vue.esm.js|--- vue.js|--- vue.min.js|--- vue.runtime.common.js|--- vue.runtime.esm.js|--- vue.runtime.js|--- vue.runtime.min.js 目录结构解释 version UMD CommonJS ES Module Full vue.js vue.common.js vue.esm.js Runtime-only vue.runtime.js vue.runtime.common.js vue.runtime.esm.js Full (production) vue.min.js - - Runtime-only (production) vue.runtime.min.js - - 说明 Full: 包含Compiler + Runtime Compiler: 负责将template字符串编译成vue render函数 Runtime: 负责创建vue实例、渲染、打补丁等 UMD: 可直接使用&lt;script&gt;标签引用的版本；unpkg CDN上https://unpkg.com/vue的默认为compiler+runtime版本(vue.js) CommonJS: 供browserify、webpack1使用 ES Module: 供webpack2、rollup使用 CommonJS及ES Module版本未提供压缩版本，需要通过打包工具自行压缩 Runtime + Compiler vs. Runtime-only Runtime + Compiler 如果需要使用vue的template字段，则需要使用此版本；会在运行时将template字符串编译成render函数 并配置相应webpack别名123456789module.exports = &#123; // ... resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1 &#125; &#125;&#125;` Runtime-only 当使用vue-loader或者vueify时，则可以直接使用此版本，因为*.vue 文件中的tempalte已经在编译阶段自动编译成渲染函数了，所以并不需要compiler，仅需要runtime就可以了 此版本体积比Runtime + Compiler版本体积&lt;~30% 入口文件 web平台的Full版本入口位置 src/platform/web/entry-runtime-with-compiler.js vue最初被定义的位置-src/core/instance/index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546// src/platform/web/entry-runtime-with-compiler.js/* @flow */import config from 'core/config'import &#123; warn, cached &#125; from 'core/util/index'import &#123; mark, measure &#125; from 'core/util/perf'import Vue from './runtime/index'...// src/platform/web/runtime/index.js/* @flow */import Vue from 'core/index'import config from 'core/config'import &#123; extend, noop &#125; from 'shared/util'...// src/core/index.jsimport Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'...// src/core/instance/index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'/* vue 在此处被定义 */function Vue(options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 数据驱动new Vue时发生了什么初始化基本思路 调用new Vue(options) 调用通过initMixin(Vue)方法导入的_init方法 _init内部调用了相关方法，做了一些初始化操作 初始化时如何代理data的? _init方法内部调用initState(vm)方法 initState(vm)方法中调用了initData(vm)方法 initData(vm)方法判断了vm.$options.data的类型(函数或其它)并根据data类型，将获取到的data值赋值给vm._data 遍历检查vm._data中是否有和props、methods重名的key(因为props、methods、data最终都要挂载到vm上，所以不能重名)，未重名时，判断下key是否是vue的保留字(vue中将以$和_开头的字段视为vue保留字,这也是声明data时，data中的key不能以$和_开头的原因) 不是保留字，则调用proxy(vm,&#39;_data&#39;,key)方法将vm.data[key]代理到vm._data[key]上(这也说明了，vue中data申明的数据本质上保存在vm._data上的) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// src/core/instance/index.jsimport &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'// 定义vue类function Vue(options) &#123; // 非生产环境必须通过new 来生成vue 实例 if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; // 初始化，并传入参数 this._init(options) // 此方法在initMixin中定义&#125;initMixin(Vue) // 导入_init方法stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue// src/core/instance/init.js...export function initMixin(Vue: Class&lt;Component&gt;) &#123; // 在Vue原型上定义_init方法 Vue.prototype._init = function(options?: Object) &#123; ... // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) // 初始化组件自身状态(data中定义的数据) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') ... &#125;&#125;// src/core/instance/state.js...const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: noop, set: noop&#125;// 将target[key]代理到target[sourceKey][key]上，主要实现将vm.data[key]代理到vm._data[key]上的操作export function proxy(target: Object, sourceKey: string, key: string) &#123; sharedPropertyDefinition.get = function proxyGetter() &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter(val) &#123; this[sourceKey][key] = val &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;export function initState(vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) // 初始化data &#125; else &#123; observe((vm._data = &#123;&#125;), true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125;function initData(vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; // 将$options中的data取出并赋值给vm._data if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance // 遍历并检查_data的key是否和methods及props重名 const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn(`Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 若key不是vue的保留字($及_开头的默认都是vue保留字，所以vue中申明状态时，不能以$及_开头) // 代理将vm[key]代理到vm[_data][key]上 proxy(vm, `_data`, key) &#125; &#125; // observe data;观测数据 observe(data, true /* asRootData */)&#125; Vue实例挂载的实现基本思路 通过$mount方法实现实例挂载 不同版本的vue实现的挂载方式不同，不过都是在runtime版本的公共$mount基础上，修改以满足不同版本的定制化挂载需求 无论什么版本，vue最终都是需要一个render函数，若是compiler版本，会检查是否有用户编写的render，否则将template编译成render函数供后续流程使用 带compiler版本的$mount调用顺序1.缓存公共$mount方法，供修改后的$mount方法调用2.修改原型上的$mount方法3.若没有指定render函数，则通过template字段获取模板，再调用compileToFunctions方法生成一个render方法绑定到vm.$options上4.调用公共$mount方法5.公共$mount方法内部调用了mountComponent方法6.mountComponent方法内部首先检查了vm.$options.render函数的存在性，不存在，则将创建空vnode的createEmptyVNode方法赋值给vm.$options.render7.在mountComponent方法内部定义了一个updateComponent方法，此方法主要调用了vm._update方法，此方法接收一个vm._render返回的VNode8.mountComponent方法内生成一个渲染watcher实例,渲染watcher实例内部会调用传入的updateComponent方法进行Vue实例挂载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// src/platforms/web/entry-runtime-with-compiler.js...const mount = Vue.prototype.$mount // 缓存了原型上的$mount方法，然后基于compiler版本做了相应修改；原始$mount方法是在./runtime/index.js中定义的Vue.prototype.$mount = function( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) // query返回一个dom元素 // el 不能是body、html元素(因为挂载会替换对应元素) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; // template是一个id选择器，则取其innerHTML template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; // template传入的是一个dom对象,取其innerHTML template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; // 未指定template字段，但el存在，则获取el的outerHTML(innerHTML+el标签自身) template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile') &#125; // 编译，生成render函数 const &#123; render, staticRenderFns &#125; = compileToFunctions( template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this ) // 赋值到options上 options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile end') measure(`vue $&#123;this._name&#125; compile`, 'compile', 'compile end') &#125; &#125; &#125; return mount.call(this, el, hydrating)// 调用缓存的公共$mount方法&#125;...// src/platforms/web/runtime/index.js...// 适用于每个平台的公共$mount方法Vue.prototype.$mount = function( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)// 调用lifecycle中的mountComponent&#125;...// src/core/instance/lifecycle.jsexport function mountComponent( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 将el保存到$el上 if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') &#123; /* istanbul ignore if */ if ( (vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el ) &#123; // 在使用runtime-only版本时，没有写render函数，而是使用了template，此时会报一个警告(使用单文件时，虽然也有template模块，但其在vue-loader时，就已经将其编译成render函数了) warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) &#125; else &#123; // 既没写template也没写render函数 warn( 'Failed to mount component: template or render function not defined.', vm ) &#125; &#125; &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; // 定义updateComponent函数，内部调用vm._update方法，第一个参数为vm._render返回的一个Vnode updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined // 实例化一个渲染watcher，其将立即调用一次updateComponent new Watcher( vm, updateComponent, noop, &#123; before() &#123; if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher 标识此watcher是一个渲染watcher，见Watcher类*/ ) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; vm._render方法 updateComponent方法中主要调用了vm._update方法，vm._update方法则接收一个vm._render方法返回的Vnode vm._render方法定义在src/instance/render.js中 vm._render方法会取出vm.$options.render方法并执行。 vm.$options.render将在vm._renderProxy上下文中执行，并传入一个vm.$createElement方法，最终返回一个vnode vm._renderProxy在src/core/instance/init.js的initProxy方法中定义，其会根据浏览器是否支持Proxy来返回一个Proxy实例还是vm自身,开发环境中是一个Proxy实例，在生产环境中就是vm自身 vm.$createElement在initRender方法中被定义，initRender方法会根据render函数来源(vue编译模板而来还是用户编写的)不同生成不同版本的createElement版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// src/core/instance/lifecycle.jsexport function mountComponent( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; ... let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; ... &#125; else &#123; // 定义updateComponent函数，内部调用vm._update方法，第一个参数为vm._render返回的一个Vnode；vm._render方法定义在src/instance/render.js中 updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125;&#125;// src/core/instance/render.js...// 此方法将在new Vue的过程中被执行，在vm上挂载不同版本的createElement方法export function initRender(vm: Component) &#123; ... // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates // 最后一个标志量是alwaysNormalize（是否总是规范化）,为false 标识此方法是给编译生成的render函数使用 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. // 为true 标识此方法是给用户编写的render函数使用 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) ...&#125;export function renderMixin(Vue: Class&lt;Component&gt;) &#123; ... Vue.prototype._render = function(): VNode &#123; const vm: Component = this // 从$options中拿到用户编写的或者vue生成的render函数 const &#123; render, _parentVnode &#125; = vm.$options ... // render self let vnode try &#123; // 调用render方法；vm._renderProxy在src/instance/init.js中定义；vm._renderProxy在生产环境下就是vm，开发环境下是一个proxy对象; vm.$createElement在initRender方法中被定义 vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; ... &#125; // return empty vnode in case the render function errored out // 创建的vnode并不是VNode实例 if (!(vnode instanceof VNode)) &#123; // vnode为一个数组，则表示我们模板有多个根节点 if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) &#123; warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) &#125; // 创建一个空vnode vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode // 返回一个vnode return vnode &#125;&#125; VirtualDOM出现原因 现有DOM因为历史原因，结构很复杂，每个节点上包含了很多非必要信息(字段)，操作起来性能消耗很大。 为了解决这一问题，人们想出在DOM层上再添加一个速度更多，性能消耗小的层，需要操作DOM时，先操作新层，新层在合适的时机通过一系列算法计算出最小更新范围，再将这些更新应用到DOM层 简单理解就像计算机读写硬盘上的文件一样，如果直接在硬盘上读写文件，速度会很慢。于是人们在硬盘和系统之间加了一层(内存)，内存速度快，系统可以先在内存中对文件进行一系列操作，最后在合适的时机再将文件重新写入硬盘。这样就避免了频繁的操作硬盘了。 VirtualDOM基本思路 VirtualDOM利用结构简单的原生js对象(VNode)去描述一个DOM节点，只保留了必要的字段，这样节点就变得简单了，操作起来速度更快 通过关联相关的VNode组成一个VNode tree 通过相应渲染方法将VNode tree渲染成真正的DOM tree 需要更新DOM tree时，会通过diff算法比较新旧两棵VNode tree，找出差异，得出最小更新范围，通过打补丁的方式(patch)将这些差异更新真正的DOM tree上 通过上述过程，一来简化了节点大小，操作速度提升。二来，降低了变更DOM tree的频率，性能更好。 vue的VirtualDOM实现参考了snabbdom VNode定义 定义在src/core/vdom/vnode.js中 仅保留了一些必要属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* @flow */export default class VNode &#123; tag: string | void // 标签名 data: VNodeData | void // VNode数据 children: ?Array&lt;VNode&gt; // 子节点 text: string | void // 文本 elm: Node | void ns: string | void context: Component | void // rendered in this component's scope key: string | number | void componentOptions: VNodeComponentOptions | void componentInstance: Component | void // component instance parent: VNode | void // component placeholder node // strictly internal raw: boolean // contains raw HTML? (server only) isStatic: boolean // hoisted static node isRootInsert: boolean // necessary for enter transition check isComment: boolean // empty comment placeholder? isCloned: boolean // is a cloned node? isOnce: boolean // is a v-once node? asyncFactory: Function | void // async component factory function asyncMeta: Object | void isAsyncPlaceholder: boolean ssrContext: Object | void fnContext: Component | void // real context vm for functional nodes fnOptions: ?ComponentOptions // for SSR caching fnScopeId: ?string // functional scope id support constructor( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child(): Component | void &#123; return this.componentInstance &#125;&#125;export const createEmptyVNode = (text: string = '') =&gt; &#123; const node = new VNode() node.text = text node.isComment = true return node&#125;export function createTextVNode(val: string | number) &#123; return new VNode(undefined, undefined, undefined, String(val))&#125;// optimized shallow clone// used for static nodes and slot nodes because they may be reused across// multiple renders, cloning them avoids errors when DOM manipulations rely// on their elm reference.export function cloneVNode(vnode: VNode): VNode &#123; const cloned = new VNode( vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory ) cloned.ns = vnode.ns cloned.isStatic = vnode.isStatic cloned.key = vnode.key cloned.isComment = vnode.isComment cloned.fnContext = vnode.fnContext cloned.fnOptions = vnode.fnOptions cloned.fnScopeId = vnode.fnScopeId cloned.asyncMeta = vnode.asyncMeta cloned.isCloned = true return cloned&#125; VNode的创建 通过vm._render方法生成，内部调用vm.$createElement createElement定义 vm.$createElement在内部调用了createElement方法 createElement方法定义在src/core/vdom/create-element.js中 createElement方法内部重设了normalizationType并调用了_createElement方法","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"gitlab-ci","date":"2018-11-19T13:49:38.000Z","path":"2018/11/19/gitlab-ci/","text":"记录搭建 gitlab-ci 服务相关概念；配置太多，很多不是很理解，仅做个记录，方便后期查阅； Gitlab-ci前置概念 持续集成（Continuous Integration） 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起 个人开发代码-&gt;构建、单元测试-&gt;向原有代码上集成 主要用来发现个人开发代码是否能主体代码上集成 持续交付（Continuous Delivery） 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 主要用来将持续集成后的成果进行更加拟真的测试 持续集成成果-&gt;拟真环境测试-&gt;手动部署到生产环境 持续部署（Continuous Deployment） 持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。 将手动部署过程进行自动化 手动部署到生产环境-&gt;自动部署到生产环境中 DevOps DevOps 是一个概念，是 Development 和 Operations 的组合 突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠 它是基于 CI/CD 的一个完整的软件开发自动化流程 起步 基本步骤 仓库根目录添加.gitlab-ci.yml文件并配置相关参数 配置相关 job 具体配置及相关概念参照下面 配置项目启用Runner Runner负责相关 job 的执行 GitLab 和 Runner 之间通过 API 通信，所以 Runner’s machine 要能连接到 Gitlab 服务 Runner 可分为为某一个项目服务的和为多个项目服务的，后者称为Shared Runner 每次push将自动触发 CI 的工作流(pipeline) .gitlab-ci.yml配置 .gitlab-ci.yml是.yml格式文件，注意缩进，始终用空格代替 tab .gitlab-ci.yml主要定义了一些在不同 stage(阶段) 需要执行的 jobs 每个.gitlab-ci.yml文件可以定义无数个job，每个job都定义在.yml的顶层 每个job至少一包含一个script字段 每个job的执行是相互独立、互不干扰的 job不能重名，一些 gitlab 的关键字不能使用，如 image、services、stages、types、before_script、after_script、variables、cache 1234567891011job1: script: - 'npm install'job2: script: - 'npm run test'# job1、job2之间无任何关联，二者在执行时是相互独立的job3:job4:... 每个job可以有一些参数来定义 job 的行为 Keyword Required Description script yes Defines a shell script which is executed by Runner(定义要执行的脚本) extends no Defines a configuration entry that this job is going to inherit from (定义此job将继承于哪个job) image no Use docker image, covered in Using Docker Images (docker镜像) services no Use docker services, covered in Using Docker Images (docker服务) stage no Defines a job stage (default: test)(定义job所属的pipeline阶段，默认是test阶段) type no Alias for stage (stage别名) variables no Define job variables on a job level(定义在当前job执行时生效的变量) only no Defines a list of git refs for which job is created(定义job执行范围及时机) except no Defines a list of git refs for which job is not created(定义job执行范围及时机) tags no Defines a list of tags which are used to select Runner(拥有制定Runner tag的runner才能执行此job) allow_failure no Allow job to fail. Failed job doesn’t contribute to commit status(此job是否允许失败) when no Define when to run job. Can be on_success, on_failure, always or manual (定义job什么时候能被执行，可以是on_success,on_failure,always或者manual) dependencies no Define other jobs that a job depends on so that you can pass artifacts between them(定义了该job依赖哪一个job，如果设置该项，你可以通过artifacts设置) artifacts no Define list of job artifacts(工件。。就是在依赖项之间传递的东西) cache no Define list of files that should be cached between subsequent runs(定义需要被缓存的文件、文件夹列表) before_script no Override a set of commands that are executed before job(在每个job执行前将执行的script) after_script no Override a set of commands that are executed after job(在每个job执行后执行的script) environment no Defines a name of environment to which deployment is done by this job(定义让job完成部署的环境名称) coverage no Define code coverage settings for a given job(允许你设置代码覆盖率输出，其值从job的输出获取) retry no Define when and how many times a job can be auto-retried in case of a failure(定义job失败后的自动重试次数) parallel no Defines how many instances of a job should be run in parallel(最大可并行执行的job实例数) extends 定义job继承行为 使用include能够实现跨配置文件的job继承123456789101112131415161718192021222324# 使用yml的隐藏key来创建隐藏job，通过添加点号来实现。隐藏job将不会被执行，但可以被继承.tests: script: rake test stage: test only: refs: - branchesrspec: extends: .tests script: rake rspec only: variables: - $RSPEC# 继承结果，后定义的将覆盖先定义的rspec: script: rake rspec stage: test only: refs: - branches variables: - $RSPEC before_script、after_script before_script每个job执行前必须执行的script before_script和job的script享有同一执行环境(可访问到job中的变量) after_script每个job执行后必须执行的script after_script无法访问到job中的变量123456789101112# 全局before_script: - global before scriptjob: # 局部，将覆盖全局 before_script: - execute this instead of global before script script: - my command after_script: - execute this after my script stages 定义job所属阶段 可在全局中先定义所有阶段(stage)12345678910111213141516171819202122232425stages: # 预定义需要按顺序执行的阶段 - build - test - deployjob 1: # job1属于build阶段 stage: build script: make build dependenciesjob 2: # job2也属于build阶段 stage: build script: make build artifactsjob 3: # job3属于test阶段 stage: test script: make testjob 4: # job4属于deploy阶段 stage: deploy script: make deploy script job唯一必填字段 指定此job需要执行的脚本，可是一个也可是多个123456789job1: # 指定一个脚本 script: \"bundle exec rspec\"job2: # 指定顺序执行的两个脚本 script: - uname -a - bundle exec rspec only、expect 指定此job的执行范围或时机，在哪个branch或者tag上执行，在何时触发12345678job: # use regexp only: - /^issue-.*$/ # use special keyword except: - branches# 只会在issue-的ref上触发此任务，并派出了所有branche tags 用来指定可以运行此job的Runner，每个Runner在创建时可以指定一个Runner&#39;s tag12345job: # 拥有ruby、postgres标签的runner才能执行此job tags: - ruby - postgres allow_failure 是否允许此job执行失败 正常情况，如果job执行失败，会中断后续stage的job执行 若为true，将不中断后续stage的job执行 when 标识当前job，在stage中某一job执行失败或所有job执行成功时才执行 关键字 on_success 在前一stage中所有job都执行成功后再执行 on_failure 在前一stage中有一个job执行失败时，就立即执行 always 无论前一stage成功或失败都将执行此job manual 手动执行123456789101112131415161718192021222324252627282930313233343536stages: - build - cleanup_build - test - deploy - cleanupbuild_job: stage: build script: - make buildcleanup_build_job: stage: cleanup_build script: - cleanup build when failed when: on_failuretest_job: stage: test script: - make testdeploy_job: stage: deploy script: - make deploy when: manualcleanup_job: stage: cleanup script: - cleanup after jobs when: always# cleanup_build_job将只在build阶段失败时执行# cleanup_job无论前面阶段是否执行成功都将执行 environment 是用于定义一个job部署到某个具名的环境 environment:on_stop、environment:action on_stop指定在环境关闭时执行某个job action关键字和on_stop关键字相关，定义在job的environment中，用于响应关闭环境的操作123456789101112131415review_app: stage: deploy script: make deploy-app environment: name: review on_stop: stop_review_appstop_review_app: stage: deploy script: make delete-app when: manual environment: name: review action: stop# 我们建立了一个review_app并部署到review环境，并且我们在on_stop下同样定义了一个新的job名为stop_review_app。一旦review_app作业成功完成，ci将可以在手动操作的时候触发stop_review_app的任务，在这个例子中，我们使用when来达到手动触发停止review app的功能 artifacts artifacts 被用于在job作业成功后将制定列表里的文件或文件夹附加到job上，传递给下一个job，如果要在两个job之间传递artifacts，你必须设置dependencies, 传递文件/文件夹 1234artifacts: paths: - binaries/ - .config 传递git没有追踪的文件 12artifacts: untracked: true 只为打tags的行为创建artifacts 1234567891011121314default-job: script: - mvn test -U except: - tagsrelease-job: script: - mvn package -U artifacts: paths: - target/*.war only: - tags 创创建一个压缩包，命名为“job名_分支名”并包含为被git跟踪的文件 1234job: artifacts: name: \"$&#123;CI_JOB_NAME&#125;_$&#123;CI_COMMIT_REF_NAME&#125;\" untracked: true 当失败时上传artifacts 123job: artifacts: when: on_failure -设置artifacts一星期过期，默认artifacts会永远保存在gitlab中 123job: artifacts: expire_in: 1 week cache 定义在不同job间需要缓存的文件、文件夹(并不明白他和artifacts的区别) dependencies dependencies需要结合artifacts使用，只有定义了依赖关系的job才可以传递artifacts(怀疑中?) coverage coverage 允许你设置代码覆盖率输出，其值从job的输出获取123job1: script: rspec coverage: '/Code coverage: \\d+\\.\\d+/' parallel 最大可并行执行的job实例数123test: script: rspec parallel: 5 include 导入其他配置文件12345include: 'https://gitlab.com/awesome-project/raw/master/.before-script-template.yml'rspec: script: - bundle exec rspec variables 定义变量1234567# 全局变量variables: DATABASE_URL: \"postgres://postgres@postgres/my_database\"job_name: # 局部变量 variables: &#123;&#125; Git Strategy 你可以通过在全局变量设置位置或者job局部变量设置位置来设置GIT_STRATEGY用以获取应用最近更新的代码。1234567891011# clone是最慢的选项，如果设置该值，每个job将会都克隆一遍仓库，确保项目工作空间总是原始的正确的。variables: GIT_STRATEGY: clone# fetch是更快的操作选项，因为他重用了项目的工作空间（如果没有的话，会去clone）, git clean用于撤销上一个job的任何操作，git fetch是用来重新获取上一个job运行到当前job产生的commitvariables: GIT_STRATEGY: fetch# none也同样重用了项目空间（但是他会跳过所有git操作，包括如果存在的gitlab runner的预克隆脚本）。其主要用于只是为了操作artifacts的job上（例如depoly部署行为）。此时Git仓库的数据可能是存在的，但它一定不是最新的。所以在设置了none的job里你应该依赖从cache或者artifacts来的数据，而不是仓库数据。variables: GIT_STRATEGY: none Git checkout 用来指定job执行时是否需要执行git checkout命令1234567variables: GIT_STRATEGY: clone # 全局定义，执行job时无需checkout GIT_CHECKOUT: \"false\"script: - git checkout master - git merge $CI_BUILD_REF_NAME Shallow cloning 你可以通过GIT_DEPTH来设置抓取或者克隆深度。这将使得仓库进行浅克隆， 如果你的仓库有特别大量的commits或者仓库好久没更新了，该设置将显著的提高克隆速度。该参数会发送给git fetch和git clone操作(其实就相当于git fetch –depth=xxx, git clone –depth=xxx。但是由于git fetch和git clone是runner在执行job时帮你做的，所以需要此配置。)1234# 抓取或者克隆最新三条commits:variables: GIT_DEPTH: \"3\" 隐藏job job名前添加点号即可，此job不被执行，但可以被继承123.hidden_job: script: - run test Anchors 类似混入概念 1234567891011121314151617181920212223242526272829303132333435363738.job_template: &amp;job_definition # Hidden key that defines an anchor named 'job_definition' image: ruby:2.1 services: - postgres - redistest1: &lt;&lt;: *job_definition # Merge the contents of the 'job_definition' alias script: - test1 projecttest2: &lt;&lt;: *job_definition # Merge the contents of the 'job_definition' alias script: - test2 project# 结果.job_template: image: ruby:2.1 services: - postgres - redistest1: image: ruby:2.1 services: - postgres - redis script: - test1 projecttest2: image: ruby:2.1 services: - postgres - redis script: - test2 project 跳过job 如果你的commit信息包涵[ci skip]或者[skip ci]，此次提交将不被job执行 总结 script 定义具体脚本 job 每个job可以执行一个或多个script 多个script按定义时顺序先后执行 stage 每个阶段由不同job组成 每个job并行执行互不干扰 只有当前stage所有job都执行成功，才能进入下一阶段。一个job执行失败，标识此阶段fail pipeline 由多个阶段组成(build-&gt;test-&gt;deploy) Runner负责管理调配执行上述过程 参考 https://segmentfault.com/a/1190000011881435https://segmentfault.com/a/1190000011890710#articleHeader31","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"},{"name":"gitlab-ci","slug":"gitlab-ci","permalink":"http://yoursite.com/tags/gitlab-ci/"}]},{"title":"vuex-guide","date":"2018-11-07T11:06:56.000Z","path":"2018/11/07/vuex-guide/","text":"重读了一遍 vuex 文档，用自己的语言记录了一部分东西，方便自己后期查找 Vuex安装 Vuex 依赖 Promise。如果你支持的浏览器并没有实现 Promise (比如 IE)，那么你可以使用一个 polyfill 的库，例如 es6-promise 什么情况需要 Vuex 相互嵌套的组件多，需要相互共享、传递数据时。 简单方案:EventBus、provide/inject、inheritAttrs/$attrs/$listeners 或者手动实现一个订阅者模式 概念 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。 Vuex 的状态存储是响应式的。当组件从 store 中获取状态后，后期只要状态变更了，组件就会自动更新 DOM 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 State Vuex 单一状态树 一个对象包含了全部的应用状态 单例模式：每个应用将仅仅包含一个 store 实例 在 Vue 组件中获得 Vuex 状态 在计算属性中返回某个状态 12345678910111213141516171819202122// app.vueconst app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;)// counter.vueconst Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;&#125; 实际生产中，一般不直接获取 State，而是通过 Getter 间接获取 State mapState 使用 mapState 辅助函数帮助我们生成计算属性（将状态映射成计算属性） mapState 返回的是一个对象，对象中包含了获取对应状态的方法定义，所以合适用 computed 接收 123456789101112131415161718192021222324252627282930313233// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState(state) &#123; return state.count + this.localCount &#125; &#125;)&#125;// 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。computed: mapState([ // 映射 this.count 为 store.state.count 'count'])// 合并现有computed，使用对象展开运算符computed: &#123; localComputed () &#123; /* ... */ &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; // ... &#125;)&#125; Getter 派生状态 基于原始状态，派生出一些新状态(类似计算属性) 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 每个 getter 在调用时会被传入 state 和 getters state 包含了当前所有原始状态，等价 store.state getters 包含了当前所有 getters，等价 store.getters 传参给 Getter 让 getter 返回一个函数，来实现给 getter 传参12345678getters: &#123; // ... getTodoById: state =&gt; id =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125;// 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果 mapGetters 返回一个对象，包含获取 Getter 的方法定义，所以合适用 computed 接收 12345678910111213141516171819import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter' // ... ]) &#125;&#125;// 如果你想将一个 getter 属性另取一个名字，使用对象形式：mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount'&#125;) Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 每个 mutation 都像一个事件处理器 有一个事件类型 type 和一个回调函数 handler 123456789101112131415161718const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, // 声明有哪些mutation mutations: &#123; // 这里的函数名increment相当于事件中的事件类型type increment(state) &#123; // 函数体相当于事件中的回调handler // 变更状态 state.count++ &#125; &#125;&#125;)// 提交mutation// 相当于触发某一事件类型（increment），将会自动调用对应的回调handlerstore.commit('increment') 每个 mutation 在调用时会被传入 state 和 payload state 包含了当前所有原始状态，等价 store.state payload 为额外参数 提交载荷(Payload) 可理解为提交 mutation 时的额外参数 1234567891011121314151617181920212223242526272829// 例子1，普通Payloadmutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10)// 例子2，对象Payloadmutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123; amount: 10&#125;)// 例子3，对象风格的提交方式mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit(&#123; type: 'increment', amount: 10&#125;) mapMutations mapMutations，返回的是一个对象，包含 mutation 定义，而 mutation 更像一个方法，所以使用 methods 接收合适。 12345678910111213141516import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; Mutation 需遵守 Vue 的响应规则 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, ‘newProp’, 123), 或者 以新对象替换老对象（扩展运算符） 使用常量替代 Mutation 事件类型 单独创建一个 mutation-types.js 保存整个 APP 的 mutation 类型 方便 eslint，方便他人查看 123456789101112131415// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) mutation 必须是同步函数 调试工具无法准确捕捉到每次记录，难以调试 异步操作可以使用 action 完成 Action Action 类似于 mutation，不同在于： Action 通过提交 mutation 来变更状态，而不是直接变更状态。所以 vuex 中唯一能改变状态的方法就是提交 mutation Action 可以包含任意异步操作。 每个 action 在被调用时，会被传入一个 context 对象和 payload context 为一个对象，包含以下属性，可利用解构提取 state, // 等同于 store.state，若在模块中则为局部状态 rootState, // 等同于 store.state，只存在于模块中 commit, // 等同于 store.commit dispatch, // 等同于 store.dispatch getters, // 等同于 store.getters rootGetters // 等同于 store.getters，只存在于模块中 payload 为额外参数 Action 定义及派发 123456789101112131415161718192021222324252627282930const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;, actions: &#123; incrementAsync(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125; &#125;&#125;)store.dispatch('incrementAsync')// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) mapActions 返回的是一个对象，包含 action 定义，而 action 更像一个方法，所以使用 methods 接收合适。 12345678910111213141516import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 组合 Action 返回 promise 12345678910111213141516171819202122232425actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125;store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;)// 在另外一个 action 中也可以：actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 小总结 state 原始状态 mapState 结合 computed 使用 getters 基于原始状态派生的一些状态，类似计算属性 mapGetters 结合 computed 使用 每个 getter 在调用时会被传入 state 和 getters state 包含了当前所有原始状态，等价 store.state getters 包含了当前所有 getters，等价 store.getters mutations 用来变更某一原始状态，不能直接变更派生状态 getter 通过 commit 提交 mutation mutation 中做的任务一般为同步任务，且较为简单 mapMutations 结合 methos 使用 每个 mutation 在调用时会被传入 state 和 payload state 包含了当前所有原始状态，等价 store.state payload 为额外参数 actions 负责复杂的异步任务 不能直接变更原始状态，需要提交 mutation 来变更原始状态 mapActions 结合 methods 使用 每个 action 在被调用时，会被传入一个 context 对象和 payload context 为一个对象，包含以下属性，可利用解构提取 state, // 等同于 store.state，若在模块中则为局部状态 rootState, // 等同于 store.state，只存在于模块中 commit, // 等同于 store.commit dispatch, // 等同于 store.dispatch getters, // 等同于 store.getters rootGetters // 等同于 store.getters，只存在于模块中 payload 为额外参数 Module 复杂应用中，Vuex 允许将 store 切割成模块 注意并不是创建了另外一个 store，全局中仍然只有一个 store，因为其是单例模式 拆分成的模块依旧包含 state、getters、mutations、actions 1234567891011121314151617181920212223242526const moduleA = &#123; state: &#123;...&#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; test:'cgh' &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; // 定义模块 modules: &#123; a: moduleA, b: moduleB &#125;&#125;)// 引用模块store.state.a // -&gt; 访问moduleA 的所有状态store.state.b.test // -&gt; 访问moduleB 的某一状态，不必store.state.b.state.test 模块内部的局部状态 模块内部定义的 mutation、getter 接受到的第一个参数是模块的局部状态对象 可通过 第三个参数 rootState 访问到根节点状态 模块内部定义的 action 接受到的 context.state 也是模块的局部状态对象 可通过 context.rootState 访问到根节点状态 123456789101112131415161718192021222324const moduleA = &#123; // 模块内局部状态 state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; // 这里的 `state` 对象是模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount(state, getters, rootState) &#123; return state.count * 2 &#125; &#125;, actions: &#123; incrementIfOddOnRootSum(&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit('increment') &#125; &#125; &#125;&#125; 命名空间 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 注意模块内部的状态仍然是挂在对应模块内部的，而不是在根状态节点上。即 store.state.moduleA.cgh 而不是 store.state.cgh 可以给模块添加 namespaced:true ，让其成为一个带命名空间的模块 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。 模块 A 使用 namespaced:true 后,A 内再嵌套模块 B 时，模块 B 会默认继承父模块 A 的命名空间 如下面例子中的 getters[&#39;account/profile&#39;] 当模块 B 再添加 namespaced:true,模块 B 会在默认继承 A 的命名空间前提下，再添加自己的命名空间 如下面例子中的 getters[&#39;account/posts/popular&#39;] 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: &#123; ... &#125;, getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: &#123; ... &#125;, getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;) 启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit 参数，即在模块内部提交模块内部的 mutation、派发内部的 action、获取内部的 getter 时，不需要添加额外的空间名前缀(vuex 隐式帮我们添加了空间前缀，会默认获取模块内的资源)。更改 namespaced 属性后也不需要修改模块内的代码。 在带命名空间的模块内访问全局内容 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 12345678910111213141516171819202122232425262728293031modules: &#123; foo: &#123; namespaced: true, getters: &#123; // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) &#123; getters.someOtherGetter // -&gt; 'foo/someOtherGetter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter' &#125;, someOtherGetter: state =&gt; &#123; ... &#125; &#125;, actions: &#123; // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' dispatch('someOtherAction', null, &#123; root: true &#125;) // -&gt; 'someOtherAction' commit('someMutation') // -&gt; 'foo/someMutation' commit('someMutation', null, &#123; root: true &#125;) // -&gt; 'someMutation' &#125;, someOtherAction (ctx, payload) &#123; ... &#125; &#125; &#125;&#125; 在带命名空间的模块注册全局 action 若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。 12345678910111213141516171819&#123; actions: &#123; someOtherAction (&#123;dispatch&#125;) &#123; dispatch('someAction') &#125; &#125;, modules: &#123; foo: &#123; namespaced: true, actions: &#123; someAction: &#123; root: true, handler (namespacedContext, payload) &#123; ... &#125; // -&gt; 'someAction' &#125; &#125; &#125; &#125;&#125; 带命名空间的 mapState、mapGetters、mapMutations、mapActions 辅助函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748computed: &#123; ...mapState(&#123; a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b &#125;)&#125;,methods: &#123; ...mapActions([ 'some/nested/module/foo', // -&gt; this['some/nested/module/foo']() 'some/nested/module/bar' // -&gt; this['some/nested/module/bar']() ])&#125;// 可将命名空间做为第一个参数传递给辅助函数computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions('some/nested/module', [ 'foo', // -&gt; this.foo() 'bar' // -&gt; this.bar() ])&#125;// 可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数import &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('some/nested/module')export default &#123; computed: &#123; // 在 `some/nested/module` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) &#125;&#125; 模块动态注册 在 store 创建之后，你可以使用 store.registerModule 方法注册模块 可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。 12345678// 注册模块 `myModule`store.registerModule('myModule', &#123; // ...&#125;)// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], &#123; // ...&#125;) 注册一个新 module 时，你很有可能想保留过去的 state 可以通过 preserveState 选项将其归档：store.registerModule(‘a’, module, { preserveState: true })。 插件 内置 logger 插件 1234567import createLogger from 'vuex/dist/logger'const debug = process.env.NODE_ENV !== 'production'const store = new Vuex.Store(&#123; plugins: debug ? [createLogger()] : [] // * 开发模式启用log工具&#125;) 严格模式 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到 12345const debug = process.env.NODE_ENV !== 'production'const store = new Vuex.Store(&#123; strict: debug&#125;) 表单处理 在严格模式，在属于 vuex 的 state 上使用 v-model 会报错(没有通过 commit 提交 mutation 而直接改变了状态) 可以将 v-model 使用原始方法实现(:value+@input) 1234567891011121314151617181920&lt;input :value=\"message\" @input=\"updateMessage\"&gt;// ...computed: &#123; ...mapState(&#123; message: state =&gt; state.obj.message &#125;)&#125;,methods: &#123; updateMessage (e) &#123; this.$store.commit('updateMessage', e.target.value) &#125;&#125;// storemutations: &#123; updateMessage (state, message) &#123; state.obj.message = message &#125;&#125; 使用带有 setter 的双向绑定计算属性(推荐) 12345678910111213&lt;input v-model=\"message\"&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125;&#125;","tags":[{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"name-style","date":"2018-11-07T11:04:47.000Z","path":"2018/11/07/name-style/","text":"工作中，经常因命名规范而头疼，所以特意整理了部分规范，就便后期查找 文件及文件夹命名规范原则 命名尽量简短，不要产生多个单词；尽量采用约定俗称的名称； 需要重点标识的可采用特殊标识去； 规范 文件夹 多个单词时：统一采用全小写+连字符；如 source-codehttp://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html 特殊情况需要特别标识的可以采用帕斯卡命名方式，如 vue 组件的文件夹 SyncClass 文件 统一采用全小写+连字符形式：auto-height.js 特殊情况需要特别标识的可以采用帕斯卡命名方式，如 vue 组件 SyncClass.vue 特殊文件可采用全大写形式，如 README 文件内部内容命名 js 变量 驼峰 isLoading js 常量 大写+下划线 ERROR_TEXT sass 变量 $开头，小写+连字符 $color-red vue 组件 name 帕斯卡 name:&#39;ErrorCorrection&#39; 组件调用 帕斯卡 &lt;ErrorCorrection&gt;&lt;/ErrorCorrection&gt;","tags":[{"name":"命名","slug":"命名","permalink":"http://yoursite.com/tags/命名/"}]},{"title":"chrome-devtools","date":"2018-09-14T15:22:21.000Z","path":"2018/09/14/chrome-devtools/","text":"记录 chrome 调试工具的一些常用技巧没有时间详细整理，想到什么记录什么 Chrome Devtools 常用技巧网络请求相关拷贝网络请求地址 选择NetWorkTab 右键一个网络请求 选择copy 选择copy link address即可拷贝某一请求实际地址 注意 如果直接双击一个网络请求会打开一个新标签页，然后会请求对应网络地址，如果有装JSONView可以直接查看对应结果 拷贝网络请求的 response 选择NetWorkTab 右键一个网络请求 选择copy 选择copy response即可 注意 选择copy response拷贝出的 response 是没有经过格式化的(没有缩进),可以通过类似json.cn等在线网站进行美化，或者使用JSON.stringify(obj,null,4)或者在console中使用copy方法进行美化，如下面例子 1234567copy(&#123;\"most_visited\": [], \"history_on\": false, \"recent\": []&#125;)// * 将得到下面美化后的结果&#123; \"most_visited\": [], \"history_on\": false, \"recent\": []&#125; 将网络请求转换为 fetch 形式 选择NetWorkTab 右键一个网络请求 选择copy 选择copy as fetch即可，devtools 会将请求的相关参数都拼装好并放到一个 fetch 中，可以直接调用 123456789fetch('https://developers.google.com/profile/userhistory', &#123; credentials: 'include', headers: &#123;&#125;, referrer: 'https://developers.google.com/web/tools/chrome-devtools/sources', referrerPolicy: 'no-referrer-when-downgrade', body: null, method: 'GET', mode: 'cors'&#125;) 如何判断网站是否开启 gzip 比较资源大小 在NetWork Tab 的左上角选择Use large request rows 选中后，重新加载页面 在size列会出现两个资源大小，上面是实际下载资源的大小，下面的是原始资源大小，如果二者大小几乎一致，则可以判定网站未开启gzip 下面为开启后的 其它方法 查看网络请求的response header的Content-Encoding是否为gzip 注意 在开启gzip时，需要忽略图片格式，因为针对图片开启 gzip 不但不会缩减大小，反倒会增大图片资源的传输大小，适得其反 命令相关CommandMenu 和很多工具一样，devtools 也有命令菜单，可以通过ctrl+shift+p唤出 可以通过输入命令的形式使用 devtools 或者打开特定菜单 常用command ctrl+p-&gt;直接输入，则查找文件 ctrl+p-&gt;输入?-&gt;查看帮助 ctrl+p-&gt;输入:-&gt;跳转特定行 ctrl+p-&gt;输入@-&gt;跳转到特定符号处(symbol) ctrl+p-&gt;输入!-&gt;运行 snippet ctrl+p-&gt;输入&gt;-&gt;命令菜单 创建所有页面都能使用的 snippet(代码片段) 例如有些网站没有引入jQuery，此时可以创建一个在任何页面都能使用的插入jQuery的代码片段 使用ctrl+shift+p打开 CommandMenu，输入Create new snippet 拷贝下面的代码，ctrl+s保存并ctrl+enter执行 你会发现在页面的head标签下已经引入一个 jQuery 了 12345let script = document.createElement('script')script.src = 'https://code.jquery.com/jquery-3.2.1.min.js'script.crossOrigin = 'anonymous'script.integrity = 'sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4='document.head.appendChild(script) 快速执行一个已经创建的 snippet 使用ctrl+p，输入!，即会列出所有 snippet，选择一个执行即可 格式化源码 有时源码会进行压缩或者格式不对，需要对其进行格式化 在source Tab 下打开的js、html、css文件，在右下角会展示一个Format按钮(大概长这样{})，点击即可格式化当前代码 格式化后 console 相关将 DOM 元素格式化为 JavaScript 对象 使用console.dir(dom元素) 使用$0 在ElementTab 中选择一个元素，然后使用$0可以引用这个 DOM 元素 例如下面打印出 DOM 元素 12345// * 打印选中的DOM元素console.log($0)// * 如果需要转成JS对象，可以使用dirconsole.dir($0) 在vue-devtools中有类似变量，可以使用$vm0引用选中组件 在 console.log 中使用 css 样式 使用%c 12// * 使用%cconsole.log('%c我将是蓝色的%c我是绿色的', 'color: blue; ', 'color:green;') 快速清除 console 面板内容 使用ctrl+l或者clear() 查看 js、css 中的无用代码使用 coverage ctrl+shift+p输入Show Coverage并选择之 会列出css、js中没有生效的占比 点击其中一条，会打开对应文件，左侧红色代表未生效的代码行，绿色代表已经执行过的代码行 未完待续","tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"},{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"},{"name":"DevTools","slug":"DevTools","permalink":"http://yoursite.com/tags/DevTools/"}]},{"title":"git","date":"2018-08-18T07:52:08.000Z","path":"2018/08/18/git/","text":"工作中经常会用到 git,都只是停留在简单的操作上，对于出现的问题也只会百度解决，无法知其所以然，所以准备好好了解一下 git，做到知其所以然。以下为阅读《progit》做的一些笔记，方便后期查阅。 Git起步同其他版本控制系统的差异 Git 存储的是项目随时间改变的快照而不是与初始版本的差异 Git 存储的是每个改变点项目整体快照 如果某文件没有被修改，Git 不会重新存储该文件 其他常见版本控制系统存储的是每个文件与初始版本的差异 Git 近乎所有操作都是本地执行 速度快 可以离线操作 Git 保证完整性 用 SHA-1 散列（hash，哈希）来计算校验和，这意味着不可能在 Git 不知情的情况下更改任何文件内容和目录 SHA-1 散列长这样124b9da6552252987aa493b52f8696cd6d3b00373 Git 管理的文件的三种状态 通过 Git 管理的文件会处于下面三种状态之一 已提交(committed) 已提交表示数据已经安全的保存在本地数据库中 已修改(modified) 已修改表示修改了文件，但还没保存到数据库中 已暂存(staged) 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 Git 的三个工作区域 Git 仓库目录(.git 文件夹) Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据 工作目录(当前目录) 工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改 暂存区域(一个保存了下次提交信息的文件) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。别名索引 基本的 Git 工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git 的三个存储配置地方 /etc/gitconfig 系统通用配置，针对系统中的每个用户都有效； 可用带有--system选项的git config命令让 Git 读取此配置 win 系统下，此配置文件在 Git 安装目录中 ~/.gitconfig或~/.config/git/config，此配置仅针对当前用户有效； 可用带有--global选项的git config命令让 Git 读取此配置。 win 系统下，此文件保存在c/users/用户/.config文件中 当前仓库下面的.git/config，此配置仅针对当前仓库有效。 可用带有--local选项的git config命令让 Git 读取此配置 在某仓库下直接git config相当于git config --local 三种配置的优先级： 仓库&gt;当前用户&gt;通用配置 设置用户信息 针对当前用户配置基本用户信息 12git config --global user.name &quot;John Doe&quot;git config --global user.email johndoe@example.com --global只需运行一次 检查配置信息1git config --list Git 会列出所有配置项 Git 基础获取 Git 仓库 在现有项目或目录下导入所有文件到 Git 中 12cd project/git init 从一个服务器克隆一个现有的 Git 仓库 1git clone [url] url 支持下面几种类型协议 https git:// ssh Git 文件状态的生命周期 工作目录下的文件 未使用 Git 追踪的 (Untracked)文件 使用 add 操作，状态会变成Staged 使用 Git 追踪的(Tracked)文件 未修改过的(Unmodified) 文件编辑后状态会变成Modified 删除文件后，状态会变成Untracked 修改过的(Modified) Modified状态的文件使用暂存操作，状态会变成(Staged) 暂存过的(Staged) 使用 commit 操作后，状态会变成Unmodified 查看当前文件状态(git status) git status git status -s或者git status --short 使用紧凑格式展示状态 123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt ??代表未追踪 A代表已经暂存 空格M代表文件已经修改过了，但还没有放入暂存区中 M空格代表文件已经修改过了，并且已经放入暂存区中 MM代表在工作区被修改并提交到暂存区后又在工作区中被修改了 暂存已修改文件/将未追踪文件添加到追踪列表中(git add) git add 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等 本质:“添加内容到下一次提交中”-&gt;将文件添加到暂存区中，用于下次提交 忽略文件(.gitignore) 添加.gitignore文件 以#开头的行代表注释 可以使用 glob 模式(正则)匹配。 [abc]代表匹配 abc 其中一个字符 a/**/z代表a/z、a/b/z、a/b/c/z 以（/）开头防止递归。 以（/）结尾指定目录。 可以在模式前加上惊叹号（!）取反。 123456789101112# 忽略任何.a文件*.a# 不忽略lib.a文件!lib.a# 仅仅忽略当前目录下下的TODO文件，不忽略当前目录子目录下面的TODO文件/TODO# 忽略build目录下面的所有文件build/# 忽略doc目录下的.txt文件，但不忽略doc子目录下的.txt文件doc/*.txt# 忽略doc所有目录下的所有.pdf文件doc/**/*.pdf 查看差异(git diff) 查看当前工作目录尚未暂存的文件更新了什么-&gt;当前工作目录文件和暂存区域中快照文件的差异 git diff 比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容 git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因 查看当前工作目录已经暂存的文件更新了什么，暂存区域与你最后提交之间的差异-&gt;暂存区域快照和最后一次提交之间的差异 git diff --cached和git diff --staged(二者是同一个意思) 提交更新(git commit) git commit 提交一次更新(暂存区的一次快照)到本地仓库中 提交的是放在暂存区域的快照 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较 git commit -m &quot;[fix] - 修复一个bug&quot; 添加提交说明 跳过暂存区域直接提交更新(git commit -a) git commit -a Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 移除文件(git rm) git rm &lt;file&gt; 从暂存区和工作区中移除某一文件 git rm --cached &lt;file&gt; 只从暂存区中移除某一文件，但会保留工作区的文件 移动文件(git mv) Git 不会显示追踪文件的移动，文件移动可以分解成多个动作 git mv README.md README 等价于下面三个动作123$ mv README.md README$ git rm README.md$ git add README 查看提交历史(git log) git log 会列出所有更新(提交)。最近的更新在最上面 git log --stat 会附带每次提交简略的统计信息 git log --pretty=oneline 将每个提交放在一行，方便查看 自定义 pretty 格式 git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 常用选项123456789101112131415%H 提交对象（commit）的完整哈希字串%h 提交对象的简短哈希字串%T 树对象（tree）的完整哈希字串%t 树对象的简短哈希字串%P 父对象（parent）的完整哈希字串%p 父对象的简短哈希字串%an 作者（author）的名字%ae 作者的电子邮件地址%ad 作者修订日期（可以用 --date= 选项定制格式）%ar 作者修订日期，按多久以前的方式显示%cn 提交者(committer)的名字%ce 提交者的电子邮件地址%cd 提交日期%cr 提交日期，按多久以前的方式显示%s 提交说明 使用图表形式查看 git log --graph 限制条件 git log -2 -&gt; 显示最近 2 个提交 git log --author=&quot;xxx&quot; -&gt; 查找对应作者的提交 git log --committer=&quot;xxx&quot; -&gt; 查找对应提交者的提交 git log --grep=&quot;xxx&quot; -&gt; 查找有对应关键词的提交 git log -Sstringname -&gt; 查找删除/添加了 stringname 字符串的提交 git log --since=&quot;2018-08-22 21:43&quot; -&gt; 特定时间点之后的提交 常见限制选项 1234567-(n) 仅显示最近的 n 条提交--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。--grep 仅显示含指定关键字的提交-S 仅显示添加或移除了某个关键字的提交 撤销操作 Git 撤销是不可逆的 重新修改(覆盖)上次commit git commit --amend 可以修改上次提交时的 message 并重新提交(覆盖之前提交)，如果在此命令之前执行了添加文件到暂存区的操作，则会在此次提交时带上新添加到暂存区中的文件。 123git commit -m &apos;inital&apos;git add test.txtgit commit --amend 则 test.txt 也会被包含到这次提交中 将某文件从暂存区中移出 git reset HEAD &lt;file&gt;12git add test.txtgit reset HEAD test.txt 撤销工作区中对文件的修改(放弃所有更改) git checkout -- &lt;file&gt; 12echo test &gt; test.txtgit checkout -- test.txt 本质是拿之前一个版本的文件来覆盖当前文件 远程仓库的使用查看已经配置的远程仓库(git remote) 使用git remote 查看所有已经配置的远程仓库的简写；默认名为origin 使用git remote -v 查看所有远程仓库的简写及对应 url 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 origin为简写 查看远程仓库详细信息 使用git remote show origin 展示远程仓库origin的详细信息 123456789101112$ git remote show origin* remote originFetch URL: https://github.com/schacon/ticgitPush URL: https://github.com/schacon/ticgitHEAD branch: masterRemote branches:master trackeddev-branch trackedLocal branch configured for &apos;git pull&apos;:master merges with remote masterLocal ref configured for &apos;git push&apos;:master pushes to master (up to date) 会告诉你当前处于 master 分支，以及git pull和git push时关联的远程分支 添加远程仓库(git remote add) git remote add &lt;shortname&gt; &lt;url&gt; 添加一个仓库地址为url,简写名为shortname的仓库 从远程仓库中抓取与拉取 git fetch [remote-repo-short-name] fetch仅仅会访问远程仓库，从中拉取所有你还没有的数据(远程仓库中本地还没有的数据)，并不会跟当前工作区文件进行合并或修改他们。仅仅是拉取下来供你查看 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。- 推送到远程仓库(git push) git push [remote-repo-short-name] [remote-branch-name] 推送本地当前分支到远程的特定分支上 默认情况下省略remote-repo-short-name和remote-branch-name时，则默认推送到origin的master分支上123git push// 等价于git push origin master 修改远程分支的本地引用名 使用git remote rename &lt;oldName&gt; &lt;newName&gt; 1234$ git remote rename pb paul$ git remoteoriginpaul 切断本地仓库和远程仓库之间的关联 使用git remote rm &lt;remote-repo-short-name&gt; 123$ git remote rm paul$ git remoteorigin 标签查看所有标签 使用git tag 会列出所有tag名 使用正则 git tag -l &#39;v1.8.*&#39;1234567891011$ git tag -l &apos;v1.8.5*&apos;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5 创建标签 使用git tag -a &lt;tagName&gt; -m [messages] 12345$ git tag -a v1.4 -m &apos;my version 1.4&apos;$ git tagv0.1v1.3v1.4 查看某一 tag 详细信息 使用git show &lt;tagName&gt;123456789$ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700changed the version number 针对某次提交打 tag 使用git tag -a &lt;tagName&gt; &lt;commitHash&gt;12// 针对9fceb02版本打tag$ git tag -a v1.2 9fceb02 推送 tag 到远程仓库 使用git push &lt;remote-repo-short-name&gt; [local-tag-name] 类似推送分支到远程仓库12// 推送本地的v1.5tag到远程的origin仓库$ git push origin v1.5 一次推送多个 tag 到远程仓库 使用git push &lt;remote-repo-short-name&gt; --tags12// 把所有不在远程仓库服务器上的标签全部传送到那里$ git push origin --tags 检出某一标签 使用git checkout -b [branchname] [tagname] 相当于重新开了一个分支 12$ git checkout -b version2 v2.0.0Switched to a new branch &apos;version2&apos; 给 Git 命令起别名 通过配置config文件 123456// 可以用git co代替git checkout$ git config --global alias.co checkout// 用git br 代替 git branch$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status Git 分支未完待续","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"oop-basic-in-js","date":"2018-04-27T02:23:58.000Z","path":"2018/04/27/oop-basic-in-js/","text":"最近在复习基础知识，特对js面向对象相关知识做个记录 js中的面向对象编程基础知识创建对象字面量模式 最简单也是最常用创建简单对象的方式 12345678var personCgh=&#123; name:'cgh', age:'18', sex:'boy', sayName:function()&#123; alert(this.name); &#125;&#125;; 缺点 如果需要创建大量类似的对象，会产生大量重复代码 工厂模式 抽象(封装)创建具体对象的过程 123456789101112function createPersonFactory(name,age,sex)&#123; var o=new Object(); o.name=name; o.age=age; o.sex=sex; o.sayName=function()&#123; alert(this.name); &#125;; return o;&#125;var personCgh=createPersonFactory('cgh',18,'boy'); 解决了字面量模式创建多个类似对象的问题 缺点 无法知道一个对象的类型 构造函数模式 通过创建自定义构造函数并通过new来创建实例 12345678910111213function Person(name,age,sex)&#123; this.name=name; this.age=age; this.sex=sex; this.sayName=function()&#123; alert(this.name); &#125;;&#125;var personCgh=new Person('cgh',18,'boy');personCgh instanceof Person; // truepersonCgh instanceof Object; // true 缺点 每个方法都需要在实例上重新创建一遍 原型模式 每个函数在创建时都会自动生成一个原型(prototype)属性，指向函数的原型对象;原型对象会自动获得一个constructor属性指向prototype属性所在的函数； 实例对象、构造函数、原型对象三者关系 构造函数被创建时，会有一个prototype属性指向原型对象 原型对象通过constructor反向指回构造函数 构造函数通过实例化过程(new过程)创建实例对象 实例对象通过内部[[prototype]]或者__proto__属性(不可直接访问)指向原型对象12345678910111213141516171819202122function Person()&#123;&#125;Person.prototype=&#123; constructor:Person,// 因为完全重写了prototype对象，所以必须定义constructor指向 name:'cgh', age:18, sex:'boy', friends:['a','b'], sayName:function()&#123; alert(this.name) &#125;&#125;;var personCgh=new Person();var personYg=new Person();personCgh.friends.push('c');personCgh.friends; // ['a','b','c']personYg.friends; // ['a','b','c']personCgh.name === personYg.name; // true 缺点 会存在共享引用值的问题 组合使用构造函数模式和原型模式 使用构造函数创建实例属性，用原型模式创建共享的方法和属性 常用模式12345678910111213141516171819function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=['a','b'];&#125;Person.prototype=&#123; constructor:Person, sayName:function()&#123; alert(this.name); &#125;&#125;;var personCgh=new Person('cgh',18,'boy');var personYg=new Person('yg',14,'boy');personCgh.friends.push('c'); // ['a','b','c']personYg.friends; // ['a','b'] new的过程 new Fn操作符主要完成了下面几件事情 创建一个新的空对象tempObj，空对象的默认原型对象(__proto__)为Object.prototype 设置空对象的__proto__指向构造函数的原型对象； 调用构造函数，构造函数的this指向tempObj； 如果构造函数返回的是一个非null的引用类型的对象，则用此对象替代tempObj成为new操作的返回对象 new会将返回对象的__proto__指向构造函数的.prototype对象12345678910111213function Test()&#123; this.name='test';&#125;var test=new Test();// new Test实际执行的伪代码...&#123; var temp=&#123;&#125;;// 创建临时对象 temp.__proto__=Test.prototype;// 改变__ptoto__指向 var ret=Test.call(tempObj); return ret!==null &amp;&amp; (typeof ret === 'object'|| typeof ret === 'function') ? ret : temp ;// 如果构造函数调用后返回的是非null的引用类型，则用其替代temp做为new操作符的返回值&#125; 继承使用原型链实现继承 让一个类(构造函数，基类)的原型对象指向另一个类(构造函数，父类)的实例即可 123456789101112131415161718192021function SuperType()&#123; this.property=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.property;&#125;;function SubType()&#123; this.subProperty=false;&#125;// 继承父类 基类的原型对象指向父类的一个实例SubType.prototype=new SuperType();SubType.prototype.getSubVaule=function()&#123; return this.subProperty;&#125;;var instance=new SubType();instance.getSuperValue();// true 如果基类要覆盖父类方法一定要在继承之后再覆盖 缺点 父类上定义的引用类型值将会被共享 无法在不影响所有对象实例的基础上，给父类的构造函数传递参数 借用构造函数实现继承 通过在子类的构造函数中调用父类的构造函数来实现继承 12345678910111213141516function SuperType(name)&#123; this.colors=['red','blue'] this.name=name;&#125;function SubType()&#123; SuperType.call(this);&#125;var instance1=new SubType('cgh');instance1.colors.push('green');var instance2=new SubType('yg');instance1.colors;// ['red','blue','green']instance2.colors;// ['red','blue'] 缺点 方法都将在构造函数中定义，无法实现方法的复用 组合继承 借用构造函数+原型链 使用原型链实现对原型属性、方法的继承，使用借用构造函数实现实例属性的继承1234567891011121314151617181920212223242526272829303132333435function SuperType(name)&#123; this.name=name; this.colors=['red','blue'];&#125;SuperType.prototype.sayName=function()&#123; alert(this.name);&#125;;function SubType(name,age)&#123; // 继承属性 SuperType.call(this,name); this.age=age;&#125;// 继承方法SubType.prototype=new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; alert(this.age);&#125;;var instance1=new SubType('cgh',20);instance1.colors.push('green');instance1.colors;// ['red','blue','green'];instance1.sayName();// 'cgh'instance1.sayAge();// 20var instance2=new SubType('yg',18);instance1.colors.push('pink');instance1.colors;// ['red','blue','pink'];instance1.sayName();// 'yg'instance1.sayAge();// 18 原型继承 通过改变对象内部的__proto__指针来实现 不需要显示的创建构造函数 思路直接以一个对象为原型，从其克隆出一个新对象 123456789function object(o)&#123; function F()&#123;&#125; F.prototype=o;// 指定原型对象 return new F();// 通过new 调用将返回对象的__proto__指向F.prototype即o &#125;// 本质是将返回对象的__proto__指向了传入对象var returnObj=object(testObj);returnObj.__proto__===testObj;//true es5对这种方式做了标准化。直接使用Object.create()来实现 12345678910var a=&#123; name:'cgh', sayName:function()&#123; alert(this.name); &#125; &#125;;var b=Object.create(a);b.name='yg';b.sayName();// yg 实现继承的本质 js中实现继承的关键在__proto__这个内部指针 首先基础知识 js中万物都是对象，没有实际的类(可以靠模拟实现类的效果)、函数、构造函数(本质就是普通函数)、原型对象(xxx.prototype)，这些都是对象 每个对象都有__proto__这个内部指针 每个函数都有.prototype这个属性 所有函数都是对象；所以函数既有__proto__也有.prototype 内部通过__proto__来构建原型链实现类似继承效果，即方法属性的查找通过__proto__链来一层层查找;(类似作用域链的回溯查找) 所有原型链最后端都是Object.prototype，Object.prototype这个对象的__proto__则指向了null __proto__和fn.prototype不一样，前者才是实现继承的关键，后者只是为了模拟传统类继承而衍生出来方便表达的属性。可以当作一个普通对象对待(但它又有不同，它默认自带constructor指回函数)12345678910111213141516171819202122232425262728293031323334var o = &#123;a: 1&#125;;// o 这个对象继承了Object.prototype上面的所有属性// o 自身没有名为 hasOwnProperty 的属性// hasOwnProperty 是 Object.prototype 的属性// 因此 o 继承了 Object.prototype 的 hasOwnProperty// Object.prototype 的原型为 null// 原型链如下:// o ---&gt; Object.prototype ---&gt; null// o.__proto___===Object.prototype;// true// Object.prototype.__proto__===null;// truevar a = [\"yo\", \"whadup\", \"?\"];// 数组都继承于 Array.prototype // (Array.prototype 中包含 indexOf, forEach等方法)// 原型链如下:// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null// a.__proto__===Array.prototype;// true// Array.prototype.__proto__===Object.prototype;// true// Object.prototype.__proto__===null;// truefunction f()&#123; return 2;&#125;// 函数都继承于Function.prototype// (Function.prototype 中包含 call, bind等方法)// 原型链如下:// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null// f.__proto__===Function.prototype;// true// Function.prototype.__proto__===Object.prototype;// true// Object.prototype.__proto__===null;// true js中万物都是对象，不一定非要模拟传统语言先有类(模板)再创建实例的形式来实现继承效果呢？为什么不能直接用一个对象做为模板，直接克隆出另一个类似对象呢?js内部通过__proto_，来实现两个对象之间的关联(委托)关系，进而实现类似继承的效果。 原型继承和Object.create()都是类似思想，直接通过建立两个对象间的委托关系，实现继承效果12345678910var a=&#123; name:'cgh', sayName:function()&#123; alert(this.name); &#125; &#125;;var b=Object.create(a);b.name='yg';b.sayName();// yg __proto__是一个内部属性，es6对其做了规范可以通过Object.getPrototypeOf和对应的Object.setPrototypeOf来操作__proto__ 参考链接https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chainhttps://www.zhihu.com/question/34183746","tags":[{"name":"oop","slug":"oop","permalink":"http://yoursite.com/tags/oop/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"创建对象","slug":"创建对象","permalink":"http://yoursite.com/tags/创建对象/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}]},{"title":"design-pattern","date":"2018-04-25T02:18:10.000Z","path":"2018/04/25/design-pattern/","text":"此文是《JavaScript设计模式与开发实践》的读书笔记本文所有源码可在这里找到 JavaScript设计模式与开发实践基础知识鸭子类型1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 鸭子类型 // 如果它走起来像鸭子，叫起来也像鸭子，那它就是鸭子 // 鸭子类型指导我们只关注对象的行为，而不关注对象本身 var duck = &#123; duckSinging: function() &#123; console.log(\"嘎嘎\"); &#125; &#125;; var chicken = &#123; duckSinging: function() &#123; console.log(\"嘎嘎\"); &#125; &#125;; // 合唱团 var choir = []; var joinChoir = function(animal) &#123; if (animal &amp;&amp; typeof animal.duckSinging === \"function\") &#123; choir.push(animal); console.log(\"恭喜加入合唱团\"); console.log(\"合唱团当前人数:\" + choir.length); &#125; &#125;; joinChoir(duck); joinChoir(chicken); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多态12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 多态:同一操作应用在不同的对象上面，可以产生不同的解释和不同的执行结果 // 即给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈 var makeSound = function(animal) &#123; if (animal instanceof Duck) &#123; console.log(\"嘎嘎\"); &#125; else if (animal instanceof Chicken) &#123; console.log(\"咯咯\"); &#125; &#125;; var Duck = function() &#123;&#125;; var Chicken = function() &#123;&#125;; makeSound(new Duck()); makeSound(new Chicken()); // 这里是不优雅的，因为如果再来一条狗，需要修改makeSound &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多态212345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 多态背后是将\"做什么\"和\"谁去做，怎么做\"分离开来，即将不变的和可变的分离开来 // 把不变的隔离出来，把可变的部分封装起来,叫是不变的，动物怎么叫是可变的 // 隔离出不变的 var makeSound = function(animal) &#123; animal.sound(); &#125;; // 封装可变的 var Duck = function() &#123;&#125;; Duck.prototype.sound = function() &#123; console.log(\"嘎嘎\"); &#125;; var Chicken = function() &#123;&#125;; Chicken.prototype.sound = function() &#123; console.log(\"咯咯\"); &#125;; makeSound(new Duck()); makeSound(new Chicken()); // 添加新动物 var Dog = function() &#123;&#125;; Dog.prototype.sound = function() &#123; console.log(\"汪汪\"); &#125;; makeSound(new Dog()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 多态31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var googleMap = &#123; show: function() &#123; console.log('开始渲染谷歌地图'); &#125; &#125;; var baiduMap = &#123; show: function() &#123; console.log('开始渲染百度地图'); &#125; &#125;; var renderMap = function(type) &#123; if (type === 'google') &#123; googleMap.show(); &#125; else if (type === 'baidu') &#123; baiduMap.show(); &#125; &#125;; renderMap('google'); // 输出：开始渲染谷歌地图 renderMap('baidu'); // 输出：开始渲染百度地图 // 如果添加其他地图，则需要在renderMap中继续判断，这里显示地图是不变的，显示哪个，怎么显示是可变的，所以可将show隔离(提取)出来 var renderMap2 = function(map) &#123; if (map.show instanceof Function) &#123; map.show(); &#125; &#125;; // 添加其他地图 var sosoMap = &#123; show: function() &#123; console.log(\"开始渲染Soso地图\"); &#125; &#125;; renderMap2(googleMap); // 输出：开始渲染谷歌地图 renderMap2(baiduMap); // 输出：开始渲染百度地图 renderMap2(sosoMap); // 输出:开始渲染Soso地图 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装数据123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // js一般通过函数来创建作用域来封装数据 var myObj = (function() &#123; // 私有变量 var _name = \"haha\"; return &#123; // 公开方法 getName: function() &#123; return _name; &#125; &#125; &#125;)(); console.log(myObj.getName()); // \"haha\" console.log(myObj._name); // undefined &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装实现1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 封装实现，例如sort()函数的具体实现你并不知道，它对外界来说是透明的，不可见的 var arr = [1, 3, 5, 2, 4, 9, 7]; console.log(arr.sort()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原型模式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 原型模式是用来创建对象的一种模式，如果想创建一个对象有2种方法 // 1.先指定类型，然后通过类型创建对象 // 2.找到一个对象做为原型，通过克隆创建一个一模一样的对象 // 原型模式是选用的第二种 // 使用场景:创建一个跟某个对象一模一样的对象时 // 实现关键:语言本身是否提供了克隆的方法,js中可用Object.create() var Plane = function() &#123; this.blood = 100; this.attackLevel = 1; this.defenseLevel = 1; &#125;; var plane = new Plane(); plane.blood = 500; plane.attackLevel = 3; plane.defenseLevel = 4; // Object.create的兼容 Object.create = Object.create || function(obj) &#123; var F = function() &#123;&#125;; F.prototype = obj; return new F(); &#125;; // 克隆 var clonePlane = Object.create(plane); console.log(clonePlane); console.log(clonePlane.blood); console.log(clonePlane.attackLevel); console.log(clonePlane.defenseLevel); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; this1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // js中this是在函数被调用时才确定的，它是指向被调用时的执行环境 // 1.全局环境下this-&gt;window console.log(this); // window // 2.当函数做为对象方法调用时,this指向此对象 var a = &#123; name: \"aaaa\", getName: function() &#123; console.log(this.name); &#125; &#125;; a.getName(); // aaaa (a.getName)(); // aaaa (a.getName = a.getName)(); // 空 (a.getName || a.getName)(); // 空 (a.getName, a.getName)(); // 空 // 注意this是指向最靠近方法的对象 var b = &#123; name: \"bbbb\" &#125;; b.bar = a; b.bar.getName(); // aaaa // 3.匿名函数的执行环境具有全局性，所以this通常指向window (function() &#123; console.log(this); // window &#125;)(); // 4.做为构造器调用时,this指向被新创建的对象 var Person = function(name) &#123; this.name = name; &#125;; var person = new Person(\"haha\"); console.log(person.name); // 5.Function.prototype.call 或Function.prototype.apply 可以动态地改变传入函数的this a.getName.call(b); // bbbb 相当于b.getName() a.getName.apply(b); // bbbb 相当于b.getName() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; call、apply123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // call、apply都可以改变函数中this的指向 // 第一个参数都指定了函数体内this的指向，如果传入null,则代表在全局环境下调用。apply的第二个参数为带下标的集合(类数组),call参数个数不限制，会按顺序依依对应到形参上 var func = function(a, b, c) &#123; console.log([a, b, c]); &#125;; func.apply(null, [1, 2, 3]); // 输出 [ 1, 2, 3 ] func.call(null, 1, 2, 3); // 输出 [ 1, 2, 3 ] // call、apply通常用来实现函数借用，用来在类数组(arguments)上调用数组的方法 // 函数的参数列表arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素 // arguments转成真正的数组的时候，可以借用Array.prototype.slice方法 // 想截取arguments列表中的头一个元素时，可以借用Array.prototype.shift方法。 (function() &#123; Array.prototype.push.call(arguments, 6); console.log(arguments); // 输出[4,5,6] &#125;)(4, 5); // 通过call、apply实现绑定this Function.prototype.bind = function() &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的this上下文,arguments上为shift方法，通过call来实现调用数组的shift方法 args = [].slice.call(arguments); // 剩余的参数转成数组 return function() &#123; // 返回一个新的函数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); // 执行新的函数的时候，会把之前传入的context 当作新函数体内的this // 并且组合两次分别传入的参数，作为新函数的参数 &#125; &#125;; var obj = &#123; name: 'sven' &#125;; var func = function(a, b, c, d) &#123; alert(this.name); // 输出：sven alert([a, b, c, d]) &#125;.bind(obj, 1, 2); // 将func中的this绑定到obj上，并传入了默认参数 func(3, 4); // 输出：[ 1, 2, 3, 4 ] &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; // 函数中声明另外一个函数就会出现闭包 // 经典案例，每个都弹出5 var nodes = document.getElementsByTagName('div'); // for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; // nodes[i].onclick = function() &#123; // alert(i); // &#125;; // &#125;; // 这是因为onclick事件是异步触发的，当触发时for循环早结束了，i已经变成5了，所以事件处理函数中引用的i都为5 // 修正 for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; (function(i) &#123; nodes[i].onclick = function() &#123; alert(i); &#125; &#125;)(i) &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用闭包创建测试类型函数12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var Type = &#123;&#125;; for (var i = 0, type; type = ['String', 'Array', 'Number'][i++];) &#123; // 当语句2条件为false时，就会退出for循环，当i为3时，type[3]为undefined，为false跳出循环 // 利用闭包创建判断类型的函数 (function(type) &#123; Type['is' + type] = function(obj) &#123; return Object.prototype.toString.call(obj) === '[object ' + type + ']'; &#125; &#125;)(type) &#125;; Type.isArray([]); // 输出：true Type.isString(\"str\"); // 输出：true &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 闭包封装变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 乘积 // 1.普通方法 var mult = function() &#123; var a = 1; for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; a *= arguments[i]; &#125; return a; &#125;; console.log(mult(8, 9)); // 72 // 2.进阶添加缓存机制 var cache = &#123;&#125;; var mult2 = function() &#123; var args = Array.prototype.join.call(arguments, \",\"); // 将实参数组转换为字符串 if (cache[args]) &#123; // cache中存在原先的计算结果，则直接返回结果 console.log(\"我是从缓存2取的\"); return cache[args]; &#125; var a = 1; for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; a *= arguments[i]; &#125; // 将结果存入缓存中 cache[args] = a; return a; &#125;; console.log(mult2(8, 9)); // console.log(cache); console.log(mult2(8, 9)); // 3.超进阶使用闭包封装cache，因为这个cache是单独属于mult3的，所以可以封装到mult3中 var mult3 = (function() &#123; var cache3 = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments, \",\"); // 将实参数组转换为字符串 if (args in cache3) &#123; // cache中存在原先的计算结果，则直接返回结果 console.log(\"我是从缓存3取的\"); return cache3[args]; &#125; var a = 1; for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; a *= arguments[i]; &#125; // 将结果存入缓存中 cache3[args] = a; return a; &#125;; &#125;)(); console.log(mult3(8, 10)); console.log(mult3(8, 10)); // console.log(cache3); // error // 4.Max版本提炼函数 var mult4 = (function() &#123; var cache4 = &#123;&#125;; // 将重复使用到的计算提炼出来 var calcuate = function() &#123; var a = 1; for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; a *= arguments[i]; &#125; return a; &#125;; return function() &#123; var args = Array.prototype.join.call(arguments, \",\"); // 将实参数组转换为字符串 if (args in cache4) &#123; // cache中存在原先的计算结果，则直接返回结果 console.log(\"我是从缓存4取的\"); return cache4[args]; &#125; // 全局环境下调用calcuate cache4[args] = calcuate.apply(null, arguments); return cache4[args]; &#125;; &#125;)(); console.log(mult4(9, 9)); console.log(mult4(9, 9)); // console.log(calcuate);// error &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 回调函数1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var appendDiv = function(callback) &#123; for (var i = 0; i &lt; 100; i++) &#123; var div = document.createElement(\"div\"); div.innerHTML = i; document.body.appendChild(div); if (typeof callback === \"function\") &#123; callback(div); &#125; &#125; &#125;; appendDiv(); // 通过回调函数来确定是否隐藏 appendDiv(function(node) &#123; node.style.display = \"none\"; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AOP1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // AOP 面向切片编程，将跟核心业务无关的功能抽离出来，再通过动态织入 Function.prototype.before = function(beforefn) &#123; var __self = this; // 保存原函数的引用 return function() &#123; // 返回包含了原函数和新函数的\"代理\"函数 beforefn.apply(this, arguments); // 执行新函数，修正this return __self.apply(this, arguments); // 执行原函数 &#125; &#125;; Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125; &#125;; var func = function() &#123; console.log(2); &#125;; func = func.before(function() &#123; console.log(1); &#125;).after(function() &#123; console.log(3); &#125;); func(); // 1,2,3 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 函数柯里化12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 柯里化一般用于创建已经设置好了一个或多个参数的函数(创建带有默认参数值函数的过程) var curry = function(fn) &#123; var _args = Array.prototype.slice.call(arguments, 1); //保存默认参数, 一般curry接收的第一个参数为需要柯里化的函数，后面的实参都是要设置为默认值的参数 console.log(_args); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); // 新参数 var finalArgs = _args.concat(innerArgs); // 最终参数 return fn.apply(null, finalArgs); // 在全局调用柯里化好的函数 &#125;; &#125;; function add(num1, num2) &#123; return num1 + num2; &#125; var curriedAdd = curry(add, 5); // curriedAdd此时已经有一个默认参数5了， 使用时就只用再传入一个参数 console.log(curriedAdd(3)); //8 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 反柯理化123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 将特有函数普通化 Function.prototype.uncurrying = function() &#123; var _self = this; // 保存原函数 return function() &#123; var obj = Array.prototype.shift.call(arguments); // 保存调用环境 return _self.apply(obj, arguments); // 调用原函数 &#125;; &#125;; // 反柯里化的另一种写法 // Function.prototype.uncurrying = function() &#123; // var _self = this; // return function() &#123; // return Function.prototype.call.apply(_self, arguments); // &#125;; // &#125;; var push = Array.prototype.push.uncurrying(); (function() &#123; push(arguments, 4); console.log(arguments); // 输出：[1, 2, 3, 4] &#125;)(1, 2, 3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 函数截流123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 有些时候函数会被系统频繁的触发,如window.onresize事件、mousemove、上传进度时会频繁触发相应的处理函数 // 实现函数节流可通过setTimeout延迟执行来解决 var throttle = function(fn, interval) &#123; var _self = fn, //保存需要被延迟的函数 firstTime = true, // 是否首次调用 intervalTime = interval || 500, // 间隔调用时间，默认500毫秒 timer; // 定时器 return function() &#123; var args = arguments, _me = this; if (firstTime) &#123; // 如果第一次，则无需延迟，直接调用 _self.apply(_me, args); return firstTime = false; &#125; if (timer) &#123; // 如果定时器存在，说明前一次执行还没有完成 return false; &#125; timer = setTimeout(function() &#123; // 延迟intervalTime后执行 clearTimeout(timer); timer = null; _self.apply(_me, args); &#125;, intervalTime); &#125;; &#125;; window.onresize = throttle(function() &#123; console.log(1); // 只触发了几次 &#125;, 1000); // window.onresize = function() &#123; // console.log(1); // 几十次 // &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 分时函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 当一次性往DOM中添加大量节点，浏览器会卡死，所以需要分时间添加节点 // var ary = []; // for (var i = 1; i &lt;= 99999; i++) &#123; // ary.push(i); // 假设ary 装载了1000 个好友的数据 // &#125;; // var renderFriendList = function(data) &#123; // for (var i = 0, l = data.length; i &lt; l; i++) &#123; // var div = document.createElement('div'); // div.innerHTML = i; // document.body.appendChild(div); // &#125; // &#125;; // renderFriendList(ary); /** * 实现分时的函数，在intervalTime时间间隔内执行count次fn函数 * @author cgh * @time 2017-03-06 * @param &#123;Array&#125; ary 每次fn执行需要的参数数组 * @param &#123;Function&#125; fn 处理函数 * @param &#123;Number&#125; count 每个时间间隔内执行的次数 * @param &#123;Number&#125; intervalTime 时间间隔 * @return &#123;Function&#125; 函数 */ var timeChunk = function(ary, fn, count, interval) &#123; var obj, t, len = ary.length, intervalTime = interval || 200; // 默认时间间隔200ms var start = function() &#123; for (var i = 0; i &lt; Math.min(count || 1, len); i++) &#123; obj = ary.shift(); fn(obj); &#125; &#125;; return function() &#123; t = setInterval(function() &#123; if (ary.length === 0) &#123; return clearInterval(t); &#125; start(); &#125;, intervalTime); &#125;; &#125;; var ary = []; for (var i = 1; i &lt;= 800; i++) &#123; ary.push(i); &#125;; // 每隔500ms创建8个节点插入到DOM中 var renderFriendList = timeChunk(ary, function(n) &#123; var div = document.createElement('div'); div.innerHTML = n; document.body.appendChild(div); &#125;, 8, 500); renderFriendList(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 惰性载入函数1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;点我绑定事件&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var addEvent = function(elem, type, handler) &#123; // 首次点击时判断绑定方式，后续点击时无需再判断 if (window.addEventListener) &#123; addEvent = function(elem, type, handler) &#123; elem.addEventListener(type, handler, false); &#125; &#125; else if (window.attachEvent) &#123; addEvent = function(elem, type, handler) &#123; elem.attachEvent('on' + type, handler); &#125; &#125; addEvent(elem, type, handler); &#125;; var div = document.getElementById('div1'); addEvent(div, 'click', function() &#123; alert(1); &#125;); addEvent(div, 'click', function() &#123; alert(2); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 单例模式基本定义12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 单例模式:保证一个类仅有一个实例，并提供一个访问它的全局访问点 // 使用场景:当某些对象只需要一个的时候，如线程池、全局缓存、window等 // 使用举例:如登录页，点击按钮生成登录框，这个登录框只会生成一次，不会每次点击都生成一个 var Singleton = function(name) &#123; this.name = name; this.instance = null; &#125;; Singleton.prototype.getName = function() &#123; alert(this.name); &#125;; Singleton.getInstance = function(name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance; &#125;; var a = Singleton.getInstance(\"AAA\"); var b = Singleton.getInstance(\"BBB\"); console.log(a === b); //true // 此种方法通过getInstance来获取实例，和正常的new不一样，用户必须知道这是个单例模式，也就是用户必须知道是通过getInstance方法来获取实例而不是new方式，所就这种方式对用户来说\"不透明\" &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 透明的单例模式123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 实例化时不是通过特殊的方法来实现，实例化和平常一样使用new var CreateDiv = (function() &#123; var instance; var CreateDiv = function(html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125;; CreateDiv.prototype.init = function() &#123; var div = document.createElement(\"div\"); div.innerHTML = this.html; document.body.appendChild(div); &#125;; return CreateDiv; &#125;)(); var a = new CreateDiv(\"div1\"); var b = new CreateDiv(\"div2\"); console.log(a === b); // true // 不足:此处的构造函数做了2件事，1.创建对象并初始化2.保证只有一个对象。如果某天需要在页面中创建多个div，则需要手动修改此构造函数，所以推荐用代理实现单例模式 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用代理实现单例模式1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var CreateDiv = function(html) &#123; this.html = html; this.init(); &#125;; CreateDiv.prototype.init = function() &#123; var div = document.createElement(\"div\"); div.innerHTML = this.html; document.body.appendChild(div); &#125;; // 引入代理,来保证实例的单一性 var ProxySingletonCreateDiv = (function() &#123; var instance; return function(html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;; &#125;)(); var a = new ProxySingletonCreateDiv(\"div1\"); var b = new ProxySingletonCreateDiv(\"div2\"); console.log(a === b); //true // 这样创建div和保证单一性就分开了，后期也好修改 // 这些方法都和传统的面向对象编程一样，先有类，再创建实例 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js中的单例模式12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 单例模式的核心是只有一个实例，并提供全局访问，所以在JS中无需脱裤子放屁，先创建个类，再从类创建实例，可以直接用全局变量(对象)来创建单例 // 全局对象满足单例的两个核心点，一个实例并提供全局访问，虽然全局对象不是单例模式，但在JS中会把全局对象当做单例模式来用 // 但全局变量(对象)会造成全局变量污染，所以需要避免，可通过下面方式 // 使用命名空间 var namespace1 = &#123; a: function() &#123; alert(1); &#125;, b: function() &#123; alert(2); &#125; &#125;; // 使用闭包封装私有变量 var user = (function() &#123; var _name = \"aaa\"; var _age = 18; return &#123; getUserInfo: functioin() &#123; return _name + \":\" + _age; &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 惰性单例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; // 惰性单例指的是在需要的时候才创建对象实例，实际在19中Singleton.getInstance就是在需要的时候创建实例，并非一开始就创建 // 利用全局变量(对象)和惰性单例来实现登录弹窗对象的创建 // var loginLayer = (function() &#123; // var div = document.createElement(\"div\"); // div.innerHTML = \"我是登录窗口\"; // div.style.display = 'none'; // document.body.appendChild(div); // return div; // &#125;)(); // document.getElementById('loginBtn').onclick = function() &#123; // loginLayer.style.display = 'block'; // &#125;; // 上面这种在页面加载的时候就会创建一个登录窗口，如果用户根本不点登录的时候也会创建，所以会浪费 // 改进 // var createLoginLayer = function() &#123; // var div = document.createElement(\"div\"); // div.innerHTML = \"我是登录窗口\"; // div.style.display = 'none'; // document.body.appendChild(div); // return div; // &#125;; // document.getElementById('loginBtn').onclick = function() &#123; // var loginLayer = createLoginLayer(); // loginLayer.style.display = 'block'; // &#125;; // 这样虽然不会一载入就创建，但是没有保证单例，多次点击会创建多个 // 改进 var createLoginLayer = (function() &#123; var div; return function() &#123; if (!div) &#123; div = document.createElement(\"div\"); div.innerHTML = \"我是登录窗口\"; div.style.display = \"none\"; document.body.appendChild(div); &#125; return div; &#125;; &#125;)(); document.getElementById('loginBtn').onclick = function() &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;; // 上面的方式已经能实现基本功能，但是仔细观察会发现，他将创建对象和管理单例的逻辑放在了一起，加入下次想创建一个iframe，就必须将上面代码再抄一遍 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通用的惰性单例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt; &lt;button id=\"loginBtn2\"&gt;登录2&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; // 将23中的管理单例的逻辑给隔离(抽象)出来，实现创建和管理的分离 // 管理单例 var getSingle = function(fn) &#123; var result; return function() &#123; return result || (result = fn.apply(this, arguments)); &#125;; &#125;; // 创建login对象 var createLoginLayer = function() &#123; var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild(div); return div; &#125;; var createSingleLoginLayer = getSingle(createLoginLayer); document.getElementById('loginBtn').onclick = function() &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; &#125;; // 创建iframe对象 var createIframe = function() &#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe; &#125; var createSingleIframe = getSingle(createIframe); document.getElementById('loginBtn2').onclick = function() &#123; var loginLayer = createSingleIframe(); loginLayer.src = 'http://baidu.com'; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 策略模式基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 策略模式:定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换。策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。它将算法的实现和使用分离 // 应用场景:当需要根据不同策略(算法)计算时;实践中，不仅可以封装算法，也可以用来封装几乎任何类型的规则，是要在分析过程中需要在不同时间应用不同的业务规则，就可以考虑是要策略模式来处理各种变化。 // 使用举例:根据工资和绩效等级计算年终奖、缓动动画、表单验证，这三种都是会有多中不同的策略，如年终奖有SAB三等级3个策略，最终都是要得到年终奖。缓动动画有ease-in,ease-out...，最后是要得到一个动画。表单验证需要验证数字、邮箱...等，但最终都要得到是否验证通过这一结果。都是需要根据不同策略，得出某结果 // 组成部分:1.一组策略类，封装了算法，并负责具体计算2.环境类Contex，负责接收请求，并把请求委托给某个具体的策略类 // var calculateBonus = function(performanceLevel, salary) &#123; // if (performanceLevel === \"S\") &#123; // return salary * 4; // &#125; // if (performanceLevel === \"A\") &#123; // return salary * 3; // &#125; // if (performanceLevel === \"B\") &#123; // return salary * 2; // &#125; // &#125;; // console.log(calculateBonus(\"B\", 2000)); //4000 // console.log(calculateBonus(\"S\", 4000)); //16000 // 上面的缺点 // 函数庞大，包含了很多if-else，这些要覆盖所有的逻辑分支 // 缺乏弹性，如果要增加C等级，或修改倍数，必须进入函数内部修改 // 算法复用性差 // 使用组合函数重构 var performanceS = function(salary) &#123; return salary * 4; &#125;; var performanceA = function(salary) &#123; return salary * 3; &#125;; var performanceB = function(salary) &#123; return salary * 2; &#125;; var calculateBonus = function(performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return performanceS(salary); &#125; if (performanceLevel === 'A') &#123; return performanceA(salary); &#125; if (performanceLevel === 'B') &#123; return performanceB(salary); &#125; &#125;; calculateBonus('A', 10000); // 输出：30000 // 虽然解决了算法复用，但是依旧庞大，并缺乏弹性 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 传统面向对象中的策略模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 使用传统面向对象方式实现策略模式，将不同策略封装到不同的类中 // 一组策略类 var performanceS = function() &#123;&#125;; performanceS.prototype.calculate = function(salary) &#123; return salary * 4; &#125; var performanceA = function() &#123;&#125;; performanceA.prototype.calculate = function(salary) &#123; return salary * 3; &#125; var performanceB = function() &#123;&#125;; performanceB.prototype.calculate = function(salary) &#123; return salary * 2; &#125; var Bonus = function() &#123; this.salary = null; // 工资 this.strategy = null; // 绩效等级对应的策略对象 &#125;; Bonus.prototype.setSalary = function(salary) &#123; this.salary = salary; &#125;; Bonus.prototype.setStrategy = function(strategy) &#123; this.strategy = strategy; &#125;; // 环境类，把请求委托给具体的策略对象 Bonus.prototype.getBonus = function() &#123; return this.strategy.calculate(this.salary); // 把计算具体奖金的工作委托给某个策略对象 &#125;; var bonus = new Bonus(); // 实例化一个年终奖对象 bonus.setSalary(1000); // 添加工资 bonus.setStrategy(new performanceS()); // 传入绩效等级 console.log(bonus.getBonus()); // 获得年终奖 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js中的策略模式123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 传统的策略模式对象，必须要从类中创建，但是JS中可以直接创建，环境类对象也不用从类中创建，可以直接创建 // 一组策略 var strategies = &#123; \"S\": function(salary) &#123; return salary * 4; &#125;, \"A\": function(salary) &#123; return salary * 3; &#125;, \"B\": function(salary) &#123; return salary * 2; &#125; &#125;; // 负责把请求委托给具体的某个策略类 var calculateBonus = function(level, salary) &#123; return strategies[level](salary); &#125;; console.log(calculateBonus(\"S\", 3000)); //12000 console.log(calculateBonus(\"A\", 1000)); //2000 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用策略模式实现缓动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"position:absolute;background:blue\" id=\"div\"&gt;我是div&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 将各种缓动动画的算法封装起来 var tween = &#123; // t是动画已消耗的时间、b小球原始位置、c小球目标位置、d动画持续的总时间 linear: function(t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125; &#125;; var Animate = function(dom) &#123; this.dom = dom; // 进行运动的dom 节点 this.startTime = 0; // 动画开始时间 this.startPos = 0; // 动画开始时，dom 节点的位置，即dom 的初始位置 this.endPos = 0; // 动画结束时，dom 节点的位置，即dom 的目标位置 this.propertyName = null; // dom 节点需要被改变的css 属性名 this.easing = null; // 缓动算法 this.duration = null; // 动画持续时间 &#125;; // start负责启动动画 /** * 启动动画 * @author cgh * @time 2017-03-07 * @param &#123;String&#125; propertyName 要运动的属性 * @param &#123;Number&#125; endPos 结束位置 * @param &#123;Time&#125; duration 持续时间 * @param &#123;Obj&#125; easing 缓动算法 * @return &#123;[type]&#125; [description] */ Animate.prototype.start = function(propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; // 动画启动时间 this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置 this.propertyName = propertyName; // dom 节点需要被改变的CSS 属性名 this.endPos = endPos; // dom 节点目标位置 this.duration = duration; // 动画持续事件 this.easing = tween[easing]; // 缓动算法 var self = this; var timeId = setInterval(function() &#123; // 启动定时器，开始执行动画 if (self.step() === false) &#123; // 如果动画已结束，则清除定时器 clearInterval(timeId); &#125; &#125;, 1000 / 60); &#125;; // 定义小球每一帧的动画 Animate.prototype.step = function() &#123; var t = +new Date; // 取得当前时间 if (t &gt;= this.startTime + this.duration) &#123; // (1) this.update(this.endPos); // 更新小球的CSS 属性值 return false; &#125; var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); // pos 为小球当前位置 this.update(pos); // 更新小球的CSS 属性值 &#125;; // 负责更新动画 Animate.prototype.update = function(pos) &#123; this.dom.style[this.propertyName] = pos + 'px'; &#125;; var div = document.getElementById('div'); var animate = new Animate(div); animate.start('left', 500, 1000, 'strongEaseOut'); // animate.start('top', 1500, 500, 'strongEaseIn'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用策略模式完成表单验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=\"registerForm\" method=\"post\"&gt; 请输入用户名： &lt;input type=\"text\" name=\"userName\" /&gt; 请输入密码： &lt;input type=\"text\" name=\"password\" /&gt; 请输入手机号码： &lt;input type=\"text\" name=\"phoneNumber\" /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script type=\"text/javascript\"&gt; // 策略模式的主要目的是将算法的实现和使用分离 // 但在广义的情况下，也可以用策略模式将一些业务规则封装起来，只要这些业务规则指向的目标一致，并可被替换使用即可。如表单验证 // var registerForm = document.getElementById('registerForm'); // registerForm.onsubmit = function() &#123; // if (registerForm.userName.value === '') &#123; // alert('用户名不能为空'); // return false; // &#125; // if (registerForm.password.value.length &lt; 6) &#123; // alert('密码长度不能少于6 位'); // return false; // &#125; // if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(registerForm.phoneNumber.value)) &#123; // alert('手机号码格式不正确'); // return false; // &#125; // &#125;; // 不足很明显，函数比较庞大、缺乏弹性、复用性差 // 策略模式改进 // 封装校验逻辑 /***********************策略对象**************************/ var strategies = &#123; isNonEmpty: function(value, errorMsg) &#123; if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function(value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function(value, errorMsg) &#123; if (!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125; &#125;; /***********************Validator 类**************************/ var Validator = function() &#123; this.cache = []; &#125;; Validator.prototype.add = function(dom, rules) &#123; var self = this; for (var i = 0, rule; rule = rules[i++];) &#123; (function(rule) &#123; var strategyAry = rule.strategy.split(':'); var errorMsg = rule.errorMsg; self.cache.push(function() &#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategies[strategy].apply(dom, strategyAry); &#125;); &#125;)(rule) &#125; &#125;; Validator.prototype.start = function() &#123; for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123; var errorMsg = validatorFunc(); if (errorMsg) &#123; return errorMsg; &#125; &#125; &#125;; /***********************客户调用代码**************************/ var registerForm = document.getElementById('registerForm'); var validataFunc = function() &#123; var validator = new Validator(); validator.add(registerForm.userName, [&#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于10 位' &#125;]); validator.add(registerForm.password, [&#123; strategy: 'minLength:6', errorMsg: '密码长度不能小于6 位' &#125;]); validator.add(registerForm.phoneNumber, [&#123; strategy: 'isMobile', errorMsg: '手机号码格式不正确' &#125;]); var errorMsg = validator.start(); return errorMsg; &#125; registerForm.onsubmit = function() &#123; var errorMsg = validataFunc(); if (errorMsg) &#123; alert(errorMsg); return false; &#125; &#125;; // 策略模式优点 // 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。 // 策略模式提供了对开放— 封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。 // 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 // 在策略模式中利用组合和委托来让Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 // 缺点 // 使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context 中要好。 // 要使用策略模式，必须了解所有的strategy，必须了解各个strategy 之间的不同点，这样才能选择一个合适的strategy,此时strategy 要向客户暴露它的所有实现，这是违反最少知识原则的 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代理模式基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 代理模式:为一个对象提供一个代用品或占位符，以便控制对它的访问 // 应用场景:当不方便直接访问某个对象时 // 分类: // JS中常用: // 虚拟代理模式:会把一些开销很大的对象，延迟到真正需要它的时候再创建(常用) // 缓存代理模式:可以为一些开销很大的运算结果提供暂时的缓存，在下次运算时，如果传递进来的参数跟之前一致，则可直接返回缓存的结果(常用) // // 不常用: // 保护代理模式:代理B可以帮A过滤掉一些请求 // 防火墙代理模式:控制网络资源的访问，保护主体不让\"坏人\"接近 // 远程代理模式:为一个对象在不同的地址空间提供局部代表，在Java 中，远程代理可以是另一个虚拟机中的对象。 // 保护代理模式：用于对象应该有不同访问权限的情况。 // 智能引用代理模式：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。 // 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。 // 使用举例:小明托人送花、虚拟代理实现图片预加载、缓存代理异步ajax请求 // 小明委托B给A送花 // var Flower = function() &#123;&#125;; // // 发起者 // var xiaoMing = &#123; // sendFolower: function(target) &#123; // var flower = new Flower(); // target.receiveFlower(flower); // &#125; // &#125;; // // 接收者 // var A = &#123; // receiveFlower: function(flower) &#123; // console.log(\"收到花\" + flower); // &#125; // &#125;; // // 被委托的对象 // var B = &#123; // receiveFlower: function(flower) &#123; // A.receiveFlower(flower); // &#125; // &#125;; // xiaoMing.sendFolower(B); // 不足，上面这个例子看不出小明自己送和托B送有什么区别，因为B只是简单的把花递给了A // 考虑下面情况 // 在A心情好的时候小明送花，成功率很高。如果心情不好的时候送花，则成功率为0。小明才认识A，并不知道她心情的变化，而A的好朋友B却很了解，所以小明只管把花交给B，B负责监听A，在A心情好的时候将花传递给A var Flower = function() &#123;&#125;; var xiaoMing = &#123; sendFolower: function(target) &#123; var flower = new Flower(); target.receiveFlower(flower); &#125; &#125;; var A = &#123; receiveFlower: function(flower) &#123; console.log(\"收到花\" + flower); &#125;, listenGoodMood: function(fn) &#123; setTimeout(function() &#123; // 假设1s后心情变好 fn(); &#125;, 3000); &#125; &#125;; var B = &#123; receiveFlower: function(flower) &#123; A.listenGoodMood(function() &#123; // 监听A的心情 A.receiveFlower(flower); &#125;); &#125; &#125;; xiaoMing.sendFolower(B); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虚拟代理模式实现图片预加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 在Web 开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张loading 片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很适合使用虚拟代理 // 非代理模式实现 // var MyImage = (function() &#123; // var imgNode = document.createElement('img'); // document.body.appendChild(imgNode); // var img = new Image; // img.onload = function() &#123; // imgNode.src = img.src; // &#125;; // return &#123; // setSrc: function(src) &#123; // imgNode.src = 'http://img.zcool.cn/community/013cb15648986a32f87512f6d87dc8.gif'; // img.src = src; // &#125; // &#125; // &#125;)(); // MyImage.setSrc('http://img1.3lian.com/2015/a1/24/d/17.jpg'); // 上面违反了单一职责原则，MyImage既负责给img设置src外，还负责预加载图片 // 虚拟代理模式 // 普通本体对象，对外提供一个setSrc接口 var myImage = (function() &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125; &#125;)(); // 代理对象 var proxyImage = (function() &#123; var img = new Image(); img.onload = function() &#123; // 真图请求完成，将真图放到页面上 myImage.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; // 设置loading图 myImage.setSrc('http://img.zcool.cn/community/013cb15648986a32f87512f6d87dc8.gif'); // 设置真图地址 img.src = src; &#125; &#125; &#125;)(); proxyImage.setSrc('http://img1.3lian.com/2015/a1/24/d/17.jpg'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虚拟代理合并http请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"checkbox\" id=\"1\"&gt;&lt;/input&gt;1 &lt;input type=\"checkbox\" id=\"2\"&gt;&lt;/input&gt;2 &lt;input type=\"checkbox\" id=\"3\"&gt;&lt;/input&gt;3 &lt;input type=\"checkbox\" id=\"4\"&gt;&lt;/input&gt;4 &lt;input type=\"checkbox\" id=\"5\"&gt;&lt;/input&gt;5 &lt;input type=\"checkbox\" id=\"6\"&gt;&lt;/input&gt;6 &lt;input type=\"checkbox\" id=\"7\"&gt;&lt;/input&gt;7 &lt;input type=\"checkbox\" id=\"8\"&gt;&lt;/input&gt;8 &lt;input type=\"checkbox\" id=\"9\"&gt;&lt;/input&gt;9 &lt;script type=\"text/javascript\"&gt; // 将多个HTPP请求打包成一个，一次发往服务器 var synchronousFile = function(id) &#123; console.log(\"开始同步文件,id为:\" + id); &#125;; var checkbox = document.getElementsByTagName(\"input\"); for (var i = 0, c; c = checkbox[i++];) &#123; c.onclick = function() &#123; // 这样每点一次就同步一次，对服务器伤害很大，可以将多个打包了，再一并发送 if (this.checked === true) &#123; proxySynchronousFile(this.id); &#125; &#125;; &#125; // 添加代理函数，负责手机一段时间内的请求 var proxySynchronousFile = (function() &#123; var cache = [], timer; return function(id) &#123; // 存入缓存 cache.push(id); if (timer) &#123; return; &#125; timer = setTimeout(function() &#123; // 执行同步 synchronousFile(cache.join(\",\")); // 清除 clearTimeout(timer); timer = null; cache.length = 0; &#125;, 2000); &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虚拟代理在惰性加载中的应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 在按特定按键时才加载另外一个js文件 // var cache = []; // var miniConsole = &#123; // log: function() &#123; // var args = arguments; // cache.push(function() &#123; // return miniConsole.log.apply(miniConsole, args); // &#125;); // &#125; // &#125;; // var handler = function(ev) &#123; // if (ev.keyCode === 32) &#123; // // 按空格才会创建脚本 // var script = document.createElement(\"script\"); // script.src = \"js/33.js\"; // script.onload = function() &#123; // for (var i = 0, fn; fn = cache[i++];) &#123; // fn(); // &#125; // &#125;; // document.body.appendChild(script); // &#125; // &#125;; // document.body.addEventListener(\"keydown\", handler, false); // miniConsole.log(3); // 这样的问题是在每次按空格都会重复创建script // 改进 var miniConsole = (function() &#123; var cache = []; var handler = function(ev) &#123; if (ev.keyCode === 32) &#123; console.log(ev); var script = document.createElement('script'); script.onload = function() &#123; for (var i = 0, fn; fn = cache[i++];) &#123; fn(); &#125; &#125;; script.src = 'js/33.js'; document.body.appendChild(script); document.body.removeEventListener('keydown', handler); // 只加载一次33.js &#125; &#125;; document.body.addEventListener('keydown', handler, false); return &#123; log: function() &#123; var args = arguments; cache.push(function() &#123; return miniConsole.log.apply(miniConsole, args); &#125;); &#125; &#125; &#125;)(); miniConsole.log(11); // 开始打印log &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 缓存代理123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 可以为一些开销很大的运算结果提供暂时的缓存，在下次运算时，如果传递进来的参数跟之前一致，则可直接返回缓存的结果 // 计算乘积 var mult = function() &#123; var a = 1; for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; a *= arguments[i]; &#125; return a; &#125;; console.log(mult(2, 3)); console.log(mult(2, 3, 4)); // 代理函数 var proxyMult = (function() &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments, \",\"); if (args in cache) &#123; console.log(\"来自缓存\"); return cache[args]; &#125; return cache[args] = mult.apply(this, arguments); &#125;; &#125;)(); console.log(proxyMult(1, 2, 3, 4)); console.log(proxyMult(1, 2, 3, 4)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用高阶函数动态创建缓存代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; /**************** 计算乘积 *****************/ var mult = function() &#123; var a = 1; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a * arguments[i]; &#125; return a; &#125;; /**************** 计算加和 *****************/ var plus = function() &#123; var a = 0; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; a = a + arguments[i]; &#125; return a; &#125;; /**************** 创建缓存代理的工厂 *****************/ var createProxyFactory = function(fn) &#123; var cache = &#123;&#125;; return function() &#123; var args = Array.prototype.join.call(arguments, ','); if (args in cache) &#123; console.log(\"来自缓存\"); return cache[args]; &#125; return cache[args] = fn.apply(this, arguments); &#125; &#125;; var proxyMult = createProxyFactory(mult), proxyPlus = createProxyFactory(plus); console.log((proxyMult(1, 2, 3, 4))); // 输出：24 console.log((proxyMult(1, 2, 3, 4))); // 输出：24 console.log((proxyPlus(1, 2, 3, 4))); // 输出：10 console.log((proxyPlus(1, 2, 3, 4))); // 输出：10 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 迭代器模式基本定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 迭代器模式:提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。它将迭代过程从业务逻辑中抽象出来。 // 分类: // 内部迭代器:内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。优点:不用关心迭代器内部实现。缺点:优点也是缺点，因为迭代器中的迭代规则以被提前规定好 // 外部迭代器:外部迭代器必须显式地请求迭代下一个元素 // 使用场景是:对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又响让客户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。 // 使用举例:很多语言都内置了迭代器如Array.prototype.forEach、jQuery中的$.each // 实现自己的each(一个内部迭代器) var each = function(ary, callback) &#123; for (var i = 0, len = ary.length; i &lt; len; i++) &#123; callback.call(ary[i], i, ary[i]); // 在ary[i]下调用callback,传入索引i和元素ary[i] &#125; &#125;; // each([1, 2, 3, 4], function(i, n) &#123; // console.log(([i, n])); // &#125;); // 用each完成判断两个数组是否相等 // var compare = function(ary1, ary2) &#123; // // 长度不同肯定不相等 // if (ary1.length !== ary2.length) &#123; // throw new Error(\"不相等\"); // &#125; // // 比较内部元素值 // each(ary1, function(i, n) &#123; // if (n !== ary2[i]) &#123; // throw new Error(\"不相等\"); // &#125; // &#125;); // console.log(\"相等\"); // &#125;; // compare([1, 2, 3], [1, 2, 4]); // 使用外部迭代器改写判断数组相等 var Iterator = function(obj) &#123; var current = 0; var next = function() &#123; current += 1; &#125;; var isDone = function() &#123; return current &gt;= obj.length; &#125;; var getCurrItem = function() &#123; return obj[current]; &#125;; return &#123; next: next, isDone: isDone, getCurrItem: getCurrItem &#125; &#125;; var compare = function(iterator1, iterator2) &#123; while (!iterator1.isDone() &amp;&amp; !iterator2.isDone()) &#123; if (iterator1.getCurrItem() !== iterator2.getCurrItem()) &#123; throw new Error(\"不相等\"); &#125; iterator1.next(); iterator2.next(); &#125; console.log(\"相等\"); &#125;; var iterator1 = Iterator([1, 2, 3]); var iterator2 = Iterator([1, 2, 3]); compare(iterator1, iterator2); // 输出：iterator1 和iterator2 相等 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 迭代类数组对象和字面量对象123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 本质上，只要对象拥有length属性的都可以迭代，arguments和对象字面量也可以迭代，仿照jquery的$.each写一个通用的迭代器 each = function(obj, callback) &#123; var value, i = 0, length = obj.length, isArray = isArraylike(obj); if (isArray) &#123; // 类数组对象 for (; i &lt; length; i++) &#123; value = callback.call(obj[i], i, obj[i]); // 约定回调函数返回false时，终止迭代 if (value === false) &#123; break; &#125; &#125; &#125; else &#123; // 普通对象 for (i in obj) &#123; value = callback.call(obj[i], i, obj[i]); if (value === false) &#123; break; &#125; &#125; &#125; return obj; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 倒序迭代器1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 倒序迭代器 var reverseEach = function(ary, callback) &#123; for (var l = ary.length - 1; l &gt;= 0; l--) &#123; callback(l, ary[l]); &#125; &#125;; reverseEach([0, 1, 2], function(i, n) &#123; console.log(n); // 分别输出：2, 1 ,0 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 迭代器模式实现上传空间选择12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // var getUploadObj = function() &#123; // try &#123; // return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上传控件 // &#125; catch (e) &#123; // if (supportFlash()) &#123; // supportFlash 函数未提供 // var str = '&lt;object type=\"application/x-shockwave-flash\"&gt;&lt;/object&gt;'; // return $(str).appendTo($('body')); // &#125; else &#123; // var str = '&lt;input name=\"file\" type=\"file\"/&gt;'; // 表单上传 // return $(str).appendTo($('body')); // &#125; // &#125; // &#125;; // 上面的难以阅读、扩展、维护 // 将获取上传对象封装起来 var getActiveUploadObj = function() &#123; try &#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上传控件 &#125; catch (e) &#123; return false; &#125; &#125;; var getFlashUploadObj = function() &#123; if (isSupportFlash()) &#123; // isSupportFlash 函数未提供 var str = '&lt;object type=\"application/x-shockwave-flash\"&gt;&lt;/object&gt;'; return document.body.innerHTML += str; &#125; return false; &#125;; var getFormUpladObj = function() &#123; var str = '&lt;input name=\"file\" type=\"file\" class=\"ui-file\"/&gt;'; // 表单上传 return document.body.innerHTML += str; &#125;; // 迭代器 var iteratorUploadObj = function() &#123; for (var i = 0, fn; fn = arguments[i++];) &#123; var uploadObj = fn(); if (uploadObj !== false) &#123; return uploadObj; &#125; &#125; &#125;; var uploadObj = iteratorUploadObj(getActiveUploadObj, getFlashUploadObj, getFormUpladObj); console.log(uploadObj); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 观察者模式基本定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 观察者模式又叫发布-订阅模式。它定义对象间的一种在对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。JS中一般用事件模型来替代传统的观察者模式 // 使用场景:应用于异步编程中，这是一种替代传递回调函数的方案。可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口 // 使用举例:买房，到达预售时间，售楼部(发布者)会打电话(通过花名册，一个缓存列表，拨打电话过程就是在执行回调函数的过程)通知买房者(订阅者)可以购买了。 // var salesOffices = &#123;&#125;; // 定义售楼处，发布者 // salesOffices.clientList = []; // 缓存列表，花名册，存放订阅者的回调函数 // salesOffices.listen = function(fn) &#123; // 增加订阅者 // this.clientList.push(fn); // 订阅者的回调函数添加到缓存列表中 // &#125;; // salesOffices.trigger = function() &#123; // 发布消息 // for (var i = 0, fn; fn = this.clientList[i++];) &#123; // fn.apply(this, arguments); // arguments是发布消息时带上的参数 // &#125; // &#125;; // salesOffices.listen(function(price, squareMeter) &#123; // 小明订阅消息 // console.log(\"我是小明订阅的\"); // console.log('价格= ' + price); // console.log('squareMeter= ' + squareMeter); // &#125;); // salesOffices.listen(function(price, squareMeter) &#123; // 小红订阅消息 // console.log(\"我是小红订阅的\"); // console.log('价格= ' + price); // console.log('squareMeter= ' + squareMeter); // &#125;); // // 发布消息，此时会通知所有订阅者 // salesOffices.trigger(2000000, 88); // 输出：200 万，88 平方米 // salesOffices.trigger(3000000, 110); // 输出：300 万，110 平方米 // 上面出现的问题时，假如小明只想买88平的，售楼部却把110平的也推送给他了 var salesOffices = &#123;&#125;; salesOffices.clientList = &#123;&#125;; salesOffices.listen = function(key, fn) &#123; // key为订阅者想订阅的某个消息类型，例如小明想订阅的88平 if (!this.clientList[key]) &#123; // 如果还没订阅过此类消息，则给该类消息创建一个缓存列表 this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 将订阅的消息添加到缓存列表中 &#125;; salesOffices.trigger = function() &#123; var key = Array.prototype.shift.call(arguments); // 取出消息类型 var fns = this.clientList[key]; // 此消息类型对应的回调函数列表 if (!fns || fns.length === 0) &#123; // 没有订阅该消息，则返回 return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // 发布消息 &#125; &#125;; salesOffices.listen('squareMeter88', function(price) &#123; // 小明订阅88 平方米房子的消息 console.log('价格= ' + price); // 输出： 2000000 &#125;); salesOffices.listen('squareMeter88', function(price) &#123; // 小周订阅88 平方米房子的消息 console.log('价格= ' + price); // 输出： 2000000 &#125;); salesOffices.listen('squareMeter110', function(price) &#123; // 小红订阅110 平方米房子的消息 console.log('价格= ' + price); // 输出： 3000000 &#125;); salesOffices.trigger('squareMeter88', 2000000); // 发布88 平方米房子的价格，此时只有小明和小周会收到订阅消息 salesOffices.trigger('squareMeter110', 3000000); // 发布110 平方米房子的价格，只有小红能收到消息 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 观察者的通用实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var event = &#123; clientList: &#123;&#125;, listen: function(key, fn) &#123; if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger: function() &#123; var key = Array.prototype.shift.call(arguments); var fns = this.clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;, remove: function(key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; // 反向遍历订阅的回调函数列表 var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); // 删除订阅者的回调函数 &#125; &#125; &#125; &#125; &#125;; var cloneObj = function(sourceObject) &#123; var str, newObj = sourceObject.constructor === Array ? [] : &#123;&#125;; if (typeof sourceObject !== 'object') &#123; return; &#125; else &#123; for (var i in sourceObject) &#123; newObj[i] = typeof sourceObject[i] === 'object' ? cloneObj(sourceObject[i]) : sourceObject[i]; &#125; &#125; return newObj; &#125;; var salesOffices = cloneObj(event); salesOffices.listen('squareMeter88', fn1 = function(price) &#123; // 小明订阅售楼1 88平消息 console.log('售楼1通知小明价格= ' + price); &#125;); salesOffices.listen('squareMeter88', fn2 = function(price) &#123; // 小周订阅售楼1 88平消息 console.log('售楼1通知小周价格= ' + price); &#125;); salesOffices.listen('squareMeter100', fn3 = function(price) &#123; // 小红订阅售楼1 100平消息 console.log('售楼1通知小红价格= ' + price); &#125;); // 售楼1发布88平米的消息 salesOffices.trigger('squareMeter88', 20000); // 输出：20000 // 售楼1发布100平米的消息 salesOffices.trigger('squareMeter100', 30000); // 输出：20000 console.log(\"=======================\");; console.log(\"删除小明订阅售楼1\"); salesOffices.remove('squareMeter88', fn1); // 删除小明的订阅 salesOffices.trigger('squareMeter88', 20000); // 输出：20000 salesOffices.trigger('squareMeter100', 30000); // 输出：20000 console.log(\"=======================\"); var salesOffices2 = cloneObj(event); salesOffices2.listen('squareMeter88', fn21 = function(price) &#123; // 小明订阅售楼2 88平消息 console.log('售楼2通知小明价格= ' + price); &#125;); salesOffices2.listen('squareMeter88', fn22 = function(price) &#123; // 小红订阅售楼2 100平消息 console.log('售楼2通知小红价格= ' + price); &#125;); // 发布88平米消息 salesOffices2.trigger('squareMeter88', 25000); // 输出：25000 console.log(\"=======================\");; console.log(\"删除小明订阅售楼2\"); salesOffices2.remove('squareMeter88', fn21); // 删除小明的订阅 salesOffices2.trigger('squareMeter88', 35000); // 输出：35000 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用观察者模式实现网站登录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;假如我们正在开发一个商城网站，网站里有header 头部、nav 导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。 这是很正常的，比如用户的名字和头像要显示在header 模块里，而这两个字段都来自用户登录后返回的信息。至于ajax 请求什么时候能成功返回用户信息，这点我们没有办法确定&lt;/p&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-2.2.4.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/mock-min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var event = &#123; clientList: &#123;&#125;, listen: function(key, fn) &#123; if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); &#125;, trigger: function() &#123; var key = Array.prototype.shift.call(arguments); var fns = this.clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;, remove: function(key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; // 反向遍历订阅的回调函数列表 var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); // 删除订阅者的回调函数 &#125; &#125; &#125; &#125; &#125;; var cloneObj = function(sourceObject) &#123; var str, newObj = sourceObject.constructor === Array ? [] : &#123;&#125;; if (typeof sourceObject !== 'object') &#123; return; &#125; else &#123; for (var i in sourceObject) &#123; newObj[i] = typeof sourceObject[i] === 'object' ? cloneObj(sourceObject[i]) : sourceObject[i]; &#125; &#125; return newObj; &#125;; // 使用 Mock模拟数据 Mock.setup(&#123; timeout: '500-1000' &#125;); Mock.mock('http://test.cn', &#123; \"userName\": \"@cname\", \"sex|1\": [\"男\", \"女\"], \"avator\": Mock.Random.image('100x100', '#894FC4', '#FFF', 'png', '头像'), \"test|1-3\": 3 &#125;); // 模拟请求 $.ajax(&#123; url: 'http://test.cn', dataType: 'json' &#125;).done(function(data, status, xhr) &#123; // 请求成功，触发登录成功 login.trigger(\"loginSucc\", data); &#125;); var login = cloneObj(event); var header = (function() &#123; // 订阅登录的登录成功消息 login.listen(\"loginSucc\", function(data) &#123; header.setAvator(data.avator); &#125;); return &#123; setAvator: function(data) &#123; console.log(\"设置Header模块头像\"); &#125; &#125; &#125;)(); var nav = (function() &#123; login.listen(\"loginSucc\", function(data) &#123; nav.setAvator(data.avator); &#125;); return &#123; setAvator: function(data) &#123; console.log(\"设置Nav模块头像\"); &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 全局发布订阅-对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"count\"&gt;点我&lt;/button&gt; &lt;div id=\"show\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var Event = (function() &#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function(key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function() &#123; var key = Array.prototype.shift.call(arguments); var fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function(key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[l]; if (_fn === fn) &#123; fns.spice(l, 1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;; &#125;)(); Event.listen('squareMeter88', function(price) &#123; // 小红订阅消息 console.log('价格= ' + price); // 输出：'价格=2000000' &#125;); Event.trigger('squareMeter88', 2000000); // 售楼处发布消息 // 利用全局的发布-订阅对象，可以实现模块间的通信 // 点击按钮，div中显示总的点击次数 var a = (function() &#123; var count = 0; var button = document.getElementById(\"count\"); button.onclick = function() &#123; Event.trigger(\"add\", count++); &#125;; &#125;)(); var b = (function() &#123; var div = document.getElementById(\"show\"); Event.listen(\"add\", function(count) &#123; div.innerHTML = count; &#125;); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 支持先发布后订阅、命名空间的观察者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;pre&gt; 有时，需要先发布，再订阅。如42中的登录，获取登录信息可能很快，但其他模块可能加载的很慢，就会造成已经发布了登录成功的消息，但其他模块还没有订阅的错误。 所以需要让观察者模式支持先缓存要发布的消息，等到有模块订阅消息的时候再正式发布消息。 另外，Event对象中只存在一个clientList，当订阅多了，就可能出现命名冲突的问题。所以还需要支持创建命名空间。&lt;/pre&gt; &lt;script&gt; var Event = (function() &#123; var global = this, Event, _default = \"default\"; Event = function() &#123; var _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function(ary, fn) &#123; var ret; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; var n = ary[i]; ret = fn.call(n, i, n); &#125; return ret; &#125;; _listen = function(key, fn, cache) &#123; if (!cache[key]) &#123; cache[key] = []; &#125; cache[key].push(fn); &#125;; _remove = function(key, cache, fn) &#123; if (cache[key]) &#123; if (fn) &#123; for (var i = cache[key].length; i &gt;= 0; i--) &#123; if (cache[key][i] === fn) &#123; cache[key].splice(i, 1); &#125; &#125; &#125; else &#123; cache[key] = &#123;&#125;; &#125; &#125; &#125;; _trigger = function() &#123; var cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, ret, stack = cache[key]; if (!stack || !stack.length) &#123; return; &#125; return each(stack, function() &#123; return this.apply(_self, args); &#125;); &#125;; _create = function(namespace) &#123; var namespace = namespace || _default; var cache = &#123;&#125;, offlineStack = [], // 离线事件 ret = &#123; listen: function(key, fn, last) &#123; _listen(key, fn, cache); if (offlineStack === null) &#123; return; &#125; if (last === \"last\") &#123; offlineStack.length &amp;&amp; offlineStack.pop()(); &#125; else &#123; each(offlineStack, function() &#123; this(); &#125;); &#125; offlineStack = null; &#125;, one: function(key, fn, last) &#123; _remove(key, cache); this.listen(key, fn, last); &#125;, remove: function(key, fn) &#123; _remove(key, cache, fn); &#125;, trigger: function() &#123; var fn, args, _self = this; _unshift.call(arguments, cache); args = arguments; fn = function() &#123; return _trigger.apply(_self, args); &#125;; if (offlineStack) &#123; return offlineStack.push(fn); &#125; return fn(); &#125; &#125;; return namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret; &#125;; return &#123; create: _create, one: function(key, fn, last) &#123; var event = this.create(); event.one(key, fn, last); &#125;, remove: function(key, fn) &#123; var event = this.create(); event.remove(key, fn); &#125;, listen: function(key, fn, last) &#123; var event = this.create(); event.listen(key, fn, last); &#125;, trigger: function() &#123; var event = this.create(); event.trigger.apply(this, arguments); &#125; &#125;; &#125;(); return Event; &#125;)(); /************** 先发布后订阅 ********************/ Event.trigger('click', 1); Event.listen('click', function(a) &#123; console.log(a); // 输出：1 &#125;); /************** 使用命名空间 ********************/ Event.create('namespace1').listen('click', function(a) &#123; console.log(a); // 输出：1 &#125;); Event.create('namespace1').trigger('click', 1); Event.create('namespace2').listen('click', function(a) &#123; console.log(a); // 输出：2 &#125;); Event.create('namespace2').trigger('click', 2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 命令模式基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"button1\"&gt;点击按钮1&lt;/button&gt; &lt;button id=\"button2\"&gt;点击按钮2&lt;/button&gt; &lt;button id=\"button3\"&gt;点击按钮3&lt;/button&gt; &lt;script&gt; // 命令模式:命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。 // 使用场景:有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 // 使用举例:拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。 命令模式把客人订餐的请求封装成command 对象，也就是订餐中的订单对象。这个对象可以在程序中被四处传递，就像订单可以从服务员手中传到厨师的手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。 // 菜单程序 // 绘制按钮和点击按钮的具体行为分离 // 点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。 // // 传统面向对象语言中的命令模式 // var button1 = document.getElementById('button1'), // button2 = document.getElementById('button2'), // button3 = document.getElementById('button3'); // // 负责往按钮上安装命令 // var setCommand = function(button, command) &#123; // button.onclick = function() &#123; // command.execute(); // &#125;; // &#125;; // var MenuBar = &#123; // refresh: function() &#123; // console.log('刷新菜单目录'); // &#125; // &#125;; // var SubMenu = &#123; // add: function() &#123; // console.log('增加子菜单'); // &#125;, // del: function() &#123; // console.log('删除子菜单'); // &#125; // &#125;; // // 构建命令 // var RefreshMenuBarCommand = function(receiver) &#123; // this.receiver = receiver; // &#125;; // RefreshMenuBarCommand.prototype.execute = function() &#123; // this.receiver.refresh(); // &#125;; // var AddSubMenuCommand = function(receiver) &#123; // this.receiver = receiver; // &#125;; // AddSubMenuCommand.prototype.execute = function() &#123; // this.receiver.add(); // &#125;; // var DelSubMenuCommand = function(receiver) &#123; // this.receiver = receiver; // &#125;; // DelSubMenuCommand.prototype.execute = function() &#123; // console.log('删除子菜单'); // &#125;; // // 实例化命令 // var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar); // var addSubMenuCommand = new AddSubMenuCommand(SubMenu); // var delSubMenuCommand = new DelSubMenuCommand(SubMenu); // // 安装命令 // setCommand(button1, refreshMenuBarCommand); // setCommand(button2, addSubMenuCommand); // setCommand(button3, delSubMenuCommand); // // 在js中使用闭包实现命令模式 // var button1 = document.getElementById('button1'); // var setCommand = function(button, func) &#123; // button.onclick = function() &#123; // func(); // &#125;; // &#125; // var MenuBar = &#123; // refresh: function() &#123; // console.log(\"刷新菜单界面\"); // &#125; // &#125;; // var RefreshMenuBarCommand = function(receiver) &#123; // return function() &#123; // receiver.refresh(); // &#125;; // &#125;; // var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar); // setCommand(button1, refreshMenuBarCommand); // 为了更明确的表达当前正在用命令模式，或者将来有可能提供撤销操作时，可以将执行函数改为调用execute方法 var RefreshMenuBarCommand = function(receiver) &#123; return &#123; execute: function() &#123; receiver.refresh(); &#125; &#125; &#125;; var button1 = document.getElementById('button1'); var setCommand = function(button, command) &#123; button.onclick = function() &#123; command.execute(); &#125;; &#125;; var MenuBar = &#123; refresh: function() &#123; console.log(\"刷新菜单界面\"); &#125; &#125;; var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar); setCommand(button1, refreshMenuBarCommand); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 带撤销的命令模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"ball\" style=\"position:absolute;background:#000;width:50px;height:50px\"&gt;&lt;/div&gt; 输入小球移动后的位置： &lt;input id=\"pos\" /&gt; &lt;button id=\"moveBtn\"&gt;开始移动&lt;/button&gt; &lt;!--增加取消按钮--&gt; &lt;button id=\"cancelBtn\"&gt;cancel&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var tween = &#123; linear: function(t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125; &#125;; var Animate = function(dom) &#123; this.dom = dom; this.startTime = 0; this.startPos = 0; this.endPos = 0; this.propertyName = null; this.easing = null; this.duration = null; &#125;; Animate.prototype.start = function(propertyName, endPos, duration, easing) &#123; this.startTime = +new Date; this.startPos = this.dom.getBoundingClientRect()[propertyName]; this.propertyName = propertyName; this.endPos = endPos; this.duration = duration; this.easing = tween[easing]; var self = this; var timeId = setInterval(function() &#123; if (self.step() === false) &#123; clearInterval(timeId); &#125; &#125;, 1000 / 60); &#125;; Animate.prototype.step = function() &#123; var t = +new Date; if (t &gt;= this.startTime + this.duration) &#123; this.update(this.endPos); return false; &#125; var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration); this.update(pos); &#125;; Animate.prototype.update = function(pos) &#123; this.dom.style[this.propertyName] = pos + 'px'; &#125;; // 以上为运动算法 // 下面通过命令模式实现运动以及撤销功能 var ball = document.getElementById('ball'); var pos = document.getElementById('pos'); var moveBtn = document.getElementById('moveBtn'); var cancelBtn = document.getElementById('cancelBtn'); var MoveCommand = function(receiver, pos) &#123; this.receiver = receiver; this.pos = pos; this.oldPos = null; &#125;; MoveCommand.prototype.execute = function() &#123; this.receiver.start('left', this.pos, 1000, 'strongEaseOut'); // 记录小球开始移动前的位置 this.oldPos = this.receiver.dom.getBoundingClientRect()[this.receiver.propertyName]; &#125;; MoveCommand.prototype.undo = function() &#123; // 回到小球移动前记录的位置 this.receiver.start('left', this.oldPos, 1000, 'strongEaseOut'); &#125;; var moveCommand; moveBtn.onclick = function() &#123; var animate = new Animate(ball); moveCommand = new MoveCommand(animate, pos.value); moveCommand.execute(); &#125;; cancelBtn.onclick = function() &#123; moveCommand.undo(); // 撤销命令 &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用命令模式实现重做12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"replay\"&gt;播放录像&lt;/button&gt; &lt;script&gt; var Ryu = &#123; attack: function() &#123; console.log('攻击'); &#125;, defense: function() &#123; console.log('防御'); &#125;, jump: function() &#123; console.log('跳跃'); &#125;, crouch: function() &#123; console.log('蹲下'); &#125; &#125;; var makeCommand = function(receiver, state) &#123; // 创建命令 return function() &#123; receiver[state](); &#125; &#125;; var commands = &#123; \"119\": \"jump\", // W \"115\": \"crouch\", // S \"97\": \"defense\", // A \"100\": \"attack\" // D &#125;; var commandStack = []; // 保存命令的堆栈 document.onkeypress = function(ev) &#123; var keyCode = ev.keyCode, command = makeCommand(Ryu, commands[keyCode]); if (command) &#123; command(); // 执行命令 commandStack.push(command); // 将刚刚执行过的命令保存进堆栈 &#125; &#125;; document.getElementById('replay').onclick = function() &#123; // 点击播放录像 var command; while (command = commandStack.shift()) &#123; // 从堆栈里依次取出命令并执行 command(); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 宏命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var closeDoorCommand = &#123; execute: function() &#123; console.log('关门'); &#125; &#125;; var openPcCommand = &#123; execute: function() &#123; console.log('开电脑'); &#125; &#125;; var openQQCommand = &#123; execute: function() &#123; console.log('登录QQ'); &#125; &#125;; var MacroCommand = function() &#123; return &#123; commandList: [], add: function(command) &#123; this.commandList.push(command); &#125;, execute: function() &#123; for (var i = 0, command; command = this.commandList[i++];) &#123; command.execute(); &#125; &#125; &#125;; &#125;; var macroCommand = MacroCommand(); macroCommand.add(closeDoorCommand); macroCommand.add(openPcCommand); macroCommand.add(openQQCommand); macroCommand.execute(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组合模式基本定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 组合模式:组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。 // 组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式可以非常方便地描述对象部分-整体层次结构。 除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。 // 使用场景:表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则;客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。 // 使用举例:扫描文件夹,文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹 /***************文件夹*******************/ var Folder = function(name) &#123; this.name = name; this.files = []; &#125;; Folder.prototype.add = function(file) &#123; this.files.push(file); &#125;; Folder.prototype.scan = function() &#123; console.log(\"开始扫描文件夹:\" + this.name); for (var i = 0, file, files = this.files; file = files[i++];) &#123; file.scan(); &#125; &#125;; /*****************文件*******************/ var File = function(name) &#123; this.name = name; &#125;; File.prototype.add = function() &#123; throw new Error(\"文件下面不能再添加文件\"); &#125;; File.prototype.scan = function() &#123; console.log(\"开始扫描文件:\" + this.name); &#125;; /****创建文件夹及文件****/ var folder = new Folder('学习资料'); var folder1 = new Folder('JavaScript'); var folder2 = new Folder('jQuery'); var file1 = new File('JavaScript 设计模式与开发实践'); var file2 = new File('精通jQuery'); var file3 = new File('重构与模式') folder1.add(file1); folder2.add(file2); folder.add(folder1); folder.add(folder2); var folder3 = new Folder('Nodejs'); var file4 = new File('深入浅出Node.js'); folder3.add(file4); var file5 = new File('JavaScript 语言精髓与编程实践'); folder.add(folder3); folder.add(file5); /****扫描文件夹****/ folder.scan(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组合模式-引用父对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 在49的基础上要添加删除功能，例如删除某个文件的时候，其实是在其上层文件夹中删除该文件。此时文件就必须要保存上层对象的引用 var Folder = function(name) &#123; this.name = name; this.parent = null; //增加this.parent 属性 this.files = []; &#125;; Folder.prototype.add = function(file) &#123; file.parent = this; //设置父对象 this.files.push(file); &#125;; Folder.prototype.scan = function() &#123; console.log('开始扫描文件夹: ' + this.name); for (var i = 0, file, files = this.files; file = files[i++];) &#123; file.scan(); &#125; &#125;; // 增加删除功能 Folder.prototype.remove = function() &#123; if (!this.parent) &#123; //根节点或者树外的游离节点 return; &#125; for (var files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) &#123; var file = files[l]; if (file === this) &#123; files.splice(l, 1); &#125; &#125; &#125;; var File = function(name) &#123; this.name = name; this.parent = null; &#125;; File.prototype.add = function() &#123; throw new Error('不能添加在文件下面'); &#125;; File.prototype.scan = function() &#123; console.log('开始扫描文件: ' + this.name); &#125;; File.prototype.remove = function() &#123; if (!this.parent) &#123; //根节点或者树外的游离节点 return; &#125; for (var files = this.parent.files, l = files.length - 1; l &gt;= 0; l--) &#123; var file = files[l]; if (file === this) &#123; files.splice(l, 1); &#125; &#125; &#125;; var folder = new Folder('学习资料'); var folder1 = new Folder('JavaScript'); var file1 = new Folder('深入浅出Node.js'); folder1.add(new File('JavaScript 设计模式与开发实践')); folder.add(folder1); folder.add(file1); folder.scan(); console.log(\"/******移除文件夹******/\"); folder1.remove(); folder.scan(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板方法模式基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 模板方法模式:一种基于继承的设计模式 // 构成:第一部分是抽象父类，第二部分是具体的实现子类;通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法;父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。 // 使用场景:从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承框架的结构之后，负责往里面填空。 // 在Web 开发中也能找到很多模板方法模式的适用场景 // 比如我们在构建一系列的UI 组件这些组件的构建过程一般如下所示： // (1) 初始化一个div 容器； // (2) 通过ajax 请求拉取相应的数据； // (3) 把数据渲染到div 容器里面，完成组件的构造； // (4) 通知用户组件渲染完毕。 // 我们看到， 任何组件的构建都遵循上面的4步，其中第(1)步和第(4)步是相同的。第(2)步不同的地方只是请求ajax的远程地址，第(3)步不同的地方是渲染数据的方式。于是我们可以把这4个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第(1)步和第(4)步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第(2)步和第(3)步。 // 使用举例:泡咖啡和泡茶 // 泡咖啡 // (1) 把水煮沸 // (2) 用沸水冲泡咖啡 // (3) 把咖啡倒进杯子 // (4) 加糖和牛奶 // 泡茶 // (1) 把水煮沸 // (2) 用沸水浸泡茶叶 // (3) 把茶水倒进杯子 // (4) 加柠檬 // 二者基本步骤是相同，不同的地方有 // 原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象为“饮料”。 // 泡的方式不同。咖啡是冲泡，而茶叶是浸泡，我们可以把它们都抽象为“泡”。 // 加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为“调料”。 // 抽象之后 // (1) 把水煮沸 // (2) 用沸水冲泡饮料 // (3) 把饮料倒进杯子 // (4) 加调料 // 抽象父类-饮料类 var Beverage = function() &#123;&#125;; // 烧水 Beverage.prototype.boilWater = function() &#123; console.log(\"把水煮沸\"); &#125;; // 泡 Beverage.prototype.brew = function() &#123; throw new Error('子类必须重写brew方法'); &#125;; // 空方法，应该由子类重写，若子类忘记重写，可在父类上添加一个错误提醒信息 // 倒入杯子 Beverage.prototype.pourInCup = function() &#123; throw new Error('子类必须重写pourInCup方法'); &#125;; // 空方法，应该由子类重写 // 加调料 Beverage.prototype.addCondiments = function() &#123; throw new Error('子类必须重写addCondiments方法'); &#125;; // 空方法，应该由子类重写 Beverage.prototype.init = function() &#123; this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); &#125;; // 抽象子类-coffee var Coffee = function() &#123;&#125;; // 继承饮料类 Coffee.prototype = new Beverage(); // 重写泡、倒入杯子、加调料方法 Coffee.prototype.brew = function() &#123; console.log('用沸水冲泡咖啡'); &#125;; Coffee.prototype.pourInCup = function() &#123; console.log('把咖啡倒进杯子'); &#125;; Coffee.prototype.addCondiments = function() &#123; console.log('加糖和牛奶'); &#125;; // coffee实例 var Coffee = new Coffee(); Coffee.init(); // 抽象子类-tea var Tea = function() &#123;&#125;; Tea.prototype = new Beverage(); Tea.prototype.brew = function() &#123; console.log('用沸水浸泡茶叶'); &#125;; Tea.prototype.pourInCup = function() &#123; console.log('把茶倒进杯子'); &#125;; Tea.prototype.addCondiments = function() &#123; console.log('加柠檬'); &#125;; var tea = new Tea(); tea.init(); // 上面Beverage.prototype.init 被称为模板方法。该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 钩子方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 在50中实现了下面的流程，如果有客人不加调料，该如何实现 // (1) 把水煮沸 // (2) 用沸水冲泡饮料 // (3) 把饮料倒进杯子 // (4) 加调料 // 钩子方法（hook）可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要“挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。 var Beverage = function() &#123;&#125;; Beverage.prototype.boilWater = function() &#123; console.log(\"把水煮沸\"); &#125;; Beverage.prototype.brew = function() &#123; throw new Error('子类必须重写brew 方法'); &#125;; Beverage.prototype.pourInCup = function() &#123; throw new Error('子类必须重写pourInCup 方法'); &#125;; Beverage.prototype.addCondiments = function() &#123; throw new Error('子类必须重写addCondiments 方法'); &#125;; Beverage.prototype.customerWantsCondiments = function() &#123; return true; // 默认需要调料 &#125;; Beverage.prototype.init = function() &#123; this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) &#123; // 如果挂钩返回true，则需要调料 this.addCondiments(); &#125; &#125;; var CoffeeWithHook = function() &#123;&#125;; CoffeeWithHook.prototype = new Beverage(); CoffeeWithHook.prototype.brew = function() &#123; console.log('用沸水冲泡咖啡'); &#125;; CoffeeWithHook.prototype.pourInCup = function() &#123; console.log('把咖啡倒进杯子'); &#125;; CoffeeWithHook.prototype.addCondiments = function() &#123; console.log('加糖和牛奶'); &#125;; CoffeeWithHook.prototype.customerWantsCondiments = function() &#123; return window.confirm('请问需要调料吗？'); &#125;; var coffeeWithHook = new CoffeeWithHook(); coffeeWithHook.init(); // 好莱坞原则 // 好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。” // 在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中， 而高层组件会决定什么时候、 以何种方式去使用这些底层组件， 高层组件对待底层组件的方式， 跟演艺公司对待新人演员一样，都是“ 别调用我们，我们会调用你”。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板方法模式在js中的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var Beverage = function(param) &#123; var boilWater = function() &#123; console.log(\"把水煮沸\"); &#125;; var brew = param.brew || function() &#123; throw new Error(\"必须传递brew方法\"); &#125;; var pourInCup = param.pourInCup || function() &#123; throw new Error(\"必须传递pourInCup方法\"); &#125;; var addCondiments = param.addCondiments || function() &#123; throw new Error(\"必须传递addCondiments方法\"); &#125;; var F = function() &#123;&#125;; F.prototype.init = function() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125;; return F; &#125;; var Coffee = Beverage(&#123; brew: function() &#123; console.log('用沸水冲泡咖啡'); &#125;, pourInCup: function() &#123; console.log('把咖啡倒进杯子'); &#125;, addCondiments: function() &#123; console.log('加糖和牛奶'); &#125; &#125;); var Tea = Beverage(&#123; brew: function() &#123; console.log('用沸水浸泡茶叶'); &#125;, pourInCup: function() &#123; console.log('把茶倒进杯子'); &#125;, addCondiments: function() &#123; console.log('加柠檬'); &#125; &#125;); var coffee = new Coffee(); coffee.init(); var tea = new Tea(); tea.init(); // 在这段代码中，我们把brew、pourInCup、addCondiments 这些方法依次传入Beverage 函数， Beverage 函数被调用之后返回构造器F。 F 类中包含了“ 模板方法” F.prototype.init。 跟继承得到的效果一样， 该“ 模板方法” 里依然封装了饮料子类的算法框架。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 享元模式基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 享元模式:享元(flyweight)模式是一种用于性能优化的模式，“ fly” 在这里是苍蝇的意思， 意为蝇量级。 享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 // 享元模式的目标是尽量减少共享对象的数量，享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）,关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。 // 内部状态存储于对象内部。 // 内部状态可以被一些对象共享。 // 内部状态独立于具体的场景，通常不会改变。 // 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 // 我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并储存在外部。 // 剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。 // 使用场景: // 一个程序中使用了大量的相似对象。 // 由于使用了大量对象，造成很大的内存开销。 // 对象的大多数状态都可以变为外部状态。 // 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。 // 使用举例:假设有个内衣工厂，目前的产品有50种男式内衣和50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。 // 正常情况下需要50 个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照 // var Model = function(sex, underwear) &#123; // this.sex = sex; // this.underwear = underwear; // &#125;; // Model.prototype.takePhoto = function() &#123; // console.log(\"sex=\" + this.sex + \";underwear=\" + this.underwear); // &#125;; // for (var i = 1; i &lt;= 50; i++) &#123; // var maleModel = new Model(\"male\", \"underwear\" + i); // maleModel.takePhoto(); // &#125; // for (var j = 1; j &lt;= 50; j++) &#123; // var femaleModel = new Model(\"female\", \"underwear\" + j); // femaleModel.takePhoto(); // &#125; // 这样会产生100个对象，如果有10000种内衣，则此程序会爆炸 // 优化，其实只要一个男模特、一个女模特，让他们分别试穿50件内衣然后拍照即可 var Model = function(sex) &#123; this.sex = sex; &#125;; Model.prototype.takePhoto = function() &#123; console.log(\"sex=\" + this.sex + \";underwear=\" + this.underwear); &#125;; var maleModel = new Model('male'), femaleModel = new Model('female'); for (var i = 1; i &lt;= 50; i++) &#123; maleModel.underwear = 'underwear' + i; maleModel.takePhoto(); &#125;; for (var j = 1; j &lt;= 50; j++) &#123; femaleModel.underwear = 'underwear' + j; femaleModel.takePhoto(); &#125;; // 上例中性别是内部状态，内衣是外部状态 // 可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 享元模式重构上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 普通上传 // var id = 0; // window.startUpload = function(uploadType, files) &#123; // for (var i = 0, file; file = files[i++];) &#123; // var uploadObj = new Upload(uploadType, file.fileName, file.fileSize); // uploadObj.init(id++); // &#125; // &#125;; // var Upload = function(uploadType, fileName, fileSize) &#123; // this.uploadType = uploadType; // this.fileName = fileName; // this.fileSize = fileSize; // this.dom = null; // &#125;; // Upload.prototype.init = function(id) &#123; // var that = this; // this.id = id; // this.dom = document.createElement(\"div\"); // this.dom.innerHTML = '&lt;span&gt;文件名称:' + this.fileName + ', 文件大小: ' + this.fileSize + '&lt;/span&gt;' + // '&lt;button class=\"delFile\"&gt;删除&lt;/button&gt;'; // this.dom.querySelector(\".delFile\").onclick = function() &#123; // that.delFile(); // &#125;; // document.body.appendChild(this.dom); // &#125;; // Upload.prototype.delFile = function() &#123; // if (this.fileSize &lt; 3000) &#123; // return this.dom.parentNode.removeChild(this.dom); // &#125; // if (window.confirm(\"确定要删除该文件吗？\" + this.fileName)) &#123; // return this.dom.parentNode.removeChild(this.dom); // &#125; // &#125;; // startUpload('plugin', [&#123; // fileName: '1.txt', // fileSize: 1000 // &#125;, &#123; // fileName: '2.html', // fileSize: 3000 // &#125;, &#123; // fileName: '3.txt', // fileSize: 5000 // &#125;]); // startUpload('flash', [&#123; // fileName: '4.txt', // fileSize: 1000 // &#125;, &#123; // fileName: '5.html', // fileSize: 3000 // &#125;, &#123; // fileName: '6.txt', // fileSize: 5000 // &#125;]); // 上面的问题在于，有多少个要上传的文件，就要需要创建多少个upload对象 // 使用享元模式重构 // uploadType是内部状态，fileName和fileSize都是外部状态 var Upload = function(uploadType) &#123; this.uploadType = uploadType; &#125;; Upload.prototype.delFile = function(id) &#123; uploadManager.setExternalState(id, this); if (this.fileSize &lt; 3000) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; if (window.confirm('确定要删除该文件吗? ' + this.fileName)) &#123; return this.dom.parentNode.removeChild(this.dom); &#125; &#125;; var UploadFactory = (function() &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function(uploadType) &#123; if (createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125;; &#125;)(); var uploadManager = (function() &#123; var uploadDatabase = &#123;&#125;; return &#123; add: function(id, uploadType, fileName, fileSize) &#123; var flyWeightObj = UploadFactory.create(uploadType); var dom = document.createElement(\"div\"); dom.innerHTML = '&lt;span&gt;文件名称:' + fileName + ', 文件大小: ' + fileSize + '&lt;/span&gt;' + '&lt;button class=\"delFile\"&gt;删除&lt;/button&gt;'; dom.querySelector('.delFile').onclick = function() &#123; flyWeightObj.delFile(id); &#125; document.body.appendChild(dom); uploadDatabase[id] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;; return flyWeightObj; &#125;, setExternalState: function(id, flyWeightObj) &#123; var uploadData = uploadDatabase[id]; for (var i in uploadData) &#123; flyWeightObj[i] = uploadData[i]; &#125; &#125; &#125;; &#125;)(); var id = 0; window.startUpload = function(uploadType, files) &#123; for (var i = 0, file; file = files[i++];) &#123; var uploadObj = uploadManager.add(++id, uploadType, file.fileName, file.fileSize); &#125; &#125;; startUpload('plugin', [&#123; fileName: '1.txt', fileSize: 1000 &#125;, &#123; fileName: '2.html', fileSize: 3000 &#125;, &#123; fileName: '3.txt', fileSize: 5000 &#125;]); startUpload('flash', [&#123; fileName: '4.txt', fileSize: 1000 &#125;, &#123; fileName: '5.html', fileSize: 3000 &#125;, &#123; fileName: '6.txt', fileSize: 5000 &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 对象池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 对象池维 // 护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如 // 果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后， 再进入 // 池子等待被下次获取。 // 对象池技术的应用非常广泛，HTTP 连接池和数据库连接池都是其代表应用。在Web 前端开 // 发中，对象池使用最多的场景大概就是跟DOM 有关的操作。很多空间和时间都消耗在了DOM // 节点上，如何避免频繁地创建和删除DOM 节点就成了一个有意义的话题。 // 对象池跟享元模式的思想有点相似,虽然innerHTML 的值A、B、C、D 等也可以看成节点的外部状态，但在这里我们并没有主动分离内部状态和外部状态的过程。 var toolTipFactory = (function() &#123; var toolTipPool = []; return &#123; create: function() &#123; if (toolTipPool.length === 0) &#123; // 对象池为空则创建一个div var div = document.createElement(\"div\"); document.body.appendChild(div); return div; &#125; else &#123; // 不为空则取出一个 return toolTipPool.shift(); &#125; &#125;, recover: function(tooltipDom) &#123; // 对象池回收dom return toolTipPool.push(tooltipDom); &#125; &#125;; &#125;)(); // 创建2个小气泡 var ary = []; for (var i = 0, str; str = [\"A\", \"B\"][i++];) &#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str; ary.push(toolTip); &#125; console.log(ary); // 地图需要重绘，所以先回收之前创建的2个气泡 for (var i = 0, toolTip; toolTip = ary[i++];) &#123; toolTipFactory.recover(toolTip); &#125;; // 创建6个气泡 for (var i = 0, str; str = ['A', 'B', 'C', 'D', 'E', 'F'][i++];) &#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML = str; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通用对象池12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 通用的创建对象池的工厂 var objectPoolFactory = function(creactObjFn) &#123; var objectPool = []; return &#123; create: function() &#123; var obj = objectPool.length === 0 ? creactObjFn.apply(this, arguments) : objectPool.shift(); return obj; &#125;, recover: function(obj) &#123; objectPool.push(obj); &#125; &#125;; &#125;; var iframeFactory = objectPoolFactory(function() &#123; var iframe = document.createElement(\"iframe\"); document.body.appendChild(iframe); iframe.onload = function() &#123; // 防止iframe重复加载的bug iframe.onload = null; // 加载完成后回收节点，供下次使用 iframeFactory.recover(iframe); &#125;; return iframe; &#125;); var iframe1 = iframeFactory.create(); iframe1.src = 'http://www.baidu.com'; var iframe2 = iframeFactory.create(); iframe2.src = 'http://www.qq.com'; setTimeout(function() &#123; var iframe3 = iframeFactory.create(); iframe3.src = 'http://www.163.com'; &#125;, 3000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 职责链模式基本定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 职责链模式:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系， 将这些对象连成一条链， 并沿着这条链传递该请求， 直到有一个对象处理它为止。 // 使用场景:类似队列的操作时可以用 // 使用举例:公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50 元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。我们的订单页面是PHP 吐出的模板，在页面加载之初，PHP 会传递给页面几个字段。 // orderType：表示订单类型（定金用户或者普通购买用户），code 的值为1 的时候是500 元定金用户，为2 的时候是200 元定金用户，为3 的时候是普通购买用户。 // pay：表示用户是否已经支付定金，值为true 或者false, 虽然用户已经下过500 元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。 // stock：表示当前用于普通购买的手机库存数量，已经支付过500 元或者200 元定金的用户不受此限制。 // 用普通流程写 // var order = function(orderType, pay, stock) &#123; // if (orderType === 1) &#123; // 500 元定金购买模式 // if (pay === true) &#123; // 已支付定金 // console.log('500 元定金预购, 得到100 优惠券'); // &#125; else &#123; // 未支付定金，降级到普通购买模式 // if (stock &gt; 0) &#123; // 用于普通购买的手机还有库存 // console.log('普通购买, 无优惠券'); // &#125; else &#123; // console.log('手机库存不足'); // &#125; // &#125; // &#125; else if (orderType === 2) &#123; // 200 元定金购买模式 // if (pay === true) &#123; // console.log('200 元定金预购, 得到50 优惠券'); // &#125; else &#123; // if (stock &gt; 0) &#123; // console.log('普通购买, 无优惠券'); // &#125; else &#123; // console.log('手机库存不足'); // &#125; // &#125; // &#125; else if (orderType === 3) &#123; // if (stock &gt; 0) &#123; // console.log('普通购买, 无优惠券'); // &#125; else &#123; // console.log('手机库存不足'); // &#125; // &#125; // &#125;; // order(1, true, 500); // 输出： 500 元定金预购, 得到100 优惠券 // 用职责链来重写 // 先把500 元订单、200 元订单以及普通购买分成3个函数 // 接下来把orderType、pay、stock 这3 个字段当作参数传递给500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后面的200 元订单函数，如果200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数 // 500 元订单 var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元定金预购, 得到100 优惠券'); &#125; else &#123; order200(orderType, pay, stock); // 将请求传递给200 元订单 // order200 和order500 耦合在一起 &#125; &#125;; // 200 元订单 var order200 = function(orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元定金预购, 得到50 优惠券'); &#125; else &#123; orderNormal(orderType, pay, stock); // 将请求传递给普通订单 &#125; &#125;; // 普通购买订单 var orderNormal = function(orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普通购买, 无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125;; // 测试结果： order500(1, true, 500); // 输出：500 元定金预购, 得到100 优惠券 order500(1, false, 500); // 输出：普通购买, 无优惠券 order500(2, true, 500); // 输出：200 元定金预购, 得到500 优惠券 order500(3, false, 500); // 输出：普通购买, 无优惠券 order500(3, false, 0); // 输出：手机库存不足 // 相比上面一个去掉了很多if判断，但是仍然存在每个处理对象相互耦合的问题，在order500中有order200 // 如果有天我们要增加300 元预订或者去掉200 元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 灵活可拆分的职责链节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 58中的第二个例子很不灵活，链中的每个节点无法灵活拆分和重组 var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元定金预购，得到100 优惠券'); &#125; else &#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125; &#125;; var order200 = function(orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元定金预购，得到50 优惠券'); &#125; else &#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125; &#125;; var orderNormal = function(orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普通购买，无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125;; // Chain.prototype.setNextSuccessor 指定在链中的下一个节点 // Chain.prototype.passRequest 传递请求给某个节点 var Chain = function(fn) &#123; this.fn = fn; this.successor = null; //表示在链中的下一个节点 &#125;; Chain.prototype.setNextSuccessor = function(successor) &#123; return this.successor = successor; &#125;; Chain.prototype.passRequest = function() &#123; var ret = this.fn.apply(this, arguments); if (ret === \"nextSuccessor\") &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); &#125; return ret; &#125;; // 将订单函数包装成职责链的节点 var chainOrder500 = new Chain(order500); var chainOrder200 = new Chain(order200); var chainOrderNormal = new Chain(orderNormal); // 然后指定节点在职责链中的顺序 chainOrder500.setNextSuccessor(chainOrder200); chainOrder200.setNextSuccessor(chainOrderNormal); // 传递请求 chainOrder500.passRequest(1, true, 500); // 输出：500 元定金预购，得到100 优惠券 chainOrder500.passRequest(2, true, 500); // 输出：200 元定金预购，得到50 优惠券 chainOrder500.passRequest(3, true, 500); // 输出：普通购买，无优惠券 chainOrder500.passRequest(1, false, 0); // 输出：手机库存不足 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 异步的职责链12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 在59中我们让每个节点函数同步返回一个特定的值\"nextSuccessor\"，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点函数中发起一个ajax异步请求，异步请求返回的结果才能决定是否继续在职责链中passRequest。 var Chain = function(fn) &#123; this.fn = fn; this.successor = null; //表示在链中的下一个节点 &#125;; Chain.prototype.setNextSuccessor = function(successor) &#123; return this.successor = successor; &#125;; Chain.prototype.passRequest = function() &#123; var ret = this.fn.apply(this, arguments); if (ret === \"nextSuccessor\") &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); &#125; return ret; &#125;; // 添加next，表示手动传递请求给下一节点 Chain.prototype.next = function() &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); &#125;; var fn1 = new Chain(function() &#123; console.log(1); return 'nextSuccessor'; &#125;); var fn2 = new Chain(function() &#123; console.log(2); var self = this; setTimeout(function() &#123; self.next(); &#125;, 1000); &#125;); var fn3 = new Chain(function() &#123; console.log(3); &#125;); fn1.setNextSuccessor(fn2).setNextSuccessor(fn3); fn1.passRequest(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用AOP实现职责链12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; Function.prototype.after = function(fn) &#123; var self = this; return function() &#123; var ret = self.apply(this, arguments); if (ret === 'nextSuccessor') &#123; return fn.apply(this, arguments); &#125; return ret; &#125; &#125;; var order500 = function(orderType, pay, stock) &#123; if (orderType === 1 &amp;&amp; pay === true) &#123; console.log('500 元定金预购，得到100 优惠券'); &#125; else &#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125; &#125;; var order200 = function(orderType, pay, stock) &#123; if (orderType === 2 &amp;&amp; pay === true) &#123; console.log('200 元定金预购，得到50 优惠券'); &#125; else &#123; return 'nextSuccessor'; // 我不知道下一个节点是谁，反正把请求往后面传递 &#125; &#125;; var orderNormal = function(orderType, pay, stock) &#123; if (stock &gt; 0) &#123; console.log('普通购买，无优惠券'); &#125; else &#123; console.log('手机库存不足'); &#125; &#125;; var order = order500.after(order200).after(orderNormal); order(1, true, 500); // 输出：500 元定金预购，得到100 优惠券 order(2, true, 500); // 输出：200 元定金预购，得到50 优惠券 order(1, false, 500); // 输出：普通购买，无优惠券 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用职责链获取文件上传对象12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; Function.prototype.after = function(fn) &#123; var self = this; return function() &#123; var ret = self.apply(this, arguments); if (ret === 'nextSuccessor') &#123; return fn.apply(this, arguments); &#125; return ret; &#125; &#125;; var getActiveUploadObj = function() &#123; try &#123; return new ActiveXObject(\"TXFTNActiveX.FTNUpload\"); // IE 上传控件 &#125; catch (e) &#123; return 'nextSuccessor'; &#125; &#125;; var getFlashUploadObj = function() &#123; if (supportFlash()) &#123; var str = '&lt;object type=\"application/x-shockwave-flash\"&gt;&lt;/object&gt;'; return $(str).appendTo($('body')); &#125; return 'nextSuccessor'; &#125;; var getFormUpladObj = function() &#123; return $('&lt;form&gt;&lt;input name=\"file\" type=\"file\"/&gt;&lt;/form&gt;').appendTo($('body')); &#125;; var getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUpladObj); console.log(getUploadObj()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中介者模式基本定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 中介者模式:程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。当对象多了以后，相互通信会变的非常封闭式。中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系 // 使用场景:当对象之间相互引用非常多时 // 使用举例:泡泡堂游戏、购买商品 function Player(name, teamColor) &#123; this.partners = []; // 队友列表 this.enemies = []; // 敌人列表 this.state = 'live'; // 玩家状态 this.name = name; // 角色名字 this.teamColor = teamColor; // 队伍颜色 &#125;; Player.prototype.win = function() &#123; // 玩家团队胜利 console.log('winner: ' + this.name); &#125;; Player.prototype.lose = function() &#123; // 玩家团队失败 console.log('loser: ' + this.name); &#125;; Player.prototype.die = function() &#123; // 玩家死亡 var all_dead = true; this.state = 'dead'; // 设置玩家状态为死亡 for (var i = 0, partner; partner = this.partners[i++];) &#123; // 遍历队友列表 if (partner.state !== 'dead') &#123; // 如果还有一个队友没有死亡，则游戏还未失败 all_dead = false; break; &#125; &#125; if (all_dead === true) &#123; // 如果队友全部死亡 this.lose(); // 通知自己游戏失败 for (var i = 0, partner; partner = this.partners[i++];) &#123; // 通知所有队友玩家游戏失败 partner.lose(); &#125; for (var i = 0, enemy; enemy = this.enemies[i++];) &#123; // 通知所有敌人游戏胜利 enemy.win(); &#125; &#125; &#125;; var playerFactory = function(name, teamColor) &#123; var newPlayer = new Player(name, teamColor); // 创建新玩家 for (var i = 0, player; player = players[i++];) &#123; // 通知所有的玩家，有新角色加入 if (player.teamColor === newPlayer.teamColor) &#123; // 如果是同一队的玩家 player.partners.push(newPlayer); // 相互添加到队友列表 newPlayer.partners.push(player); &#125; else &#123; player.enemies.push(newPlayer); // 相互添加到敌人列表 newPlayer.enemies.push(player); &#125; &#125; players.push(newPlayer); return newPlayer; &#125;; var players = []; //红队： var player1 = playerFactory('皮蛋', 'red'), player2 = playerFactory('小乖', 'red'), player3 = playerFactory('宝宝', 'red'), player4 = playerFactory('小强', 'red'); //蓝队： var player5 = playerFactory('黑妞', 'blue'), player6 = playerFactory('葱头', 'blue'), player7 = playerFactory('胖墩', 'blue'), player8 = playerFactory('海盗', 'blue'); player1.die(); player2.die(); player4.die(); player3.die(); // 问题,每个玩家和其他玩家都是紧紧耦合在一起的。当每个对象的状态发生改变，比如角色移动、吃到道具或者死亡时，都必须要显式地遍历通知其他对象。当玩家变的很多，则会爆炸 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中介者模式改造泡泡堂游戏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function Player(name, teamColor) &#123; this.name = name; // 角色名字 this.teamColor = teamColor; // 队伍颜色 this.state = 'alive'; // 玩家生存状态 &#125;; Player.prototype.win = function() &#123; console.log(this.name + ' won '); &#125;; Player.prototype.lose = function() &#123; console.log(this.name + ' lost'); &#125;; /*******************玩家死亡*****************/ Player.prototype.die = function() &#123; this.state = 'dead'; playerDirector.reciveMessage('playerDead', this); // 给中介者发送消息，玩家死亡 &#125;; /*******************移除玩家*****************/ Player.prototype.remove = function() &#123; playerDirector.reciveMessage('removePlayer', this); // 给中介者发送消息，移除一个玩家 &#125;; /*******************玩家换队*****************/ Player.prototype.changeTeam = function(color) &#123; playerDirector.reciveMessage('changeTeam', this, color); // 给中介者发送消息，玩家换队 &#125;; var playerFactory = function(name, teamColor) &#123; var newPlayer = new Player(name, teamColor); // 创造一个新的玩家对象 playerDirector.reciveMessage('addPlayer', newPlayer); // 给中介者发送消息，新增玩家 return newPlayer; &#125;; var playerDirector = (function() &#123; var players = &#123;&#125;, // 保存所有玩家 operations = &#123;&#125;; // 中介者可以执行的操作 /****************新增一个玩家***************************/ operations.addPlayer = function(player) &#123; var teamColor = player.teamColor; // 玩家的队伍颜色 players[teamColor] = players[teamColor] || []; // 如果该颜色的玩家还没有成立队伍，则新成立一个队伍 players[teamColor].push(player); // 添加玩家进队伍 &#125;; /****************移除一个玩家***************************/ operations.removePlayer = function(player) &#123; var teamColor = player.teamColor, // 玩家的队伍颜色 teamPlayers = players[teamColor] || []; // 该队伍所有成员 for (var i = teamPlayers.length - 1; i &gt;= 0; i--) &#123; // 遍历删除 if (teamPlayers[i] === player) &#123; teamPlayers.splice(i, 1); &#125; &#125; &#125;; /****************玩家换队***************************/ operations.changeTeam = function(player, newTeamColor) &#123; // 玩家换队 operations.removePlayer(player); // 从原队伍中删除 player.teamColor = newTeamColor; // 改变队伍颜色 operations.addPlayer(player); // 增加到新队伍中 &#125;; operations.playerDead = function(player) &#123; // 玩家死亡 var teamColor = player.teamColor, teamPlayers = players[teamColor]; // 玩家所在队伍 var all_dead = true; for (var i = 0, player; player = teamPlayers[i++];) &#123; if (player.state !== 'dead') &#123; all_dead = false; break; &#125; &#125; if (all_dead === true) &#123; // 全部死亡 for (var i = 0, player; player = teamPlayers[i++];) &#123; player.lose(); // 本队所有玩家lose &#125; for (var color in players) &#123; if (color !== teamColor) &#123; var teamPlayers = players[color]; // 其他队伍的玩家 for (var i = 0, player; player = teamPlayers[i++];) &#123; player.win(); // 其他队伍所有玩家win &#125; &#125; &#125; &#125; &#125;; var reciveMessage = function() &#123; var message = Array.prototype.shift.call(arguments); // arguments 的第一个参数为消息名称 operations[message].apply(this, arguments); &#125;; return &#123; reciveMessage: reciveMessage &#125; &#125;)(); // 红队： var player1 = playerFactory('皮蛋', 'red'), player2 = playerFactory('小乖', 'red'), player3 = playerFactory('宝宝', 'red'), player4 = playerFactory('小强', 'red'); // 蓝队： var player5 = playerFactory('黑妞', 'blue'), player6 = playerFactory('葱头', 'blue'), player7 = playerFactory('胖墩', 'blue'), player8 = playerFactory('海盗', 'blue'); player1.changeTeam('blue'); player2.die(); player3.die(); player4.die(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 普通方法购买商品123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;选择颜色: &lt;select id=\"colorSelect\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"red\"&gt;红色&lt;/option&gt; &lt;option value=\"blue\"&gt;蓝色&lt;/option&gt; &lt;/select&gt; 选择内存: &lt;select id=\"memorySelect\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"32G\"&gt;32G&lt;/option&gt; &lt;option value=\"16G\"&gt;16G&lt;/option&gt; &lt;/select&gt; 输入购买数量: &lt;input type=\"text\" id=\"numberInput\" /&gt; &lt;br/&gt; 您选择了颜色: &lt;div id=\"colorInfo\"&gt;&lt;/div&gt; &lt;br/&gt; 您选择了内存: &lt;div id=\"memoryInfo\"&gt;&lt;/div&gt; &lt;br/&gt; 您输入了数量: &lt;div id=\"numberInfo\"&gt;&lt;/div&gt; &lt;br/&gt; &lt;button id=\"nextBtn\" disabled=\"true\"&gt;请选择手机颜色和购买数量&lt;/button&gt; &lt;script&gt; // 假设我们正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输入购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量，按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车。 var colorSelect = document.getElementById('colorSelect'), numberInput = document.getElementById('numberInput'), colorInfo = document.getElementById('colorInfo'), numberInfo = document.getElementById('numberInfo'), nextBtn = document.getElementById('nextBtn'); var goods = &#123; // 手机库存 \"red|32G\": 3, // 红色32G，库存数量为3 \"red|16G\": 0, \"blue|32G\": 1, \"blue|16G\": 6 &#125;; colorSelect.onchange = function() &#123; var color = this.value, memory = memorySelect.value, stock = goods[color + '|' + memory]; number = numberInput.value, // 数量 colorInfo.innerHTML = color; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if (!memory) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if (!(/^[0-9]*[1-9][0-9]*$/).test(number)) &#123; // 输入购买数量是否为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if (number &gt; stock) &#123; // 当前选择数量没有超过库存量 nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车'; &#125;; numberInput.oninput = function() &#123; var color = colorSelect.value, // 颜色 number = this.value, // 数量 memory = memorySelect.value, stock = goods[color + '|' + memory]; number = numberInput.value, // 数量 numberInfo.innerHTML = number; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if (!memory) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if (!(/^[0-9]*[1-9][0-9]*$/).test(number)) &#123; // 输入购买数量是否为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if (number &gt; stock) &#123; // 当前选择数量没有超过库存量 nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车'; &#125;; memorySelect.onchange = function() &#123; var color = colorSelect.value, // 颜色 number = numberInput.value, // 数量 memory = this.value, stock = goods[color + '|' + memory]; // 该颜色手机对应的当前库存 memoryInfo.innerHTML = memory; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择手机颜色'; return; &#125; if (!memory) &#123; nextBtn.disabled = true; nextBtn.innerHTML = '请选择内存大小'; return; &#125; if (!(/^[0-9]*[1-9][0-9]*$/).test(number)) &#123; // 输入购买数量是否为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if (number &gt; stock) &#123; // 当前选择数量没有超过库存量 nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = '放入购物车'; &#125;; // 上面的方式，每个对象都耦合在一起，当修改一个地方，需要在每个事件里同步修改，非常不利于维护。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中介者模式购买商品123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;选择颜色: &lt;select id=\"colorSelect\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"red\"&gt;红色&lt;/option&gt; &lt;option value=\"blue\"&gt;蓝色&lt;/option&gt; &lt;/select&gt; 选择内存: &lt;select id=\"memorySelect\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"16G\"&gt;16G&lt;/option&gt; &lt;option value=\"32G\"&gt;32G&lt;/option&gt; &lt;/select&gt; 选择CPU: &lt;select id=\"cpuSelect\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"800\"&gt;800&lt;/option&gt; &lt;option value=\"801\"&gt;801&lt;/option&gt; &lt;/select&gt; 输入购买数量: &lt;input type=\"text\" id=\"numberInput\" /&gt; &lt;br/&gt; 您选择了颜色: &lt;div id=\"colorInfo\"&gt;&lt;/div&gt; &lt;br/&gt; 您选择了内存: &lt;div id=\"memoryInfo\"&gt;&lt;/div&gt; &lt;br/&gt;您选择了cpu: &lt;div id=\"cpuInfo\"&gt;&lt;/div&gt; &lt;br/&gt; 您输入了数量: &lt;div id=\"numberInfo\"&gt;&lt;/div&gt; &lt;br/&gt; &lt;button id=\"nextBtn\" disabled=\"true\"&gt;请选择手机颜色和购买数量&lt;/button&gt; &lt;script&gt; // 引入中介者模式,所有的节点对象只跟中介者通信 var goods = &#123; // 手机库存 \"red|32G|800\": 3, // 颜色red，内存32G，cpu800，对应库存数量为3 \"red|16G|801\": 0, \"blue|32G|800\": 1, \"blue|16G|801\": 6 &#125;; var mediator = (function() &#123; var colorSelect = document.getElementById('colorSelect'), memorySelect = document.getElementById('memorySelect'), numberInput = document.getElementById('numberInput'), colorInfo = document.getElementById('colorInfo'), cpuInfo = document.getElementById('cpuInfo'), memoryInfo = document.getElementById('memoryInfo'), numberInfo = document.getElementById('numberInfo'), nextBtn = document.getElementById('nextBtn'), cpuSelect = document.getElementById('cpuSelect'); return &#123; changed: function(obj) &#123; var color = colorSelect.value, memory = memorySelect.value, number = numberInput.value, cpu = cpuSelect.value, stock = goods[color + '|' + memory + '|' + cpu]; if (obj === colorSelect) &#123; colorInfo.innerHTML = color; &#125; else if (obj === memorySelect) &#123; memoryInfo.innerHTML = memory; &#125; else if (obj === cpuSelect) &#123; cpuInfo.innerHTML = cpu; &#125; else if (obj === numberInput) &#123; numberInfo.innerHTML = number; &#125; if (!color) &#123; nextBtn.disabled = true; nextBtn.innerHTML = \"请选择手机颜色\"; return; &#125; if (!memory) &#123; nextBtn.disabled = true; nextBtn.innerHTML = \"请选择手机内存大小\"; return; &#125; if (!cpu) &#123; nextBtn.disabled = true; nextBtn.innerHTML = \"请选择CPU\"; return; &#125; if (!(/^[0-9]*[1-9][0-9]*$/).test(number)) &#123; // 输入购买数量是否为正整数 nextBtn.disabled = true; nextBtn.innerHTML = '请输入正确的购买数量'; return; &#125; if (!stock || number &gt; stock) &#123; // 当前选择数量没有超过库存量 nextBtn.disabled = true; nextBtn.innerHTML = '库存不足'; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = \"放入购物车\"; &#125; &#125;; &#125;)(); colorSelect.onchange = function() &#123; mediator.changed(this); &#125;; memorySelect.onchange = function() &#123; mediator.changed(this); &#125;; cpuSelect.onchange = function() &#123; mediator.changed(this); &#125;; numberInput.oninput = function() &#123; mediator.changed(this); &#125;; // 当再添加一个cpu型号时，可直接在mediator中添加即可 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 装饰者模式基本定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 装饰者模式:装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象 动态地添加职责。 // 使用场景:当需要给对象动态的添加行为时 // 使用举例:统计代码、插件式验证等 // 传统装饰者模式 // var Plane = function() &#123;&#125; // Plane.prototype.fire = function() &#123; // console.log('发射普通子弹'); // &#125;; // var MissileDecorator = function(plane) &#123; // this.plane = plane; // &#125; // MissileDecorator.prototype.fire = function() &#123; // this.plane.fire(); // console.log('发射导弹'); // &#125;; // var AtomDecorator = function(plane) &#123; // this.plane = plane; // &#125;; // AtomDecorator.prototype.fire = function() &#123; // this.plane.fire(); // console.log('发射原子弹'); // &#125;; // var plane = new Plane(); // plane = new MissileDecorator(plane); // plane = new AtomDecorator(plane); // plane.fire(); // // 分别输出： 发射普通子弹、发射导弹、发射原子弹 // js中的装饰者模式 var plane = &#123; fire: function() &#123; console.log(\"发射普通\"); &#125; &#125;; var missileDecorator = function() &#123; console.log('发射导弹'); &#125; var atomDecorator = function() &#123; console.log('发射原子弹'); &#125; var fire1 = plane.fire; plane.fire = function() &#123; fire1(); missileDecorator(); &#125; var fire2 = plane.fire; plane.fire = function() &#123; fire2(); atomDecorator(); &#125; plane.fire(); // 分别输出： 发射普通子弹、发射导弹、发射原子弹 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 装饰函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // 装饰函数-&gt;为函数添加功能 // 最low的添加功能，直接改写原函数 // var a = function() &#123; // alert(1); // &#125;; // var a = function() &#123; // alert(1); // alert(2); // &#125;; // 保存原函数的引用，这种方法必须得维护_a这个中间量，如果装饰链过长或要装饰的函数过多，中间量就会变的很多;还会出现this劫持问题 // var a = function() &#123; // alert(1); // &#125;; // var _a = a; // a = function() &#123; // _a(); // alert(2); // &#125;; // a(); // 上面方法会出现下面的this劫持问题 // var _getElementById = document.getElementById; // document.getElementById = function(id) &#123; // alert(1); // return _getElementById(id); // (1) // &#125; // var button = document.getElementById('button'); // error // 报错原因是getElementById内部是要用到this,调用_getElementById时this是指向window而不是document，所以会报错 // 为解决上面问题，可以将document动态传入 var _getElementById = document.getElementById; document.getElementById = function() &#123; alert(1); return _getElementById.apply(document, arguments); &#125; var button = document.getElementById('button'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用AOP来装饰函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; Function.prototype.before = function(beforefn) &#123; var __self = this; // 保存原函数的引用 return function() &#123; // 返回包含了原函数和新函数的\"代理\"函数 beforefn.apply(this, arguments); // 执行新函数，且保证this 不被劫持，新函数接受的参数 // 也会被原封不动地传入原函数，新函数在原函数之前执行 return __self.apply(this, arguments); // 执行原函数并返回原函数的执行结果， // 并且保证this 不被劫持 &#125; &#125;; Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125; &#125;; document.getElementById = document.getElementById.before(function() &#123; alert(\"取button之前\"); &#125;); var button = document.getElementById('button'); console.log(button); window.onload = function() &#123; alert(1); &#125; window.onload = (window.onload || function() &#123;&#125;).after(function() &#123; alert(2); &#125;).after(function() &#123; alert(3); &#125;).after(function() &#123; alert(4); &#125;); // 上面的AOP 实现是在Function.prototype 上添加before 和after 方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传入before 或者after 方法 var before = function(fn, beforefn) &#123; return function() &#123; beforefn.apply(this, arguments); return fn.apply(this, arguments); &#125; &#125; var a = before( function() &#123; alert(3) &#125;, function() &#123; alert(2) &#125; ); a = before(a, function() &#123; alert(1); &#125;); a(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用AOP实现数据上报12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button tag=\"login\" id=\"button\"&gt;点击打开登录浮层&lt;/button&gt; &lt;script&gt; // 一般在业务完成后要要求添加上数据统计的功能 // 普通上报 // var showLogin = function() &#123; // console.log('打开登录浮层'); // log(this.getAttribute('tag')); // &#125; // var log = function(tag) &#123; // console.log('上报标签为: ' + tag); // // (new Image).src = 'http:// xxx.com/report?tag=' + tag; // 真正的上报代码略 // &#125; // document.getElementById('button').onclick = showLogin; // showLogin既打开浮层又上报 // 使用AOP分离 Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125; &#125;; var showLogin = function() &#123; console.log('打开登录浮层'); &#125;; var log = function() &#123; console.log('上报标签为: ' + this.getAttribute('tag')); &#125;; showLogin = showLogin.after(log); // 打开登录浮层之后上报数据 document.getElementById('button').onclick = showLogin; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用AOP动态改变函数的参数12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1,2公用了arguments，所以可以在1中将arguments改变 Function.prototype.before = function(beforefn) &#123; var __self = this; return function() &#123; beforefn.apply(this, arguments); // (1) return __self.apply(this, arguments); // (2) &#125; &#125;; var func = function(param) &#123; console.log(param); // 输出： &#123;a: \"a\", b: \"b\"&#125; &#125; func = func.before(function(param) &#123; param.b = 'b'; &#125;); func(&#123; a: 'a' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用AOP动态改变参数实现发送ajax前添加token12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 需要在每次发送ajax前添加一个验证用的token // 通常做法 // var getToken = function() &#123; // return 'Token'; // &#125; // var ajax = function(type, url, param) &#123; // param = param || &#123;&#125;; // param.Token = getToken(); // 发送ajax 请求的代码略... // &#125;; // 如果要将这个ajax发布到网上，可能有些人就不需要token // 改进 Function.prototype.before = function(beforefn) &#123; var __self = this; // 保存原函数的引用 return function() &#123; // 返回包含了原函数和新函数的\"代理\"函数 beforefn.apply(this, arguments); // 执行新函数，且保证this 不被劫持，新函数接受的参数 // 也会被原封不动地传入原函数，新函数在原函数之前执行 return __self.apply(this, arguments); // 执行原函数并返回原函数的执行结果， // 并且保证this 不被劫持 &#125; &#125;; var ajax = function(type, url, param) &#123; console.log(param); &#125;; var getToken = function() &#123; return \"Token\"; &#125;; // 在ajax发送之前添加token ajax = ajax.before(function(type, url, param) &#123; param.Token = getToken(); &#125;); ajax(\"get\", 'http:// xxx.com/userinfo', &#123; name: 'sven' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插件式的表单验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;用户名： &lt;input id=\"username\" type=\"text\" /&gt; 密码： &lt;input id=\"password\" type=\"password\" /&gt; &lt;input id=\"submitBtn\" type=\"button\" value=\"提交\"&gt; &lt;script&gt; // 正常写法 // var username = document.getElementById('username'), // password = document.getElementById('password'), // submitBtn = document.getElementById('submitBtn'); // var formSubmit = function() &#123; // if (username.value === '') &#123; // return alert('用户名不能为空'); // &#125; // if (password.value === '') &#123; // return alert('密码不能为空'); // &#125; // var param = &#123; // username: username.value, // password: password.value // &#125; // ajax('http:// xxx.com/login', param); // ajax 具体实现略 // &#125; // submitBtn.onclick = function() &#123; // formSubmit(); // &#125;; // 存在的问题formSubmit承担了过多的职责，一要验证，二要负责提交 // 将验证逻辑分离到validata中 // var validata = function() &#123; // if (username.value === '') &#123; // alert('用户名不能为空'); // return false; // &#125; // if (password.value === '') &#123; // alert('密码不能为空'); // return false; // &#125; // &#125;; // var formSubmit = function() &#123; // if (validata() === false) &#123; // 校验未通过 // return; // &#125; // var param = &#123; // username: username.value, // password: password.value // &#125; // ajax('http:// xxx.com/login', param); // &#125;; // submitBtn.onclick = function() &#123; // formSubmit(); // &#125;; // 此时，虽将验证逻辑抽离，但formSubmit中还需要validata的返回值 // 再次优化 Function.prototype.before = function(beforefn) &#123; var __self = this; return function() &#123; if (beforefn.apply(this, arguments) === false) &#123; // beforefn 返回false 的情况直接return，不再执行后面的原函数 return; &#125; return __self.apply(this, arguments); &#125; &#125;; var validata = function() &#123; if (username.value === '') &#123; alert('用户名不能为空'); return false; &#125; if (password.value === '') &#123; alert('密码不能为空'); return false; &#125; &#125;; var formSubmit = function() &#123; var param = &#123; username: username.value, password: password.value &#125; ajax('http:// xxx.com/login', param); &#125;; // 利用AOP动态织入验证逻辑 formSubmit = formSubmit.before(validata); submitBtn.onclick = function() &#123; formSubmit(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AOP的注意事项12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // before,after返回的实际上是一个新函数，所以原先保存在函数上的属性会丢失;这种装饰方式也叠加了函数的作用域，如果装饰的链条过长，性能上也会受到一些影响。 Function.prototype.after = function(afterfn) &#123; var __self = this; return function() &#123; var ret = __self.apply(this, arguments); afterfn.apply(this, arguments); return ret; &#125; &#125;; var func = function() &#123; alert(1); &#125; func.a = 'a'; func = func.after(function() &#123; alert(2); &#125;); alert(func.a); // 输出：undefined // 代理模式和装饰者模式的不同 // 代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系（Proxy 与它的实体之间的关系），这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理本体的引用，而装饰者模式经常会形成一条长长的装饰链。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 状态模式基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 状态模式:允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。往往将状态封装成一个类，跟此状态有关的所有行为都被封装在这个类的内部 // 使用场景:程序有多种状态，并状态改变会影响其他行为时 // 使用举例:一个开关的两个状态(开、关)，将影响灯泡的状态 var Light = function() &#123; this.state = 'off'; // 给电灯设置初始状态off this.button = null; // 电灯开关按钮 &#125;; Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; button.innerHTML = '开关'; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; self.buttonWasPressed(); &#125; &#125;; Light.prototype.buttonWasPressed = function() &#123; if (this.state === 'off') &#123; console.log('开灯'); this.state = 'on'; &#125; else if (this.state === 'on') &#123; console.log('关灯'); this.state = 'off'; &#125; &#125;; var light = new Light(); light.init(); //这个世界上的电灯并非只有一种。许多酒店里有另外一种电灯，这种电灯也只有一个开关，但它的表现是：第一次按下打开弱光，第二次按下打开强光，第三次才是关闭电灯 Light.prototype.buttonWasPressed = function() &#123; if (this.state === 'off') &#123; console.log('弱光'); this.state = 'weakLight'; &#125; else if (this.state === 'weakLight') &#123; console.log('强光'); this.state = 'strongLight'; &#125; else if (this.state === 'strongLight') &#123; console.log('关灯'); this.state = 'off'; &#125; &#125;; // 上面的缺点 // buttonWasPressed方法违反了开放-封闭原则，每次新增或修改light的状态都需要改动buttonWasPressed方法 // 所有跟状态有关的行为都封装在了buttonWasPressed方法里，以后若需要修改可能会造成此方法的无限膨胀 // 状态的切换非常不明显，仅仅表现在对state变量的赋值，实际过程中可能会遗忘，也无法一目了然的知道总共有多少状态 // 状态之间的切换关系依靠if...else来切换，维护麻烦 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 状态模式改进电灯程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 通常我们谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以button 被按下的的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为 // OffLightState var OffLightState = function(light) &#123; this.light = light; &#125;; OffLightState.prototype.buttonWasPressed = function() &#123; console.log(\"弱光\"); // offLightState对应的行为 this.light.setState(this.light.weakLightState); // 切换到weakLightState &#125;; // WeakLightState： var WeakLightState = function(light) &#123; this.light = light; &#125;; WeakLightState.prototype.buttonWasPressed = function() &#123; console.log('强光'); // weakLightState 对应的行为 this.light.setState(this.light.strongLightState); // 切换状态到strongLightState &#125;; // StrongLightState： var StrongLightState = function(light) &#123; this.light = light; &#125;; StrongLightState.prototype.buttonWasPressed = function() &#123; console.log('超强光'); // strongLightState 对应的行为 this.light.setState(this.light.superStrongLightState); // 切换状态到offLightState &#125;; var SuperStrongLightState = function(light) &#123; this.light = light; &#125;; SuperStrongLightState.prototype.buttonWasPressed = function() &#123; console.log('关灯'); this.light.setState(this.light.offLightState); &#125;; var Light = function() &#123; console.log(this); this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.superStrongLightState = new SuperStrongLightState(this); // 新增superStrongLightState 对象 this.button = null; &#125;; Light.prototype.init = function() &#123; var button = document.createElement(\"button\"), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = \"开关\"; this.currState = this.offLightState; // 设置当前状态 this.button.onclick = function() &#123; self.currState.buttonWasPressed(); &#125;; &#125;; Light.prototype.setState = function(newState) &#123; this.currState = newState; &#125;; var light = new Light(); light.init(); // 添加新状态时 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 状态模式的通用结构12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 首先定义了Light 类，Light类在这里也被称为上下文（Context）。随后在Light 的构造函数中，我们要创建每一个状态类的实例对象，Context将持有这些状态对象的引用，以便把请求委托给状态对象。用户的请求，即点击button的动作也是实现在Context中的 var Light = function() &#123; this.offLightState = new OffLightState(this); // 持有状态对象的引用 this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); this.superStrongLightState = new SuperStrongLightState(this); this.button = null; &#125;; Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; this.button = document.body.appendChild(button); this.button.innerHTML = '开关'; this.currState = this.offLightState; // 设置默认初始状态 this.button.onclick = function() &#123; // 定义用户的请求动作 self.currState.buttonWasPressed(); &#125; &#125;; // 接下来可能是个苦力活，我们要编写各种状态类，light对象被传入状态类的构造函数，状态对象也需要持有light对象的引用，以便调用light 中的方法或者直接操作light 对象 var OffLightState = function(light) &#123; this.light = light; &#125;; OffLightState.prototype.buttonWasPressed = function() &#123; console.log('弱光'); this.light.setState(this.light.weakLightState); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 状态模式实现文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; //文件在扫描状态中，是不能进行任何操作的，既不能暂停也不能删除文件，只能等待扫描完成。扫描完成之后，根据文件的md5 值判断，若确认该文件已经存在于服务器，直接跳到上传完成状态。如果该文件的大小超过允许上传的最大值，或者该文件已经损坏，则跳往上传失败状态。剩下的情况下才进入上传中状态。 // 上传过程中可以点击暂停按钮来暂停上传，暂停后点击同一个按钮会继续上传。 // 扫描和上传过程中，点击删除按钮无效，只有在暂停、上传完成、上传失败之后，才能 删除文件。 // 正常实现 window.external.upload = function(state) &#123; console.log(state); // 可能为sign、uploading、done、error &#125;; var plugin = (function() &#123; var plugin = document.createElement('embed'); plugin.style.display = 'none'; plugin.type = 'application/txftn-webkit'; plugin.sign = function() &#123; console.log('开始文件扫描'); &#125; plugin.pause = function() &#123; console.log('暂停文件上传'); &#125;; plugin.uploading = function() &#123; console.log('开始文件上传'); &#125;; plugin.del = function() &#123; console.log('删除文件上传'); &#125; plugin.done = function() &#123; console.log('文件上传完成'); &#125; document.body.appendChild(plugin); return plugin; &#125;)(); var Upload = function(fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.state = 'sign'; // 设置初始状态为waiting &#125;; Upload.prototype.init = function() &#123; var that = this; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称:' + this.fileName + '&lt;/span&gt;\\&lt;button data-action=\"button1\"&gt;扫描中&lt;/button&gt;\\&lt;button data-action=\"button2\"&gt;删除&lt;/button&gt;'; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector('[data-action=\"button1\"]'); // 第一个按钮 this.button2 = this.dom.querySelector('[data-action=\"button2\"]'); // 第二个按钮 this.bindEvent(); &#125;; Upload.prototype.bindEvent = function() &#123; var self = this; this.button1.onclick = function() &#123; if (self.state === 'sign') &#123; // 扫描状态下，任何操作无效 console.log('扫描中，点击无效...'); &#125; else if (self.state === 'uploading') &#123; // 上传中，点击切换到暂停 self.changeState('pause'); &#125; else if (self.state === 'pause') &#123; // 暂停中，点击切换到上传中 self.changeState('uploading'); &#125; else if (self.state === 'done') &#123; console.log('文件已完成上传, 点击无效'); &#125; else if (self.state === 'error') &#123; console.log('文件上传失败, 点击无效'); &#125; &#125;; this.button2.onclick = function() &#123; if (self.state === 'done' || self.state === 'error' || self.state === 'pause') &#123; // 上传完成、上传失败和暂停状态下可以删除 self.changeState('del'); &#125; else if (self.state === 'sign') &#123; console.log('文件正在扫描中，不能删除'); &#125; else if (self.state === 'uploading') &#123; console.log('文件正在上传中，不能删除'); &#125; &#125;; &#125;; Upload.prototype.changeState = function(state) &#123; switch (state) &#123; case 'sign': this.plugin.sign(); this.button1.innerHTML = '扫描中，任何操作无效'; break; case 'uploading': this.plugin.uploading(); this.button1.innerHTML = '正在上传，点击暂停'; break; case 'pause': this.plugin.pause(); this.button1.innerHTML = '已暂停，点击继续上传'; break; case 'done': this.plugin.done(); this.button1.innerHTML = '上传完成'; break; case 'error': this.button1.innerHTML = '上传失败'; break; case 'del': this.plugin.del(); this.dom.parentNode.removeChild(this.dom); console.log('删除完成'); break; &#125;; this.state = state; &#125;; var uploadObj = new Upload('JavaScript 设计模式与开发实践'); uploadObj.init(); window.external.upload = function(state) &#123; // 插件调用JavaScript 的方法 uploadObj.changeState(state); &#125;; window.external.upload('sign'); // 文件开始扫描 setTimeout(function() &#123; window.external.upload('uploading'); // 1 秒后开始上传 &#125;, 1000); setTimeout(function() &#123; window.external.upload('done'); // 5 秒后上传完成 &#125;, 5000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 状态模式重构文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.external.upload = function(state) &#123; console.log(state); // 可能为sign、uploading、done、error &#125;; var plugin = (function() &#123; var plugin = document.createElement('embed'); plugin.style.display = 'none'; plugin.type = 'application/txftn-webkit'; plugin.sign = function() &#123; console.log('开始文件扫描'); &#125; plugin.pause = function() &#123; console.log('暂停文件上传'); &#125;; plugin.uploading = function() &#123; console.log('开始文件上传'); &#125;; plugin.del = function() &#123; console.log('删除文件上传'); &#125; plugin.done = function() &#123; console.log('文件上传完成'); &#125; document.body.appendChild(plugin); return plugin; &#125;)(); var Upload = function(fileName) &#123; this.plugin = plugin; this.fileName = fileName; this.button1 = null; this.button2 = null; this.signState = new SignState(this); // 设置初始状态为waiting this.uploadingState = new UploadingState(this); this.pauseState = new PauseState(this); this.doneState = new DoneState(this); this.errorState = new ErrorState(this); this.currState = this.signState; // 设置当前状态 &#125;; Upload.prototype.init = function() &#123; var that = this; this.dom = document.createElement('div'); this.dom.innerHTML = '&lt;span&gt;文件名称:' + this.fileName + '&lt;/span&gt;\\&lt;button data-action=\"button1\"&gt;扫描中&lt;/button&gt;\\&lt;button data-action=\"button2\"&gt;删除&lt;/button&gt;'; document.body.appendChild(this.dom); this.button1 = this.dom.querySelector('[data-action=\"button1\"]'); this.button2 = this.dom.querySelector('[data-action=\"button2\"]'); this.bindEvent(); &#125;; Upload.prototype.bindEvent = function() &#123; var self = this; this.button1.onclick = function() &#123; self.currState.clickHandler1(); &#125; this.button2.onclick = function() &#123; self.currState.clickHandler2(); &#125; &#125;; Upload.prototype.sign = function() &#123; this.plugin.sign(); this.currState = this.signState; &#125;; Upload.prototype.uploading = function() &#123; this.button1.innerHTML = '正在上传，点击暂停'; this.plugin.uploading(); this.currState = this.uploadingState; &#125;; Upload.prototype.pause = function() &#123; this.button1.innerHTML = '已暂停，点击继续上传'; this.plugin.pause(); this.currState = this.pauseState; &#125;; Upload.prototype.done = function() &#123; this.button1.innerHTML = '上传完成'; this.plugin.done(); this.currState = this.doneState; &#125;; Upload.prototype.error = function() &#123; this.button1.innerHTML = '上传失败'; this.currState = this.errorState; &#125;; Upload.prototype.del = function() &#123; this.plugin.del(); this.dom.parentNode.removeChild(this.dom); &#125;; var StateFactory = (function() &#123; var State = function() &#123;&#125;; State.prototype.clickHandler1 = function() &#123; throw new Error('子类必须重写父类的clickHandler1 方法'); &#125; State.prototype.clickHandler2 = function() &#123; throw new Error('子类必须重写父类的clickHandler2 方法'); &#125; return function(param) &#123; var F = function(uploadObj) &#123; this.uploadObj = uploadObj; &#125;; F.prototype = new State(); for (var i in param) &#123; F.prototype[i] = param[i]; &#125; return F; &#125; &#125;)(); var SignState = StateFactory(&#123; clickHandler1: function() &#123; console.log('扫描中，点击无效...'); &#125;, clickHandler2: function() &#123; console.log('文件正在上传中，不能删除'); &#125; &#125;); var UploadingState = StateFactory(&#123; clickHandler1: function() &#123; this.uploadObj.pause(); &#125;, clickHandler2: function() &#123; console.log('文件正在上传中，不能删除'); &#125; &#125;); var PauseState = StateFactory(&#123; clickHandler1: function() &#123; this.uploadObj.uploading(); &#125;, clickHandler2: function() &#123; this.uploadObj.del(); &#125; &#125;); var DoneState = StateFactory(&#123; clickHandler1: function() &#123; console.log('文件已完成上传, 点击无效'); &#125;, clickHandler2: function() &#123; this.uploadObj.del(); &#125; &#125;); var ErrorState = StateFactory(&#123; clickHandler1: function() &#123; console.log('文件上传失败, 点击无效'); &#125;, clickHandler2: function() &#123; this.uploadObj.del(); &#125; &#125;); var uploadObj = new Upload('JavaScript 设计模式与开发实践'); uploadObj.init(); window.external.upload = function(state) &#123; uploadObj[state](); &#125;; window.external.upload('sign'); setTimeout(function() &#123; window.external.upload('uploading'); // 1 秒后开始上传 &#125;, 1000); setTimeout(function() &#123; window.external.upload('done'); // 5 秒后上传完成 &#125;, 5000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 状态模式注意事项1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 状态模式的优缺点 // 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。 // 避免Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了Context 中原本过多的条件分支。 // 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 // Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。 // 缺点 // 状态模式的缺点是会在系统中定义许多状态类，编写20 个状态类是一项枯燥乏味的工作，而且系统中会因此而增加不少对象。另外，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。 // 状态模式的性能优化点 // 有两种选择来管理state 对象的创建和销毁。第一种是仅当state 对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果state对象比较庞大，可以用第一种方式来节省内存，这样可以避免创建一些不会用到的对象并及时地回收它们。但如果状态的改变很频繁，最好一开始就把这些state 对象都创建出来，也没有必要销毁它们，因为可能很快将再次用到它们。 // 在本章的例子中，我们为每个Context 对象都创建了一组state 对象，实际上这些state对象之间是可以共享的，各Context 对象可以共享一个state 对象，这也是享元模式的应用场景之一。 // 状态模式和策略模式的关系 // 相同点 // 策略模式和状态模式的相同点是，它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。 // 不同点 // 策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js版本的状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 状态模式是状态机的实现之一，但在JavaScript 这种“无类”语言中，没有规定让状态对象一定要从类中创建而来。另外一点，JavaScript 可以非常方便地使用委托技术，并不需要事先让一个对象持有另一个对象。下面的状态机选择了通过Function.prototype.call 方法直接把请求委托给某个字面量对象来执行。 // 改写灯泡 var Light = function() &#123; this.currState = FSM.off; // 设置当前状态 this.button = null; &#125;; Light.prototype.init = function() &#123; var button = document.createElement(\"button\"), self = this; button.innerHTML = \"已关灯\"; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; self.currState.buttonWasPressed.call(self); // 把请求委托给FSM状态机 &#125;; &#125;; var FSM = &#123; off: &#123; buttonWasPressed: function() &#123; console.log('关灯'); this.button.innerHTML = '下一次按我是开灯'; this.currState = FSM.on; &#125; &#125;, on: &#123; buttonWasPressed: function() &#123; console.log('开灯'); this.button.innerHTML = '下一次按我是关灯'; this.currState = FSM.off; &#125; &#125; &#125;; var light = new Light(); light.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用delegate函数实现状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var delegate = function(client, delegation) &#123; return &#123; buttonWasPressed: function() &#123; // 将客户的操作委托给delegation 对象 return delegation.buttonWasPressed.apply(client, arguments); &#125; &#125; &#125;; var FSM = &#123; off: &#123; buttonWasPressed: function() &#123; console.log('关灯'); this.button.innerHTML = '下一次按我是开灯'; this.currState = this.onState; &#125; &#125;, on: &#123; buttonWasPressed: function() &#123; console.log('开灯'); this.button.innerHTML = '下一次按我是关灯'; this.currState = this.offState; &#125; &#125; &#125;; var Light = function() &#123; this.offState = delegate(this, FSM.off); this.onState = delegate(this, FSM.on); this.currState = this.offState; // 设置初始状态为关闭状态 this.button = null; &#125;; Light.prototype.init = function() &#123; var button = document.createElement('button'), self = this; button.innerHTML = '已关灯'; this.button = document.body.appendChild(button); this.button.onclick = function() &#123; self.currState.buttonWasPressed(); &#125; &#125;; var light = new Light(); light.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 表驱动的有限状态机1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 参考:https://github.com/jakesgordon/javascript-state-machine var fsm = StateMachine.create(&#123; initial: 'off', events: [&#123; name: 'buttonWasPressed', from: 'off', to: 'on' &#125;, &#123; name: 'buttonWasPressed', from: 'on', to: 'off' &#125;], callbacks: &#123; onbuttonWasPressed: function(event, from, to) &#123; console.log(arguments); &#125; &#125;, error: function(eventName, from, to, args, errorCode, errorMessage) &#123; console.log(arguments); // 从一种状态试图切换到一种不可能到达的状态的时候 &#125; &#125;); button.onclick = function() &#123; fsm.buttonWasPressed(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 适配器模式基本定义12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 适配器模式:适配器模式的作用是解决两个软件实体间的接口不兼容的问题,它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 // 使用场景:当两个接口不一样时，可以采用亡羊补牢的方式实现一个适配器，来提供一个统一的接口 // 使用举例:百度谷歌地图提供的展示地图的API不同，一个show,一个display var googleMap = &#123; show: function() &#123; console.log('开始渲染谷歌地图'); &#125; &#125;; var baiduMap = &#123; display: function() &#123; console.log('开始渲染百度地图'); &#125; &#125;; var baiduMapAdapter = &#123; show: function() &#123; return baiduMap.display(); &#125; &#125;; renderMap(googleMap); // 输出：开始渲染谷歌地图 renderMap(baiduMapAdapter); // 输出：开始渲染百度地图 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 单一职责原则基本定义12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 就一个类而言，应该仅有一个引起它变化的原因。在JS中类用的很少，单一职责更多的是体现在对象和方法上 // SRP原则体现为：一个对象（方法）只做一件事情。-&gt;职责分离 // SRP原则在代理模式、迭代器模式、单例模式、装饰者模式中都有体现 // 何时用职责分离: // 如果随着需求的变化，有2个职责总是同时变化，则不必分离他们 // 如果两个职责以后确定不会发生变化，则不用分离 // SRP原则优缺点 // 优点:降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。 // 缺点:会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最少知识原则基本定义1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。 // 最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。 // 中介者模式、外观模式(定义了一个高层接口去封装一组“子系统”，可以直接定义调用高层接口完成一组事情，也可调用子系统中的某一个接口完成某一个特定事情)中都有体现。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 开放封闭原则基本定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 在面向对象的程序设计中，开放-封闭原则（OCP）是最重要的一条原则 // 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。(进行扩展，但不能修改源代码-&gt;保留源码基础上增加代码) // 开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 // 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。 // 发布-订阅、模板方法、策略、代理、职责链等模式都有体现 // 过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。每当需要增加一个新的if时，就必须修改源代码。 // 当看到很多if时，应考虑能否使用对象的多态性来重构(找出变化部分，将其封装起来，这样就可以将变化的和稳定的隔离开来) // 反例，很多if，违反开放-封闭原则 // var makeSound = function(animal) &#123; // if (animal instanceof Duck) &#123; // console.log('嘎嘎嘎'); // &#125; else if (animal instanceof Chicken) &#123; // console.log('咯咯咯'); // &#125; // &#125;; // var Duck = function() &#123;&#125;; // var Chicken = function() &#123;&#125;; // makeSound(new Duck()); // 输出：嘎嘎嘎 // makeSound(new Chicken()); // 输出：咯咯咯 // 利用多态的思想，我们把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。当我们想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的makeSound 函数 var makeSound = function(animal) &#123; animal.sound(); &#125;; var Duck = function() &#123;&#125;; Duck.prototype.sound = function() &#123; console.log('嘎嘎嘎'); &#125;; var Chicken = function() &#123;&#125;; Chicken.prototype.sound = function() &#123; console.log('咯咯咯'); &#125;; makeSound(new Duck()); // 嘎嘎嘎 makeSound(new Chicken()); // 咯咯咯 /********* 增加动物狗，不用改动原有的makeSound 函数 ****************/ var Dog = function() &#123;&#125;; Dog.prototype.sound = function() &#123; console.log('汪汪汪'); &#125;; makeSound(new Dog()); // 汪汪汪 // 实现开放-封闭原则的其他方法:放置钩子见52、使用回调(特殊钩子) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接口和面向接口编程基本定义123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 接口: // 第一种含义:我们经常说一个库或者模块对外提供了某某API 接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节 // 第二种含义:是一些语言提供的关键字，比如Java 的interface。interface 关键字可以产生一个完全抽象的类。这个完全抽象的类用来表示一种契约，专门负责建立类与类之间的联系。 // 第三种含义:“面向接口编程”中的接口，接口的含义在这里体现得更为抽象。-&gt;接口是对象能响应的请求的集合。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码重构技巧基本定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 1.提炼函数 var getUserInfo = function() &#123; ajax('http:// xxx.com/userInfo', function(data) &#123; // 有打印数据的操作，可提炼出来 console.log('userId: ' + data.userId); console.log('userName: ' + data.userName); console.log('nickName: ' + data.nickName); &#125;); &#125;; // 改进 var getUserInfo = function() &#123; ajax('http:// xxx.com/userInfo', function(data) &#123; printDetails(data); &#125;); &#125;; var printDetails = function(data) &#123; console.log('userId: ' + data.userId); console.log('userName: ' + data.userName); console.log('nickName: ' + data.nickName); &#125;; // 2.合并重复的条件片段 var paging = function(currPage) &#123; // 每个分支里面都有jump if (currPage &lt;= 0) &#123; currPage = 0; jump(currPage); // 跳转 &#125; else if (currPage &gt;= totalPage) &#123; currPage = totalPage; jump(currPage); // 跳转 &#125; else &#123; jump(currPage); // 跳转 &#125; &#125;; // 改进 var paging = function(currPage) &#123; if (currPage &lt;= 0) &#123; currPage = 0; &#125; else if (currPage &gt;= totalPage) &#123; currPage = totalPage; &#125; jump(currPage); // 把jump 函数独立出来 &#125;; function jump(page) &#123; xxxxx &#125; // 3.把条件分支语句提炼成函数 var getPrice = function(price) &#123; var date = new Date(); if (date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9) &#123; // 可将判断夏天提取出来，单独使用 return price * 0.8; &#125; return price; &#125;; // 改进 var isSummer = function() &#123; var date = new Date(); return date.getMonth() &gt;= 6 &amp;&amp; date.getMonth() &lt;= 9; &#125;; var getPrice = function(price) &#123; if (isSummer()) &#123; // 夏天 return price * 0.8; &#125; return price; &#125;; // 4.合理使用循环 var createXHR = function() &#123; var xhr; try &#123; xhr = new ActiveXObject('MSXML2.XMLHttp.6.0'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('MSXML2.XMLHttp.3.0'); &#125; catch (e) &#123; xhr = new ActiveXObject('MSXML2.XMLHttp'); &#125; &#125; return xhr; &#125;; var xhr = createXHR(); // 可用循环一次生成 var createXHR = function() &#123; var versions = ['MSXML2.XMLHttp.6.0ddd', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp']; for (var i = 0, version; version = versions[i++];) &#123; try &#123; return new ActiveXObject(version); &#125; catch (e) &#123;&#125; &#125; &#125;; var xhr = createXHR(); // 5.提前让函数退出代替嵌套条件分支 var del = function(obj) &#123; var ret; if (!obj.isReadOnly) &#123; // 不为只读的才能被删除 if (obj.isFolder) &#123; // 如果是文件夹 ret = deleteFolder(obj); &#125; else if (obj.isFile) &#123; // 如果是文件 ret = deleteFile(obj); &#125; &#125; return ret; &#125;; // 改进 var del = function(obj) &#123; if (obj.isReadOnly) &#123; // 反转if 表达式 return; &#125; if (obj.isFolder) &#123; return deleteFolder(obj); &#125; if (obj.isFile) &#123; return deleteFile(obj); &#125; &#125;; // 6.传递对象参数代替过长的参数列表 var setUserInfo = function(id, name, address, sex, mobile, qq) &#123; console.log('id= ' + id); console.log('name= ' + name); console.log('address= ' + address); console.log('sex= ' + sex); console.log('mobile= ' + mobile); console.log('qq= ' + qq); &#125;; setUserInfo(1314, 'sven', 'shenzhen', 'male', '137********', 377876679); // 改进 var setUserInfo = function(obj) &#123; console.log('id= ' + obj.id); console.log('name= ' + obj.name); console.log('address= ' + obj.address); console.log('sex= ' + obj.sex); console.log('mobile= ' + obj.mobile); console.log('qq= ' + obj.qq); &#125;; setUserInfo(&#123; id: 1314, name: 'sven', address: 'shenzhen', sex: 'male', mobile: '137********', qq: 377876679 &#125;); // 7.尽量减少参数数量 var draw = function(width, height, square) &#123;&#125;; // 改进 var draw = function(width, height) &#123; var square = width * height; &#125;; // 8.少用三目运算符，仅在简单判断时使用，复杂情况下用if if (!aup || !bup) &#123; return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) : 0; &#125; // 9.分解大型类 // 10.用return退出多重循环 var func = function() &#123; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; return; &#125; &#125; &#125; console.log(i); // 这句代码没有机会被执行 &#125;; // 改进 var print = function(i) &#123; console.log(i); &#125;; var func = function() &#123; for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i * j &gt; 30) &#123; return print(i); &#125; &#125; &#125; &#125;; func(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"mini-program-bus","date":"2018-03-15T05:49:47.000Z","path":"2018/03/15/mini-program-bus/","text":"最近在做一个关于公交查询的小程序第一次接触小程序，有很多不熟悉的地方，特在此做个记录 微信小程序-公交查询笔记注册小程序 可以参照官网的教程https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1521093163 需要注意的是注册邮箱必须是未注册过公众号、个人微信号的邮箱才行 目录结构 app.js用来注册app程序的，有对应的生命周期钩子，可以在其中做一些初始化工作，app会在整个程序运行的生命周期内可访问，所以一些简单的数据传递、共享，可以通过在app.js中挂载全局变量的形式完成。 app.json用来配置app程序 pages字段用来指定总共有哪些页面，最上面的是程序启动页； 微信开发工具保存时，会自动刷新并返回到启动页，所以在开发非启动页页面时，可以通过将非启动页调整到pages字段最上面，来提高开发效率。 window主要用来配置app的一些样式(navigationBar样式)、全局功能(下拉刷新) networkTimeout用来配置网络的超时时间 app.wxss用来配置全局样式 可以在里面设计基础样式，如全局字体、背景色 wxss基本和css一样，css能用的，wxss基本都能用 project.config.json项目配置 pages文件夹主要用来存放页面，页面相关资源全部保存在一个页面文件中，如图中的index 每个页面文件夹(如index页面)中又包含页面对应的js、json(非必须，若设置了会覆盖app.json)、wxml、wxss(会覆盖app.wxss) utils用来保存一些工具函数 API Promisify 小程序提供的接口，用的都是回调函数的形式，这在开发时不太友好。不过，小程序提供的api接口的回调名一致，而且支持原生的promise，可以用promise来定义一个Promisify函数来。123456789101112131415161718// promisify.jsmodule.exports = (api) =&gt; &#123; return (options, ...params) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; api(Object.assign(&#123;&#125;, options, &#123; success: resolve, fail: reject &#125;), ...params); &#125;); &#125;&#125;// index.jsconst Promisify = require('../../utils/promise.js'); let promisiedGetLocation = Promisify(wx.getLocation);promisiedGetLocation(&#123; type: 'gcj02'&#125;).then((res)=&gt;&#123; console.log(res);&#125;); 不同页面通信 可以参考https://github.com/dannnney/weapp-event12345678910111213141516171819202122232425262728293031323334353637// event.jsvar events = &#123;&#125;;function on(name, self, callback) &#123; var tuple = [self, callback]; var callbacks = events[name]; if (Array.isArray(callbacks)) &#123; callbacks.push(tuple); &#125; else &#123; events[name] = [tuple]; &#125;&#125;function remove(name, self) &#123; var callbacks = events[name]; if (Array.isArray(callbacks)) &#123; events[name] = callbacks.filter((tuple) =&gt; &#123; return tuple[0] != self; &#125;) &#125;&#125;function emit(name, data) &#123; var callbacks = events[name]; if (Array.isArray(callbacks)) &#123; callbacks.map((tuple) =&gt; &#123; var self = tuple[0]; var callback = tuple[1]; callback.call(self, data); &#125;) &#125;&#125;exports.on = on;exports.remove = remove;exports.emit = emit; 清除input内容 小程序没有提供一个简便的方法清除input的内容，百度了下可以用以下方法实现 将input的value属性绑定到一个变量上，单击时置空变量 场景:实现搜索建议，搜索框带有清除按钮 将input的value绑定到变量a上，并监听input的oninput事件，将e.currentTarget.detail.value赋值给a,点击清除按钮时，置空a。 虽然完成了搜索建议和清除功能，但在手机上，快速删除时，光标会出现闪烁问题 坐标转换 wx.getLocation()可以返回wgs84坐标和gcj02坐标 wgs84坐标为gps坐标；国内地图公司一般不使用 硬件设备、谷歌地球、chrome devTool中的Sensor gcj02为在wgs84基础上加密的坐标，又称火星坐标系；国内大部分地图公司用的是gcj02 腾讯地图、高德地图国内、谷歌地图国内 bd09为百度地图使用的坐标系统，在gcj02的基础又加密了一层 百度地图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// Created by Wandergis on 2015/7/8.// 提供了百度坐标（BD09）、国测局坐标（火星坐标，GCJ02）、和WGS84坐标系之间的转换//定义一些常量var x_PI = 3.14159265358979324 * 3000.0 / 180.0;var PI = 3.1415926535897932384626;var a = 6378245.0;var ee = 0.00669342162296594323;// 百度坐标系 (BD-09) 与 火星坐标系 (GCJ-02)的转换// 即 百度 转 谷歌、高德// @param bd_lon// @param bd_lat// @returns &#123;*[]&#125;//function bd09togcj02(bd_lon, bd_lat) &#123; var x_pi = 3.14159265358979324 * 3000.0 / 180.0; var x = bd_lon - 0.0065; var y = bd_lat - 0.006; var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi); var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi); var gg_lng = z * Math.cos(theta); var gg_lat = z * Math.sin(theta); return [gg_lng, gg_lat]&#125;// 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换// 即谷歌、高德 转 百度// @param lng// @param lat// @returns &#123;*[]&#125;function gcj02tobd09(lng, lat) &#123; var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI); var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI); var bd_lng = z * Math.cos(theta) + 0.0065; var bd_lat = z * Math.sin(theta) + 0.006; return [bd_lng, bd_lat]&#125;// WGS84转GCj02// @param lng// @param lat// @returns &#123;*[]&#125;function wgs84togcj02(lng, lat) &#123; if (out_of_china(lng, lat)) &#123; return [lng, lat] &#125; else &#123; var dlat = transformlat(lng - 105.0, lat - 35.0); var dlng = transformlng(lng - 105.0, lat - 35.0); var radlat = lat / 180.0 * PI; var magic = Math.sin(radlat); magic = 1 - ee * magic * magic; var sqrtmagic = Math.sqrt(magic); dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI); dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI); var mglat = lat + dlat; var mglng = lng + dlng; return [mglng, mglat] &#125;&#125;// GCJ02 转换为 WGS84// @param lng// @param lat// @returns &#123;*[]&#125;function gcj02towgs84(lng, lat) &#123; if (out_of_china(lng, lat)) &#123; return [lng, lat] &#125; else &#123; var dlat = transformlat(lng - 105.0, lat - 35.0); var dlng = transformlng(lng - 105.0, lat - 35.0); var radlat = lat / 180.0 * PI; var magic = Math.sin(radlat); magic = 1 - ee * magic * magic; var sqrtmagic = Math.sqrt(magic); dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI); dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI); mglat = lat + dlat; mglng = lng + dlng; return [lng * 2 - mglng, lat * 2 - mglat] &#125;&#125;function transformlat(lng, lat) &#123; var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng)); ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0; ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0; return ret&#125;function transformlng(lng, lat) &#123; var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng)); ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0; ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0; return ret&#125;// 判断是否在国内，不在国内则不做偏移// @param lng// @param lat// @returns &#123;boolean&#125; function out_of_china(lng, lat) &#123; return (lng &lt; 72.004 || lng &gt; 137.8347) || ((lat &lt; 0.8293 || lat &gt; 55.8271) || false);&#125;module.exports=&#123; bd09togcj02: bd09togcj02, gcj02tobd09: gcj02tobd09, wgs84togcj02: wgs84togcj02, gcj02towgs84: gcj02towgs84,&#125;;","tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"postman-guide","date":"2018-02-24T01:34:28.000Z","path":"2018/02/24/postman-guide/","text":"最近在看postman文档(https://www.getpostman.com/docs/)记录一些常用操作 postman 常用操作介绍 postman是一个调试、管理接口的神器。 登不登录都可以使用，登录后可以同步数据。 界面 主要分两部分 左侧为侧边栏，包含历史记录(History)、集合(Collections) 右侧为request builder 历史记录Tab页 主要记录了之前操作的一些request；可以通过clear all来清空；以及上面的filter来筛选 每个请求左侧都会标识出请求的类型(post、get…) 集合Tab页 主要用来展示所有的项目 一般一个集合对应着一个项目，如ShangCheng就对应着一个项目； 黄色星星代表置顶项目 项目可以按照字母或者时间来排序 可以通过右键-&gt;edit对当前collection进行详细编辑，如添加描述、脚本等 request builder 主要用来构建请求 看下图，一共有5个红框，依次为 第一个框右侧为环境相关选项，下拉框可以选择当前request发送的环境(在环境中会定义一些变量)，比如可以为请求定义开发环境和生产环境，二者请求的url不同；眼睛图标，可以查看当前环境下定义的一些变量的具体值；再右侧齿轮是环境的管理 第二个框主要有当前请求的一些简单描述(注意在postman中可以使用markdown语法来写描述)；右侧examples可以用来保存当前request的example，供其他人查看请求可能返回的情况 第三个框中最左侧可以选择请求的类型(get、post..)，再右侧是url地址(path是定义的一个变量)，params是添加查询字符串的按钮，点击后可以通过key-value的形式添加查询字符串；再右侧是发送请求(可通过ctrl+enter来快速发送)以及保存当前请求 第四个框是request相关的，分别有 授权 request header(通过key-value形式添加) request body(会根据选择的请求类型，自动置灰，如选择get请求，request body会不可用) 可以在descriptions给value添加描述 pre-request script(请求发送之前会执行的脚本，js编写) tests(请求返回后会执行的script) 右侧cookie是cookie管理 右侧code是生成不同语言发送当前请求代码段的按钮，生成后可以直接拷贝使用 最后一个框是response相关的 body展示的是response body 可以通过pretty、raw(源码)、preview(传会图片时会有用)以不同形式来查看返回的值 cookie是后台返回的cookie header是response header test results是展示测试脚本执行的结果 变量 主要用来复用 常用的变量有环境变量、集合变量、全局变量 环境变量仅在对应对应环境中起作用 集合变量仅在当前集合中起作用 全局变量则是在任何地方都起作用 同名变量冲突时，作用范围小的生效，如一个变量同时在上述三个中都有定义，则环境变量中定义的生效 使用 使用双大括号包裹使用 如上文看到的双大括号path就是一个变量 传递参数 实际场景：在登录后，保存token，在后续的请求中带上token；这就涉及到如何保存，如何传递token了 解决:可以在登录接口的test中编写代码，将token做为一个变量保存到全局或者环境变量(需要先创建一个环境)中，在其他接口中直接使用此变量即可 总结 https://www.getpostman.com/docs/","tags":[{"name":"postman","slug":"postman","permalink":"http://yoursite.com/tags/postman/"}]},{"title":"same-origin-policy","date":"2018-02-05T02:07:24.000Z","path":"2018/02/05/same-origin-policy/","text":"前端时间，项目中遇到一些跨域问题，查阅了一些文档后，特在此做个记录。 浏览器的同源策略及规避方法同源策略(same-origin-policy) 同源策略主要是用来隔离一些潜在的恶意文件。保证用户信息的安全，防止恶意的网站窃取数据。https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy 例如AB两个不同源的网页，如果没有同源策略，AB之间就可以相互访问请求到对方的隐私信息(如cookie)，这样显然是不安全的。 什么是同源? 同源要求: 协议相同 域名相同 端口相同 举例 URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 如何规避同源策略(跨域) 虽然同源策略能保证一定的安全性，但是有时候我们需要请求不同源页面的资源，就需要跨过同源策略。 cookie 当AB两个页面，一级域名相同，二级域名不同时，可以通过同时设置document.domain为一级域名，就可以实现cookie的共享 A页面是http://a.test.com，B页面是http://b.test.com，二者因为二级域名不同，所以受同源策略的限制，无法共享cookie。可以同时设置document.domain=&#39;test.com&#39;来解决123456789// A页面document.domain='test.com'document.cookie = \"testName=cgh\"; // A页面设置cookie// B页面document.domain='test.com'...var allCookie = document.cookie; // B页面可以读取到A页面的cookie... iframe 使用iframe嵌套页面时，iframe的src不受同源策略的影响，可以加载任意地址的文档；当父页面和iframe存在同源限制时，将不能相互访问window和DOM。例如在A页面嵌套了百度，则在A页面是无法访问到百度首页的window和DOM的。父子页面同源时，能可以相互访问window、DOM 父子页面，一级域名相同，二级域名不同时，可以使用和cookie相同的办法（设置documen.domain）来解决，进而可以相互访问window和DOM 12345678910111213// http://www.test.com/a.html&lt;iframe src=\"child.test.com/b.html\"&gt;&lt;/iframe&gt;&lt;script&gt;document.domain='test.com';var user='cgh';&lt;/script&gt;// http://child.test.com/b.html&lt;script&gt;document.domain='test.com';console.log(window.parent.user);// 获取父窗口的变量&lt;/script&gt; 完全不同源的iframe可以通过以下方法实现 hash+hashchange 父页面将信息写入到子iframe的hash值中，子页面通过监听hashchange事件来接收信息(也可以采用setInterval向下兼容);子页面可以直接改写父页面的hash值(有些浏览器不允许直接修改父页面的hash值，可以通过在父页面A的同域下再创建一个中间页面C,在目标页面B嵌入C来实现，具体看下面例子)，父页面也可以监听hashchange来接收子页面的信息；参考:https://www.zhihu.com/question/20314348/answer/20025563123456789101112131415161718192021// http://w1.test.com/a.html，a页面中嵌入了不同源的b页面；a页面可以设置bFrame src中的hash值&lt;iframe id=\"bFrame\" src=\"http://ah122.cn/b.html\"&gt;&lt;/iframe&gt;// http://ah122.cn/b.html，b页面嵌套了和a页面同源的c页面&lt;iframe id=\"cFrame\" src=\"http://w1.test.com/c.html\" style=\"display:none\"&gt;&lt;/iframe&gt;&lt;script&gt; window.onhashchange = function()&#123;// b页面监听a页面改变bFrame Hash值的事件，并将值传递给和a同源的c页面 document.getElementById('cFrame').src = 'http://w1.test.com/c.html' + location.hash; &#125;&lt;/script&gt;// http://w1.test.com/c.html，和a页面同源，ac页面可以相互访问变量和DOM&lt;script&gt; window.onhashchange = function()&#123;// c页面监听到hash值改变，将值传递到同源的a页面 parent.parent._bHash = location.hash; &#125;&lt;/script&gt;// 总结A-&gt;B AB不同源，但A可以修改bFrame中src的hash值，B可以通过hashchange事件获取到传递过来的hash值B-&gt;A 因为B为子页面，而且不同源，无法直接传递数据或者修改A的window、DOM，必须找个中间桥梁来实现传递，于是，通过在B中嵌套和A同源的C页面，将数据通过修改cFrame的hash的方式传递给C页面，C页面通过hashchange事件接收到数据，并通过parent.parent将数据传递给A(AC同源，可以相互访问window、DOM)，这样就完成了子页面B像不同源的A页面传递数据的过程。 window.name 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页(iframe)设置了这个属性，后一个网页可以读取它(就是iframe即使src发生改变了，iframe对应的contentWindow.name都不会发生改变，除非重新设置了)。并且容量很大，正常2M，IE、FF可以达到32M; 利用window.name跨域，原理和hash值跨域类似，都需要一个中间(代理)页面；参考:http://www.cnblogs.com/rainman/archive/2011/02/21/1960044.html12345678910111213141516171819202122232425262728293031323334353637383940// a.com/a.html：应用页面。// a.com/c.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。// b.com/b.html：应用页面需要获取数据的页面，可称为数据页面。// a.com/a.html，a页面中创建并嵌入不同源的c页面；可以通过修改hash值来传递数据给b页面&lt;script&gt; var state = 0, iframe = document.createElement('iframe'), loadfn = function() &#123;// b.html加载完成后会执行 if (state === 1) &#123; var data = iframe.contentWindow.name; // 读取数据 alert(data); //弹出'需要回传给a的数据' &#125; else if (state === 0) &#123; state = 1; iframe.contentWindow.location = \"http://a.com/c.html\"; // 设置的代理文件 &#125; &#125;; iframe.src = 'http://b.com/b.html'; if (iframe.attachEvent) &#123; iframe.attachEvent('onload', loadfn); &#125; else &#123; iframe.onload = loadfn; &#125; document.body.appendChild(iframe); // 数据获取完毕后，可以销毁iframe iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe);&lt;/script&gt;// b.com/b.html，b页面可以监听hashchange事件来接收a页面传递来的数据&lt;script&gt;window.onhashchange=function()&#123; // 接收a传递来的数据 var receive=window.location.hash;&#125;;window.name='需要回传给a的数据';&lt;/script&gt;// a.com/c.html，是一个空白页面，什么都不需要处理，只需要和a页面同源 window.postMessage 无论是hash还是window.name都属于一种hack技术；H5引入了跨文档通信的API，postMessage；可以支持IE8+(IE89仅支持在iframe中传递)；参考:http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html1234567891011// a.com/a.htmlvar popup = window.open('http://b.com', 'title');popup.postMessage('Hello World!', 'http://b.com');// b.com/b.htmlwindow.addEventListener('message', function(e) &#123;// event.source：发送消息的窗口// event.origin: 消息发向的网址// event.data: 消息内容 console.log(e.data);// 'Hello World!'&#125;,false); AJAX 同源政策规定，AJAX请求只能发给同源的网址，否则就报错 跨域解决 架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务) 在vue-cli中可以通过配置express.Router.get()来实现对外接口请求 JSONP 在html中src、href请求的资源是不受同源策略的限制的;img、iframe、css、script可以加载任意的资源；jsonp就是利用script标签的src不受同源限制，并在创建时自动执行内部代码来实现的。 一个简单的jsonp实现；源码请查看:https://github.com/BryanAdamss/SourceSave/blob/master/Plugins/js/vendor/12_jsonp.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143(function(root, moduleName, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; define([], function() &#123; return (root[moduleName] = factory(root)); &#125;); &#125; else &#123; root[moduleName] = factory(root); &#125;&#125;(typeof window !== \"undefined\" ? window : this, \"c_jsonp\", function(win) &#123; if (typeof Object.assign != 'function') &#123; Object.defineProperty(Object, \"assign\", &#123; value: function assign(target, varArgs) &#123; 'use strict'; if (target == null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index]; if (nextSource != null) &#123; for (var nextKey in nextSource) &#123; if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, writable: true, configurable: true &#125;); &#125; function formatParams(obj) &#123; // 格式化参数 var arr = []; for (var key in obj) &#123; arr.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key])); &#125; return arr.join('&amp;'); &#125; var configs = &#123; url: '', data: &#123;&#125;, callbackKey: 'callback', // 和后台约定的确定回调名的key值 callbackName: ('jsonpCallback' + Math.random()).replace('.', ''), // 默认的随机回调名 timeout: 3000, // 超时时间 success: function(resp) &#123; // 会在请求成功时，调用callbackName对应的函数中执行success(为什么不直接执行success是因为，需要在callbackName对应的函数中做一些其他操作，如删除script、清除定时器) console.log(resp); &#125;, error: function() &#123; // 请求出错时，会直接调用 throw new Error('请求出错!'); &#125;, &#125;; function jsonp(options) &#123; var settings = Object.assign(&#123;&#125;, configs, options); if (!settings.url) &#123; throw new Error('url必须传入'); return; &#125; var params = ''; // 格式化参数 if (settings.data) &#123; settings.data[settings.callbackKey] = settings.callbackName; params = formatParams(settings.data); &#125; var timer = null; // 超时处理 if (settings.timeout) &#123; timer = setTimeout(function() &#123; win[settings.callbackName] = null; oHead.removeChild(oScript); settings.error &amp;&amp; settings.error.call(null); &#125;, settings.timeout); &#125; // 创建一个全局回调函数，等待jsonp调用 window[settings.callbackName] = function(resp) &#123; oHead.removeChild(oScript); if (timer) &#123; clearTimeout(timer); &#125; window[settings.callbackName] = null; settings.success &amp;&amp; settings.success.call(null, resp); &#125;; // 创建script并追加到页面上 var oHead = document.querySelector('head'); var oScript = document.createElement('script'); var hasQuestionMark = settings.url.indexOf('?') &lt; 0 ? false : true; var src = ''; if (hasQuestionMark) &#123; src = settings.url + params; &#125; else &#123; src = settings.url + '?' + params; &#125; oScript.src = src; oHead.appendChild(oScript); &#125; return jsonp;&#125;));// 使用&lt;script type=\"text/javascript\" src=\"js/vendor/12_jsonp.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;window.onload = function() &#123; main();&#125;;function main() &#123; getList();&#125;function getList() &#123; c_jsonp(&#123; url: 'http://192.168.23.126:8080/hfgj/app/cgh.do', data: &#123; id: 3, name: 'cgh' &#125;, success: function(resp) &#123; console.log(resp); &#125;, error: function() &#123; console.log('出错了'); &#125; &#125;);&#125;&lt;/script&gt; websocket 双向实时全双工通信，支持跨域连接；具体参考:http://www.52im.net/forum.php?mod=viewthread&amp;tid=331&amp;ctid=15 CORS 跨资源共享，需要在服务端配置Access-Control-Allow-Origin为*，代表允许任何来源的请求资源；客户端在发送请求时需要带上origin来标识请求来自哪个域，好让服务端做验证。具体可参考:http://www.ruanyifeng.com/blog/2016/04/cors.html 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E8%B7%A8%E6%BA%90%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AEhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORShttp://www.cnblogs.com/rainman/archive/2011/02/20/1959325.htmlhttp://www.cnblogs.com/rainman/archive/2011/02/21/1960044.htmlhttp://www.ruanyifeng.com/blog/2016/04/same-origin-policy.htmlhttp://www.ruanyifeng.com/blog/2016/04/cors.html","tags":[{"name":"CORS","slug":"CORS","permalink":"http://yoursite.com/tags/CORS/"},{"name":"JSONP","slug":"JSONP","permalink":"http://yoursite.com/tags/JSONP/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"vue-music-note","date":"2018-01-30T09:08:32.000Z","path":"2018/01/30/vue-music-note/","text":"幕客网音乐app学习笔记 幕客网音乐app学习笔记vue-cli 初始化 vue init webpack vue-music，如果没有，会自动创建vue-music文件夹 vue-cli的runtime+compiler vs runtime选择 前者会包含编译器，适合在需要客户端编译模板的时候 后者因为不包含编译器，最终编译出来的大小会比前者小，适用于基于.vue文件开发使用了vue-loader的情况。一般选择这个 vue-cli的eslint模式 使用standard 基本命令 可在package.json的scripts中查询到 npm start、npm run dev启动开发服务器，默认在localhost:8080端口；若想在其他电脑查看，可配置config/index.js下的host字段为本机IP 修改vue-cli目录 默认目录结构 12345678910111213141516171819/vue-music|---build/ // 存放webpack构建相关文件，一般不建议修改|---config/ // 构建的一些配置参数，如果需要对构建过程做一些修改，可以配置此文件|---node_modules/|---src/ // 存放开发的主要文件，一般需要修改这里的目录结构 assets/ // 存放一些需要webpack处理的静态文件 components/ // 存放vue的.vue组件 router/ // 存放路由文件 App.vue // 根组件，一般做整体布局用 main.js // 入口文件，负责渲染App.vue文件，并进行一些全局性的操作；全局性样式可在这里通过import &apos;test.scss&apos;导入|---static/ // 存放不需要webpack处理可以直接使用的静态文件|---.babelrc // babel配置|---.editorconfig|---.eslintrc.js // eslint配置文件|---.gitignore|---.postcssrc.js // postcss配置|---index.html // spa的主体html文件，需要修改一些head中代码，js代码会通过webpack自动注入|---package.json // 保存项目所有的依赖|---README.md 修改后的目录，开发时主要修改的是/src/目录结构 1234567891011121314151617181920212223242526272829303132/vue-music|---build/|---config/|---node_modules/|---src/ api/ // 存放请求后台接口的js文件以及接口的通用配置参数文件 base/ // 存放基础(通用)组件，以文件夹做区分 base1/ base1.vue base2/ base2.vue common/ // 存放一些通用的js、img、字体等静态资源 components/ // 存放业务组件，组件用不同的文件夹区分，组件自身用到的资源组织到一个文件夹中 comp1/ com1Bg.jpg comp1.vue comp2/ comp2.vue router/ store/ // 存放vuex相关文件 sass/ // 存放sass样式文件 App.vue main.js|---static/|---.babelrc|---.editorconfig|---.gitignore|---.postcssrc.js|---index.html|---package.json|---README.md vue-cli本身不自带样式预处理器，需要手动安装npm install --save-dev node-sass sass-loader vue-cli会配置路径别名@指向/src/文件夹，所以可以通过@/components/comp1/comp1来引用组件；也可以手动配置路径别名，减少书写量。 vue-router 需要在/src/router/index.js中导入vue-router，并导出一个router的实例，最后在入口js(main.js)中导入并注册 1234567891011121314151617181920212223242526272829303132333435363738394041// router/index.jsimport Vue from &apos;vue&apos;;import Router from &apos;vue-router&apos;;// 导入vue-router..import Recommend from &apos;components/recommend/recommend&apos;import Singer from &apos;components/singer/singer&apos;...Vue.use(Router); // 必须使用use方法来注册第三方插件export default new Router(&#123;// 导出一个vue-router实例 routes: [&#123; path: &apos;/&apos;, redirect: &apos;/recommend&apos;,// 没有匹配到的路径全部重定向到/recomend &#125;, &#123; path: &apos;/recommend&apos;,// path一定是个路径，开头必须有/ name: &apos;Recommend&apos;, component: Recommend, children: [&#123;// 子路由 path: &apos;:id&apos;,// 传递的参数 name: &apos;Disc&apos;, component: Disc &#125;]&#125;)// src/main.jsimport Vue from &apos;vue&apos;...import router from &apos;./router&apos;; // 导入...new Vue(&#123; el: &apos;#app&apos;, router,// 注册 store, render: h =&gt; h(App)&#125;) router-link 123&lt;router-link tag=&quot;div&quot; class=&quot;tab-item&quot; to=&quot;/recommend&quot; active-class=&quot;is-cur&quot;&gt; // 渲染成div，跳转到/recommend路径，并在激活时添加is-cur样式类 &lt;span class=&quot;tab-link&quot;&gt;推荐&lt;/span&gt; &lt;/router-link&gt; 使用babel vue-cli的babel转义不太清楚，为什么用了很多preset，难道不是用最新的babel-preset-env就可以了吗？疑惑中… 自己总结的babel使用经验 使用babel-preset-env，并配置targets浏览器 结合useBuiltIns:usage选项和babel-polyfill来完成按需polyfill 参考 https://github.com/babel/babel/tree/master/packages/babel-preset-env fastclick 取消移动端点击300ms延迟 入口文件中导入，并绑定到body上 1234567// src/main.js...import fastclick from &apos;fastclick&apos;...fastclick.attach(document.body) 注意:fastclick会拦截click事件，如果一个组件内部需要监听click事件时，可在对应DOM节点上添加needsclick样式类告诉fastclick不拦截此DOM的click事件 import/export 通过import可以导入各种模块1234567891011121314151617181920import Test from &apos;./components/test/test&apos;; // 相对路径查找import &#123;getRecommend,getDiscList&#125; from &apos;./api/recommend&apos;; // 导入特定方法import myDefault,* as myObj from &apos;./a&apos;; // 导入所有方法(默认方法+其他方法)import Vue from &apos;vue&apos;; // 直接以名字开头，会在node_modules下查找import createLogger from &apos;vuex/dist/logger&apos;; // 可以在node_modules下按路径查找// 配置了别名的情况下，可以直接使用名字开头，如果没配置别名则会在node_modules下查找// webpack.base.conf.jsmodule.exports = &#123; ... resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;components&apos;: resolve(&apos;src/components&apos;), &#125; &#125;,&#125;import Test from &apos;components/test/test&apos;; jsonp 原理:script标签没有同源策略限制。通过动态创建script标签，然后src指向api地址，并附带一个回调函数名，后端用前台传来的回调名将需要的数据包裹并传回前台，前台会自动执行提前写好的回调。jsonp是get请求； 下面是jsonp的简单实现，具体可查看:https://github.com/BryanAdamss/SourceSave/blob/master/Plugins/js/vendor/11_jsonp.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115(function(root, moduleName, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; define([], function() &#123; return (root[moduleName] = factory(root)); &#125;); &#125; else &#123; root[moduleName] = factory(root); &#125;&#125;(typeof window !== \"undefined\" ? window : this, \"c_jsonp\", function(win) &#123; if (typeof Object.assign != 'function') &#123; Object.defineProperty(Object, \"assign\", &#123; value: function assign(target, varArgs) &#123; 'use strict'; if (target == null) &#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index]; if (nextSource != null) &#123; for (var nextKey in nextSource) &#123; if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, writable: true, configurable: true &#125;); &#125; function formatParams(obj) &#123; // 格式化参数 var arr = []; for (var key in obj) &#123; arr.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key])); &#125; return arr.join('&amp;'); &#125; var configs = &#123; url: '', data: &#123;&#125;, callbackKey: 'callback', // 和后台约定的确定回调名的key值 callbackName: ('jsonpCallback' + Math.random()).replace('.', ''), // 默认的随机回调名 timeout: 3000, // 超时时间 success: function(resp) &#123; // 会在请求成功时，调用callbackName对应的函数中执行success(为什么不直接执行success是因为，需要在callbackName对应的函数中做一些其他操作，如删除script、清除定时器) console.log(resp); &#125;, error: function() &#123; // 请求出错时，会直接调用 throw new Error('请求出错!'); &#125;, &#125;; function jsonp(options) &#123; var settings = Object.assign(&#123;&#125;, configs, options); if (!settings.url) &#123; throw new Error('url必须传入'); return; &#125; var params = ''; // 格式化参数 if (settings.data) &#123; settings.data[settings.callbackKey] = settings.callbackName; params = formatParams(settings.data); &#125; var timer = null; // 超时处理 if (settings.timeout) &#123; timer = setTimeout(function() &#123; win[settings.callbackName] = null; oHead.removeChild(oScript); settings.error &amp;&amp; settings.error.call(null); &#125;, settings.timeout); &#125; // 创建一个全局回调函数，等待jsonp调用 window[settings.callbackName] = function(resp) &#123; oHead.removeChild(oScript); if (timer) &#123; clearTimeout(timer); &#125; window[settings.callbackName] = null; settings.success &amp;&amp; settings.success.call(null, resp); &#125;; // 创建script并追加到页面上 var oHead = document.querySelector('head'); var oScript = document.createElement('script'); var hasQuestionMark = settings.url.indexOf('?') &lt; 0 ? false : true; var src = ''; if (hasQuestionMark) &#123; src = settings.url + params; &#125; else &#123; src = settings.url + '?' + params; &#125; oScript.src = src; oHead.appendChild(oScript); &#125; return jsonp;&#125;)); vue中可以使用webmodules/jsonp模块(github下载)来实现jsonp请求 默认是使用回调函数的形式 改造成promise形式1234567891011121314151617181920212223242526import originJsonp from 'jsonp'; // 导入原来回调形式的jsonpexport default function jsonp(url, data, option) &#123; url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data); return new Promise((resolve, reject) =&gt; &#123;// 返回一个promise实例，供后面使用then方法 originJsonp(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data); &#125; else &#123; reject(err); &#125; &#125;); &#125;);&#125;function param(data) &#123;// 格式化参数 let url = ''; for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : ''; url += `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;`; &#125; return url ? url.substring(1) : '';&#125; 组件何时拉取数据？ 组件拉取后台数据一般放在created钩子中，并将获取数据封装成一个methods12345678910111213141516171819202122232425import &#123;getRecommend,getDiscList&#125; from 'api/recommend'; // 导入实际拉取数据的方法import &#123;ERR_OK&#125; from 'api/config';// 为保证语义化，可以将一些常见状态定义为常量export default&#123; created()&#123; this._getRecommend(); this._getDiscList(); &#125;, methods:&#123; _getRecommend()&#123; getRecommend().then((res)=&gt;&#123; if(res.code===ERR_OK)&#123; this.recommends=res.data.slider; &#125; &#125;); &#125;, _getDiscList()&#123; getDiscList().then((res)=&gt;&#123; if(res.code===ERR_OK)&#123; this.discList=res.data.list; &#125; &#125;); &#125;, &#125;&#125;; 封装轮播组件 底层使用better-scroll实现 基本原理:外部一个固定尺寸的容器(尺寸better-scroll会自动设置)，内部有一个超出尺寸的内容;动态设置内容的transform； 下面的slide是容器，sliderGroup是内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;template&gt; &lt;div class=\"slider\" ref=\"slider\"&gt; &lt;div class=\"slider-group\" ref=\"sliderGroup\"&gt; &lt;slot&gt; &lt;/slot&gt; &lt;/div&gt; &lt;div class=\"dots\"&gt; &lt;span v-for=\"(item,index) in dots\" class=\"dot\" :class=\"&#123;active:index===currentPageIndex&#125;\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt; import BScroll from 'better-scroll'; import &#123;addClass&#125; from 'common/js/dom'; export default &#123; data()&#123; return &#123; dots:[], currentPageIndex:0,// 指示当前dots &#125;; &#125;, props:&#123; loop:&#123; type:Boolean, default:true, &#125;, autoPlay:&#123; type:Boolean, default:true, &#125;, interval:&#123; type:Number, default:4000 &#125; &#125;, mounted()&#123; // DOM准备好时，初始化；可以用this.$nextTick(),更推荐用setTimeout(()=&gt;&#123;&#125;,20); setTimeout(()=&gt;&#123; this._setSliderWidth(); this._initDots(); this._initSlider(); if(this.autoPlay)&#123; this._play(); &#125; &#125;,20); window.addEventListener('resize',()=&gt;&#123; if(!this.slider)&#123; return ; &#125; this._setSliderWidth(true); this.slider.refresh(); &#125;); &#125;, destoryed()&#123; // 组件切换后，应该停止timer clearTimeout(this.timer); &#125;, methods:&#123; _setSliderWidth(isResize)&#123; this.children=this.$refs.sliderGroup.children; let width=0; let sliderWidth=this.$refs.slider.clientWidth; for(let i=0;i&lt;this.children.length;i++)&#123; let child =this.children[i]; // 我们不应该要求传入的slot是特定样式的，应该我们主动添加样式，这样可以降低和外部的耦合 addClass(child,'slider-item'); child.style.width=sliderWidth+'px'; width+=sliderWidth; &#125; // 因为better-scroll在循环时，会在前后自动复制一个，所以总宽度需要加2 if(this.loop &amp;&amp; !isResize)&#123; width+=2*sliderWidth; &#125; // 设置内容的宽度 this.$refs.sliderGroup.style.width=width + 'px'; &#125;, _initDots()&#123; // dots为一个只有长度的空数组，方便渲染dots // this.children在_setSliderWidth中已经声明 this.dots=new Array(this.children.length); &#125;, _initSlider()&#123; this.slider=new BScroll(this.$refs.slider,&#123; scrollX: true,// 横向滚动 scrollY: false, momentum: false,// 动量动画 snap: &#123; loop: true,// 循环 threshold: 0.1, speed:400 &#125;, &#125;); // 监听better-scroll派发的scrollEnd事件，更新currentPageIndex this.slider.on('scrollEnd',()=&gt;&#123; let pageIndex=this.slider.getCurrentPage().pageX; // 循环播放会在头尾复制一个，所以index需要-1 if(this.loop)&#123; pageIndex-=1; &#125; this.currentPageIndex=pageIndex; if(this.autoPlay)&#123; clearTimeout(this.timer); this._play(); &#125; &#125;); &#125;, _play()&#123; // 要滚动到的索引值 let pageIndex=this.currentPageIndex+1; // 循环，因为存在头尾复制，所以需要再+1 if(this.loop)&#123; pageIndex+=1; &#125; this.timer=setTimeout(()=&gt;&#123; // 横向滚动到pageIndex页 this.slider.goToPage(pageIndex,0,400); &#125;,this.interval); &#125;, &#125; &#125;&lt;/script&gt; keep-alive 用来缓存不活动的组件 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 和transition组件使用时，要放在transition内部 12345&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 后端接口代理 有些接口会在请求时配置请求头的Host和Referer来限制随意访问，纯前端无法直接绕过。 因为vue-cli使用的express框架，可以借助express框架的Router来实现后端接口反向代理工作 正反向代理 正向代理 代理人代理的是客户端(VPN)，代理人充当的是客户端，负责接受服务器传来的数据 反向代理 代理人代理的是服务端(负载均衡,其实就是服务器内容分发)，代理人充当的是服务端，提供数据给前台 为何反向代理可以实现跨域请求 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就没有跨越问题。 通俗易懂解释可参考 https://www.aliyun.com/jiaocheng/21099.html http://blog.csdn.net/zhanghanboke/article/details/77488894123456789101112131415161718192021const app = express()const apiRoutes = express.Router();apiRoutes.get('/getDiscList', function (req, res) &#123; var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg' axios.get(url, &#123; headers: &#123; // 配置refer、host referer: 'https://c.y.qq.com/', host: 'c.y.qq.com' &#125;, params: req.query &#125;).then((response) =&gt; &#123; res.json(response.data) &#125;).catch((e) =&gt; &#123; console.log(e) &#125;)&#125;);app.use('/api', apiRoutes); // 所有/api下的请求都会由后台发送给远程服务器，成功后返回数据给后台，后台再传给前台(代理人充当了远程服务器的角色，负责提供数据给前台) 封装scroll组件 底层使用better-scroll 注意:better-scroll的可滚动距离是自动计算r的，所以初始化一定要在DOM渲染好后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;template&gt; &lt;div ref=\"wrapper\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt; import BScroll from 'better-scroll' export default&#123; props: &#123; // 如何派发scroll事件(0默认值，不派发；1屏幕滑动超过一定时间后派发；2实时派发；3实时派发，而且在缓动时也派发) probeType: &#123; type: Number, default:1 &#125;, // 是否主动派发点击事件 click: &#123; type: Boolean, default: true &#125;, // 在低版本的better-scroll中需要手动监听数据的变化并重新初始化组件，但高版本的已经不需要手动监听data了 data: &#123; type: Array, default: null &#125;, // 是否监听滚动 listenScroll:&#123; type:Boolean, default:false &#125;, // 是否派发滚动到底部事件 pullup:&#123; type:Boolean, default:false &#125;, // 是否派发beforeScroll事件 beforeScroll:&#123; type:Boolean, default:false &#125; &#125;, mounted() &#123; // DOM准备好时初始化组件 setTimeout(()=&gt; &#123; this._initScroll(); &#125;, 20) &#125;, methods: &#123; _initScroll()&#123; if (!this.$refs.wrapper) &#123; return; &#125; // 创建一个scroll this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType, click: this.click &#125;); // 派发滚动事件 if (this.listenScroll) &#123; let me = this; this.scroll.on('scroll', (pos) =&gt; &#123; me.$emit('scroll', pos); &#125;); &#125; // 派发滚动到底部事件 if(this.pullup)&#123; this.scroll.on('scrollEnd',()=&gt;&#123; if(this.scroll.y&lt;=(this.scroll.maxScrollY+50))&#123; this.$emit('scrollToEnd'); &#125; &#125;); &#125; // 派发beforeScroll事件 if(this.beforeScroll)&#123; this.scroll.on('beforeScrollStart',()=&gt;&#123; this.$emit('beforeScroll'); &#125;); &#125; &#125;, // 代理并暴露一些常用接口 enable()&#123; this.scroll &amp;&amp; this.enable(); &#125;, disable()&#123; this.scroll &amp;&amp; this.disable(); &#125;, refresh()&#123; console.log('refresh'); this.scroll &amp;&amp; this.scroll.refresh(); &#125;, scrollTo()&#123; this.scroll&amp;&amp;this.scroll.scrollTo.apply(this.scroll,arguments); &#125;, scrollToElement()&#123; this.scroll&amp;&amp;this.scroll.scrollToElement.apply(this.scroll,arguments); &#125; &#125; &#125;&lt;/script&gt; 注意:fastclick会拦截click事件，如果一个组件内部需要监听click事件时，可在对应DOM节点上添加needsclick样式类告诉fastclick不拦截此DOM的click事件 lazy-load 可以使用vue-lazyload实现1234567891011// main.jsimport VueLazyLoad from 'vue-lazyload';Vue.use(VueLazyLoad,&#123; loading:require('common/image/default.png')&#125;);// 使用时 &lt;div class=\"icon\"&gt; &lt;img v-lazy=\"item.imgurl\" alt=\"\" width=\"60\" height=\"60\"&gt;&lt;/div&gt; loading组件123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=\"loading\"&gt; &lt;img width=\"24\" height=\"24\" src=\"./loading.gif\"&gt; &lt;p class=\"desc\"&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt; export default &#123; props: &#123; title: &#123; type: String, default: '正在载入...' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang=\"stylus\" rel=\"stylesheet/stylus\"&gt; @import \"~common/stylus/variable\" .loading width: 100% text-align: center .desc line-height: 20px font-size: $font-size-small color: $color-text-l&lt;/style&gt; vuex1234567891011121314151617181920const store = new Vuex.Store(&#123; state: &#123; // 需要全局共享的数据 count: 1 &#125;, mutations: &#123; // 注册一个increment mutations increment (state,payload) &#123; // 变更状态 state.count += payload.amount &#125; &#125;, actions: &#123; incrementAsync (context,payload) &#123; setTimeout(() =&gt; &#123; context.commit('increment') &#125;, 1000) &#125; &#125;&#125;) states 需要全局共享的数据 getters 类似计算属性，可以用来访问基于state派生出的一些state，主要用来访问states mutations 很类似事件，只能通过提交mutations来改变state(方便开发工具跟踪)，主要用来设置states 提交mutaions是改变state的唯一方式 只能是同步任务，异步任务需要actions来完成 每一个mutation，store会传入state和可选的payload commit 用来提交mutaions 可以传递额外的参数payload给mutaions123store.commit('increment', &#123; amount: 10&#125;) actions 主要用来完成异步任务;需要请求后台的任务全部放在actions中 action不会直接变更状态，而是通过提交mutation来改变state， 每个action，store会传入一个context和可选的payload，context包含store实例的所有方法和属性。因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters dispatch 用来分发(提交)action 可以传递额外的参数(payload)给actions123store.dispatch('incrementAsync', &#123; amount: 10&#125;) 辅助函数 123456789101112131415161718192021222324252627282930313233343536// mapState、mapGetters、mapMutations、mapActions，都是返回一个对象，可以使用扩展预算符解析出来new Vue(&#123; el:'#app', store, computed: &#123; localComputed () &#123;&#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState([ count,// 将this.count 映射为 store.state.count ]), ...mapGetters([ 'doneTodosCount',// 将this.doneTodosCount 映射为 store.getters.doneTodosCount 'anotherGetter',// 将this.anotherGetter 映射为 store.getters.anotherGetter ]) &#125;, methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'SET_INCREMENT' // 将 `this.add()` 映射为 `this.$store.commit('SET_INCREMENT')` &#125;), ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125;); 实际项目目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313|---store/ actions.js // 保存所有异步任务 getters.js // 保存所有getters index.js // 导入state、getter...来实例化vuex mutations-type.js // 保存所有mutations类型 mutations.js // 实际的mutation函数 state.js // 所有需要共享的数据// state.js// 首先确定哪些数据需要vuex来管理，并给定默认值import &#123;playMode&#125; from 'common/js/config'import &#123;loadSearch,loadPlay,loadFavorite&#125; from 'common/js/cache'// state只放一些基础数据，派生的数据可放在getter中，如currentSong可通过palyList和currentIndex计算而来const state = &#123; singer: &#123;&#125;, playing: false, fullScreen: false, playlist: [], sequenceList: [], mode: playMode.sequence, currentIndex: -1, disc:&#123;&#125;, topList:&#123;&#125;, searchHistory:loadSearch(), playHistory:loadPlay(), favoriteList:loadFavorite(),&#125;;export default state;// 导出state对象// mutation-types.js// 确定针对state的修改export const SET_SINGER = 'SET_SINGER'export const SET_PLAYING_STATE = 'SET_PLAYING_STATE'export const SET_FULL_SCREEN = 'SET_FULL_SCREEN'export const SET_PLAYLIST = 'SET_PLAYLIST'export const SET_SEQUENCE_LIST = 'SET_SEQUENCE_LIST'export const SET_PLAY_MODE = 'SET_PLAY_MODE'export const SET_CURRENT_INDEX = 'SET_CURRENT_INDEX'export const SET_DISC = 'SET_DISC'export const SET_TOP_LIST = 'SET_TOP_LIST'export const SET_SEARCH_HISTORY = 'SET_SEARCH_HISTORY'export const SET_PLAY_HISTORY = 'SET_PLAY_HISTORY'export const SET_FAVORITE_LIST = 'SET_FAVORITE_LIST'// mutations.js// 根据mutaion-types编写具体的mutation来设置stateimport * as types from './mutation-types'const mutations = &#123; [types.SET_SINGER](state, singer) &#123; state.singer = singer &#125;, [types.SET_PLAYING_STATE](state, flag) &#123; state.playing = flag &#125;, [types.SET_FULL_SCREEN](state, flag) &#123; state.fullScreen = flag &#125;, [types.SET_PLAYLIST](state, list) &#123; state.playlist = list &#125;, [types.SET_SEQUENCE_LIST](state, list) &#123; state.sequenceList = list &#125;, [types.SET_PLAY_MODE](state, mode) &#123; state.mode = mode &#125;, [types.SET_CURRENT_INDEX](state, index) &#123; state.currentIndex = index &#125;, [types.SET_DISC](state, disc) &#123; state.disc = disc &#125;, [types.SET_TOP_LIST](state, topList) &#123; state.topList = topList &#125;, [types.SET_SEARCH_HISTORY](state, history) &#123; state.searchHistory = history &#125;, [types.SET_PLAY_HISTORY](state, history) &#123; state.playHistory = history &#125;, [types.SET_FAVORITE_LIST](state, list) &#123; state.favoriteList = list &#125;,&#125;export default mutations; // 导出mutations对象// getters.js// 编写getter来读取stateexport const singer = state =&gt; state.singerexport const playing = state=&gt;state.playingexport const fullScreen = state=&gt;state.fullScreenexport const playlist = state=&gt;state.playlistexport const sequenceList = state=&gt;state.sequenceListexport const mode = state=&gt;state.modeexport const currentIndex = state=&gt;state.currentIndex// 通过playlist、currentIndex计算而来export const currentSong = (state)=&gt; &#123; return state.playlist[state.currentIndex] || &#123;&#125;;&#125;export const disc = state=&gt;state.discexport const topList = state=&gt;state.topListexport const searchHistory = state=&gt;state.searchHistoryexport const playHistory = state=&gt;state.playHistoryexport const favoriteList = state=&gt;state.favoriteList// actions.js// 异步操作import * as types from './mutation-types'import &#123; playMode &#125; from 'common/js/config'import &#123; shuffle &#125; from 'common/js/util'import &#123; saveSearch, deleteSearch, clearSearch, savePlay, saveFavorite, deleteFavorite &#125; from 'common/js/cache'function findIndex(list, song) &#123; return list.findIndex((item) =&gt; &#123; return item.id === song.id; &#125;)&#125;export const selectPlay = function(&#123; commit, state &#125;, &#123; list, index &#125;) &#123; commit(types.SET_SEQUENCE_LIST, list); if (state.mode === playMode.random) &#123; let randomList = shuffle(list); commit(types.SET_PLAYLIST, randomList); index = findIndex(randomList, list[index]); &#125; else &#123; commit(types.SET_PLAYLIST, list); &#125; commit(types.SET_CURRENT_INDEX, index); commit(types.SET_FULL_SCREEN, true); commit(types.SET_PLAYING_STATE, true);&#125;;export const randomPlay = function(&#123; commit &#125;, &#123; list &#125;) &#123; commit(types.SET_PLAY_MODE, playMode.random); commit(types.SET_SEQUENCE_LIST, list); let randomList = shuffle(list); commit(types.SET_PLAYLIST, randomList); commit(types.SET_CURRENT_INDEX, 0); commit(types.SET_FULL_SCREEN, true); commit(types.SET_PLAYING_STATE, true);&#125;;export const insertSong = function(&#123; commit, state &#125;, song) &#123; let playlist = state.playlist.slice(); let sequenceList = state.sequenceList.slice(); let currentIndex = state.currentIndex; // 记录当前歌曲 let currentSong = playlist[currentIndex]; // 修改playlist // 查询当前列表中是否有待插入的歌曲并返回其索引 let fpIndex = findIndex(playlist, song); // 因为是插入歌曲，所以索引要+1 currentIndex++; // 插入这首歌当当前索引位置 playlist.splice(currentIndex, 0, song); // 如果已经包含这首歌曲 if (fpIndex &gt; -1) &#123; // 如果当前插入的索引大于列表中的序号 if (currentIndex &gt; fpIndex) &#123; playlist.splice(fpIndex, 1); currentIndex--; &#125; else &#123; playlist.splice(fpIndex + 1, 1); &#125; &#125; // 修改sequenceList let currentSIndex = findIndex(sequenceList, currentSong) + 1; let fsIndex = findIndex(sequenceList, song); sequenceList.splice(currentSIndex, 0, song); if (fsIndex &gt; -1) &#123; if (currentSIndex &gt; fsIndex) &#123; sequenceList.splice(fsIndex, 1); &#125; else &#123; sequenceList.splice(fsIndex + 1, 1); &#125; &#125; commit(types.SET_PLAYLIST, playlist); commit(types.SET_SEQUENCE_LIST, sequenceList); commit(types.SET_CURRENT_INDEX, currentIndex); commit(types.SET_FULL_SCREEN, true); commit(types.SET_PLAYING_STATE, true);&#125;;export const saveSearchHistory = function(&#123; commit &#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, saveSearch(query));&#125;;export const deleteSearchHistory = function(&#123; commit &#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, deleteSearch(query));&#125;;export const clearSearchHistory = function(&#123; commit &#125;) &#123; commit(types.SET_SEARCH_HISTORY, clearSearch());&#125;;export const deleteSong = function(&#123; commit, state &#125;, song) &#123; let playlist = state.playlist.slice() let sequenceList = state.sequenceList.slice() let currentIndex = state.currentIndex let pIndex = findIndex(playlist, song) playlist.splice(pIndex, 1) let sIndex = findIndex(sequenceList, song) sequenceList.splice(sIndex, 1) if (currentIndex &gt; pIndex || currentIndex === playlist.length) &#123; currentIndex-- &#125; commit(types.SET_PLAYLIST, playlist) commit(types.SET_SEQUENCE_LIST, sequenceList) commit(types.SET_CURRENT_INDEX, currentIndex) if (!playlist.length) &#123; commit(types.SET_PLAYING_STATE, false) &#125; else &#123; commit(types.SET_PLAYING_STATE, true) &#125;&#125;export const deleteSongList = function(&#123; commit &#125;) &#123; commit(types.SET_CURRENT_INDEX, -1) commit(types.SET_PLAYLIST, []) commit(types.SET_SEQUENCE_LIST, []) commit(types.SET_PLAYING_STATE, false)&#125;export const savePlayHistory = function(&#123; commit &#125;, song) &#123; commit(types.SET_PLAY_HISTORY, savePlay(song))&#125;export const saveFavoriteList = function(&#123; commit &#125;, song) &#123; commit(types.SET_FAVORITE_LIST, saveFavorite(song))&#125;export const deleteFavoriteList = function(&#123; commit &#125;, song) &#123; commit(types.SET_FAVORITE_LIST, deleteFavorite(song))&#125;// index.js// 入口文件，实例化vueximport Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'import createLogger from 'vuex/dist/logger';// 调试工具，可以打印出logVue.use(Vuex);// vuex是个插件，需要useconst debug = process.env.NODE_ENV !== 'production';// 导出一个store实例，供main.js使用export default new Vuex.Store(&#123; actions, getters, state, mutations, strict: debug,// strict模式会针对不通过commit提交mutation报错 plugins: debug ? [createLogger()] : [],// 使用打印log插件&#125;)// main.js// 导入vuex的stroe实例，并注入到vue根组件中import store from './store'...new Vue(&#123; el: '#app', router, store,// 导入vuex的stroe实例 render: h =&gt; h(App)&#125;); js prefix12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// common/js/dom.js// 能力检测，判断是哪种前缀let elementStyle = document.createElement('div').style;// 利用IIFE得到支持的前缀let vendor = (()=&gt; &#123; // 利用transform做能力检测，来判断支持哪种前缀 let transformNames = &#123; webkit: 'webkitTransform', Moz: 'MozTransform', O: 'OTransform', ms: 'msTransform', standard: 'transform' &#125;; for (let key in transformNames) &#123; // 支持某种前缀则直接返回 if (elementStyle[transformNames[key]] !== undefined) &#123; return key; &#125; &#125; // 如果没有匹配，则返回false return false;&#125;)();// 添加前缀export function prefixStyle(style) &#123; if (vendor === false) &#123; return false; &#125; // 支持标准，则直接返回 if (vendor === 'standard') &#123; return style; &#125; // 否则返回prefix后的字符串 return vendor + style.charAt(0).toUpperCase() + style.substr(1);&#125;// 实际调用// musicList.js...import &#123;prefixStyle&#125; from 'common/js/dom';...const transform=prefixStyle('transform');const backdrop=prefixStyle('backdrop-filter');...watch:&#123; scrollY(newY)&#123; ... this.$refs.layer.style[transform]=`translate3d(0,$&#123;translateY&#125;px,0)`; ... this.$refs.filter.style[backdrop]=`blur($&#123;blur&#125;px)`; ... &#125;&#125; 用js创建animation动画 使用create-keyframe-animation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!-- 监听一些钩子 --&gt;&lt;transition name=\"normal\" @enter=\"enter\" @after-enter=\"afterEnter\" @leave=\"leave\" @after-leave=\"afterLeave\"&gt;... &lt;/transition&gt;// 样式&amp;.normal-enter-active, &amp;.normal-leave-active transition: all 0.4s .top, .bottom transition: all 0.4s cubic-bezier(0.86, 0.18, 0.82, 1.32)&amp;.normal-enter, &amp;.normal-leave-to opacity: 0 .top transform: translate3d(0, -100px, 0) .bottom transform: translate3d(0, 100px, 0)// js...import animations from 'create-keyframe-animation'...methods:&#123; enter(el,done)&#123; const &#123;x,y,scale&#125;=this._getPosAndScale(); let animation=&#123; 0:&#123; transform:`translate3d($&#123;x&#125;px,$&#123;y&#125;px,0) scale($&#123;scale&#125;)`, &#125;, 60:&#123; transform:`translate3d(0,0,0) scale(1.1)`, &#125;, 100:&#123; transform:`translate3d(0,0,0) scale(1)`, &#125; &#125;; // 注册一个move动画 animations.registerAnimation(&#123; name:'move', animation, presets:&#123; duration:400, easing:'linear' &#125; &#125;); // 在cdWrapper上调用move动画，结束时一定要调用done animations.runAnimation(this.$refs.cdWrapper,'move',done); &#125;, afterEnter()&#123; // 运动结束注销move animations.unregisterAnimation('move'); this.$refs.cdWrapper.style.animation = ''; &#125;, leave(el,done)&#123; // leave动画用普通的过渡动画实现即可 this.$refs.cdWrapper.style.transition='all .3s'; const &#123;x,y,scale&#125;=this._getPosAndScale(); this.$refs.cdWrapper.style[transform]=`translate3d($&#123;x&#125;px,$&#123;y&#125;px,0)`; // 结束时，调用done this.$refs.cdWrapper.addEventListener('transitionend',done); &#125;, afterLeave()&#123; this.$refs.cdWrapper.style.transition = '' this.$refs.cdWrapper.style[transform] = '' &#125;&#125; 利用svg实现圆形进度 利用dasharray配合stroke-dashoffset来实现进度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div class=\"progress-circle\"&gt; &lt;svg :width=\"radius\" :height=\"radius\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle class=\"progress-background\" r=\"50\" cx=\"50\" cy=\"50\" fill=\"transparent\"/&gt; &lt;circle class=\"progress-bar\" r=\"50\" cx=\"50\" cy=\"50\" fill=\"transparent\" :stroke-dasharray=\"dashArray\" :stroke-dashoffset=\"dashOffset\"/&gt; &lt;/svg&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/ecmascript-6\"&gt; export default&#123; props:&#123; radius:&#123; type:Number, default:100 &#125;, percent:&#123; type:Number, default:0 &#125; &#125;, data()&#123; return &#123; dashArray:Math.PI * 100 &#125; &#125;, computed:&#123; dashOffset()&#123; return (1-this.percent)*this.dashArray &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped lang=\"stylus\" rel=\"stylesheet/stylus\"&gt; @import \"~common/stylus/variable\" .progress-circle position: relative circle stroke-width: 8px transform-origin: center &amp;.progress-background transform: scale(0.9) stroke: $color-theme-d &amp;.progress-bar transform: scale(0.9) rotate(-90deg) stroke: $color-theme&lt;/style&gt; 利用mixin复用组件选项 当组件的选项类似是，可以将其抽取成一个公用mixin，然后在组件mixins字段中引入即可123456789101112131415161718192021222324252627282930313233343536373839// mixins.jsimport &#123;mapGetters, mapMutations, mapActions&#125; from 'vuex'...export const playlistMixin = &#123; // 下面定义的选项将在不同组件中复用 computed: &#123; ...mapGetters([ 'playlist' ]) &#125;, mounted() &#123; this.handlePlaylist(this.playlist) &#125;, activated() &#123; this.handlePlaylist(this.playlist) &#125;, watch: &#123; playlist(newVal) &#123; this.handlePlaylist(newVal) &#125; &#125;, methods: &#123; handlePlaylist() &#123; throw new Error('component must implement handlePlaylist method') &#125; &#125;&#125;;// playList.vue... import &#123;playerMixin&#125; from 'common/js/mixin'...export default &#123; mixins:[playerMixin], ...&#125; 编译打包 直接使用npm run build 打包优化 路由懒加载 vue官方推荐使用webpack的ensure(这是webpack1.x版本的，2.x推荐使用import)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import Vue from 'vue'import Router from 'vue-router'// import Recommend from 'components/recommend/recommend'// import Singer from 'components/singer/singer'// import Rank from 'components/rank/rank'// import Search from 'components/search/search'// import SingerDetail from 'components/singer-detail/singer-detail'// import Disc from 'components/disc/disc'// import TopList from 'components/top-list/top-list'// import UserCenter from 'components/user-center/user-center'Vue.use(Router)// 使用import动态加载组件，并在成功后，resolve组件传递给路由const Recommend = (resolve) =&gt; &#123; import('components/recommend/recommend').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Singer = (resolve) =&gt; &#123; import('components/singer/singer').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Rank = (resolve) =&gt; &#123; import('components/rank/rank').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Search = (resolve) =&gt; &#123; import('components/search/search').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const SingerDetail = (resolve) =&gt; &#123; import('components/singer-detail/singer-detail').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Disc = (resolve) =&gt; &#123; import('components/disc/disc').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const TopList = (resolve) =&gt; &#123; import('components/top-list/top-list').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const UserCenter = (resolve) =&gt; &#123; import('components/user-center/user-center').then((module) =&gt; &#123; resolve(module) &#125;)&#125;export default new Router(&#123; routes: [&#123; path: '/', redirect: '/recommend' &#125;, &#123; path: '/recommend', name: 'Recommend', component: Recommend, children: [&#123; path: ':id', name: 'Disc', component: Disc &#125;] &#125;, &#123; path: '/singer', name: 'Singer', component: Singer, children: [&#123; path: ':id', name: 'SingerDetail', component: SingerDetail &#125;] &#125;, &#123; path: '/rank', name: 'Rank', component: Rank, children:[&#123; path:':id', name: 'TopList', component:TopList &#125;] &#125;, &#123; path: '/search', name: 'Search', component: Search, children: [&#123; path: ':id', name: 'SingerDetail', component: SingerDetail &#125;] &#125;,&#123; path:'/user', name:'User', component:UserCenter &#125; ]&#125;) 移动端调试工具vConsole 在代码入口文件main.js中导入并实例化 vconsole是不需要调用的，所以使用特定注释规避掉eslint检查 上线时，记得清除掉vConsole123456789101112131415161718// main.js...import VConsole from 'vconsole'...// vconsole是不需要调用的，所以使用特定注释规避掉eslint检查/* eslint-disable no-unused-vars */var vConsole=new VConsole();console.log('test');.../* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App)&#125;) 抓包工具 win上使用fiddler工具","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"websocket_chat","date":"2018-01-18T06:53:58.000Z","path":"2018/01/18/websocket-chat/","text":"最近在看web端即时通信方面东西，用nodejs结合websocket(socket.io)做了一个简单的web聊天室。特在此做个记录完整代码可以查看(https://github.com/BryanAdamss/SourceSave/tree/master/WebSocket/ws-socketiodemo) 使用NodeJs、Socket.io搭建一个web聊天室前置知识Web端实现即时通信主要有四种方式：短轮询(polling)、comet、Websocket、SSE 短轮询 前台设置个定时器不断发送请求去请求后台数据 缺点:会有大量无效请求、浪费服务器资源、有延迟 Comet 其实是一种hack技术，主要是一种基于http长连接的”服务器推”的技术 主要有两种实现方式 ajax长轮询(long-polling) 客户端发出ajax请求，服务端接收到请求后，会阻塞请求直到有数据或者超时才返回，客户端在在处理信息后再次发出请求，重新建立连接。 优点:相比短轮询减少了无效请求、实时性提高 缺点:保持连接也会消耗服务器资源 基于iframe及htmlfile的流方式 iframe的src属性会保持对指定服务器的长连接请求，服务器端则可以不停地返回数据 缺点:ie、ff下会显示页面未加载完成 利用htmlfile的ActiveX解决了IE上的加载显示问题 WebSocket Websocket是一个全新的、独立的协议，基于TCP协议，与http协议兼容。 Websocket在建立连接之前有一个Handshake过程，在关闭连接前也有一个Handshake过程，建立连接之后，双方即可双向通信。 优点:全双工相互通信 SSE Server-Sent Event 服务器推送事件，允许服务端向客户端推送新数据。 传统情况下服务端可以通过flash(Flash XMLSocket)或者Java Applet 套接口来实现推送 一般说websocket和sse都能做彼此能做的事情，不过sse更多的是专注服务端向客户端推，客户端想发送消息给服务端必须通过ajax来发送，而websocket连接上后，双方就可以直接通过websocket通信了。 需求 允许同名登录 查看在线人数及列表 区分自己发言和他人发言 加入、退出聊天室有提示 尽量兼容低版本浏览器 websocket API 通过分析对比几种及时通信的实现方式，客户端选择使用websocket来实现较为简单。 常用API，具体可参考(https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket); 1234567891011121314151617var socket=new Socket('http://xxxx.com:port');socket.onopen=function()&#123; // 连接上服务器时触发(此时表示客户端可以接受和发送数据)&#125;;socket.onerror=function()&#123; // 当错误发生时用于监听error事件的事件监听器。会接受一个名为“error”的event对象。&#125;;socket.onmessage=function()&#123; // 当有消息到达的时候该事件会触发&#125;;socket.close();// 主动关闭连接socket.send();// 发送信息给服务端，可接受DOMString data、ArrayBuffer data、Blob data 分析 原生的websocket只能支持IE10+、移动端只能支持到安卓4.4，所以最后采用socket.io来实现。 socket.io是运行在node环境上的，可以兼顾到前后台，它可以做到优雅降级，当不支持websocket的浏览器会自动使用轮询的方式来实现即时通信。具体可参考(https://socket.io/docs/); 代码实现 完整代码可以查看(https://github.com/BryanAdamss/SourceSave/tree/master/WebSocket/ws-socketiodemo) 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var express = require('express');var app = express();var path = require('path');var server = require('http').createServer(app);var io = require('socket.io')(server);var port = process.env.PORT || 3000;server.listen(port, function() &#123; console.log('服务启动在:%d', port);&#125;);app.use(express.static(path.join(__dirname, './public')));var onlineUsers = &#123;&#125;; //在线用户var onlineCount = 0; //当前在线人数// 监听用户连接io.on('connection', function(socket) &#123; console.log('有用户连接!'); // 连接后监听相应事件 // 监听客户端的登录事件 socket.on('login', function(obj) &#123; // 保存连接的id，退出时会用到 socket.id = obj.userId; // 将新的连接加入到在线列表中 if (!onlineUsers.hasOwnProperty(obj.userId)) &#123; onlineUsers[obj.userId] = obj.userName; onlineCount++; &#125; // 向所有客户端广播有新用户加入，并将新用户及最新的在线人数和在线列表传过去 io.emit('newIn', &#123; onlineUsers: onlineUsers, onlineCount: onlineCount, user: obj &#125;); console.log(obj.userName + '加入了聊天室'); &#125;); // 监听客户端的发送事件，将其广播给所有用户 socket.on('message', function(obj) &#123; console.log('%s说了:%s', obj.name, obj.message); io.emit('message', obj); &#125;); // 监听客户端的离线事件 socket.on('disconnect', function() &#123; // 在线列表中删除对应的连接 if (onlineUsers.hasOwnProperty(socket.id)) &#123; var obj = &#123; userId: socket.id, userName: onlineUsers[socket.id] &#125;; delete onlineUsers[socket.id]; onlineCount--; // 向所有客户端广播有用户退出 io.emit('logout', &#123; onlineUsers: onlineUsers, onlineCount: onlineCount, user: obj &#125;); console.log(obj.userName + '退出了聊天室'); console.log('现在聊天室里有:', onlineUsers); &#125; &#125;);&#125;); 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155(function() &#123; function addEvent(ele, type, handler) &#123; if (ele.addEventListener) &#123; ele.addEventListener(type, handler, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent(\"on\" + type, handler); &#125; else &#123; ele[\"on\" + type] = handler; &#125; &#125; function trim(str) &#123; if (!str.trim) &#123; return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); &#125; return str.trim(); &#125; window.onload = function() &#123; main(); &#125;; function main() &#123; var loginInput = document.querySelector('#js_loginInput'), loginBox = document.querySelector('#js_loginBox'); loginInput.focus(); // 登录框默认聚焦 var URL = 'http://192.168.23.27:3000'; addEvent(loginInput, 'keydown', function(e) &#123; var e = e || window.e; if (e.keyCode === 13) &#123; var val = trim(loginInput.value); if (val !== '') &#123; // 隐藏登录框 loginInput.value = ''; loginBox.className = loginBox.className + ' is-hide'; // 创建一个ws连接 var link = new Link(URL, val); &#125; &#125; &#125;); &#125; function Link(url, name) &#123; this.url = url; this.userName = trim(name); this.init(); &#125; Link.prototype = &#123; constructor: Link, init: function() &#123; var self = this; this.socket = io.connect(this.url); this.userId = this.genUid(); this.submitInput = document.querySelector('#js_chatInput'); this.list = document.querySelector('#js_chatList'); this.hd = document.querySelector('#js_chatHd'); this.submitInput.focus(); this.socket.emit('login', &#123; userName: this.userName, userId: this.userId &#125;); // 告诉服务端，当前客户端登录了 this.socket.on('newIn', function(o) &#123; // 监听服务端派发的用户登录事件 var li = self.makeTips(o.user.userName); self.updateList(li); self.updateOnline(o.onlineUsers, o.onlineCount); &#125;); addEvent(this.submitInput, 'keydown', function(e) &#123; var e = e || window.e; var text = trim(self.submitInput.value); if (e.keyCode === 13) &#123; if (text !== '') &#123; self.submitInput.value = ''; self.socket.emit('message', &#123; message: text, name: self.userName, id: self.userId &#125;); // 告诉服务端，当前客户端发送了一个message &#125; &#125; &#125;); this.socket.on('message', function(o) &#123; // 监听服务端派发的message事件 var isMe = o.id === self.userId ? true : false; // 判断消息是否是当前客户端发送的 var li = self.makeMessage(o.name, o.message, isMe); self.updateList(li); &#125;); this.socket.on('logout', function(o) &#123; // 监听服务端派发的logout事件 var li = self.makeTips(o.user.userName, true); self.updateList(li); self.updateOnline(o.onlineUsers, o.onlineCount); &#125;); &#125;, genUid: function() &#123; return new Date().getTime() + \"\" + Math.floor(Math.random() * 899 + 100); // 生成唯一id，用于后面的判断 &#125;, makeTips: function(name, logout) &#123; if (typeof name === 'undefined') &#123; return; &#125; var li = document.createElement('li'); li.className = 'c-ChatList-item is-tips'; if (logout) &#123; li.innerHTML = '&lt;span class=\"c-ChatList-tip\"&gt;' + name + '退出了聊天室&lt;/span&gt;'; &#125; else &#123; li.innerHTML = '&lt;span class=\"c-ChatList-tip\"&gt;' + name + '加入了聊天室&lt;/span&gt;'; &#125; return li; &#125;, makeMessage: function(name, text, me) &#123; if (typeof name === 'undefined' || typeof text === 'undefined') &#123; return; &#125; var li = document.createElement('li'); if (me) &#123; li.className = 'c-ChatList-item fadeInRight is-me'; li.innerHTML = '&lt;div class=\"c-ChatList-cont\"&gt;&lt;div class=\"c-ChatList-text\"&gt;' + text + '&lt;/div&gt;&lt;div class=\"c-ChatList-name\"&gt;' + name + '&lt;/div&gt;&lt;/div&gt;'; &#125; else &#123; li.className = 'c-ChatList-item fadeInLeft'; li.innerHTML = '&lt;div class=\"c-ChatList-cont\"&gt;&lt;div class=\"c-ChatList-name\"&gt;' + name + '&lt;/div&gt;&lt;div class=\"c-ChatList-text\"&gt;' + text + '&lt;/div&gt;&lt;/div&gt;'; &#125; return li; &#125;, updateList: function(li) &#123; this.list.appendChild(li); li.scrollIntoView(); &#125;, updateOnline: function(users, count) &#123; var html = '在线人数：' + count + '人；在线列表：'; var arr = []; for (var key in users) &#123; if (users.hasOwnProperty(key)) &#123; arr.push(users[key]); &#125; &#125; html += arr.join('、'); this.hd.innerHTML = html; &#125; &#125;;&#125;)(); 相关链接 http://www.52im.net/thread-336-1-1.htmlhttps://segmentfault.com/a/1190000002496055https://socket.io","tags":[{"name":"聊天室","slug":"聊天室","permalink":"http://yoursite.com/tags/聊天室/"},{"name":"websocket","slug":"websocket","permalink":"http://yoursite.com/tags/websocket/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"im","slug":"im","permalink":"http://yoursite.com/tags/im/"}]},{"title":"webpack-multi-page","date":"2018-01-02T01:38:03.000Z","path":"2018/01/02/webpack-multi-page/","text":"最近在看webpack的配置，自己尝试写了个多页面的配置文件。在此做个记录，方便日后查找。详细代码可以查看(https://github.com/BryanAdamss/WebpackTemplate) Webpack多页面配置想实现的功能 开发环境、生产环境配置分离 开发环境 HMR 自动生成HTML文件 source map 生产环境 提取css、sass 提取公共模块 压缩代码 hash 缓存 与SPA的不同 单页面应用在入口处引入所有的js文件 多页面应用需要在每个页面中引入公共的js文件和自身的js文件(公共代码、多入口) 项目结构123456789101112131415161718|---config/| config.js│ webpack.config.base.js│ webpack.config.dev.js│ webpack.config.prod.js|---dist/|---node_modules/|---src/| css/| html/| img/| sass/| vendors/| a.js| b.js|---.babelrc|---package.json|---postcss.config.js 为了方便管理，将配置文件拆分为4个并全部放置在config文件夹下 dist文件夹主要放置打包后的文件 src主要是源文件和一些第三方组件 .babelrc为babel配置文件 postcss.config.js为postcss的配置文件 package.json123456789101112131415161718192021222324252627282930313233343536&#123; \"name\": \"WebpackTemplate\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"build\": \"webpack --progress --color --config ./config/webpack.config.prod.js\", \"dev\": \"webpack-dev-server --progress --color --open --config ./config/webpack.config.dev.js\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"auto-prefixer\": \"^0.4.2\", \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.2\", \"babel-preset-env\": \"^1.6.1\", \"clean-webpack-plugin\": \"^0.1.17\", \"css-loader\": \"^0.28.7\", \"extract-text-webpack-plugin\": \"^3.0.2\", \"file-loader\": \"^1.1.6\", \"html-webpack-plugin\": \"^2.30.1\", \"node-sass\": \"^4.7.2\", \"postcss-loader\": \"^2.0.9\", \"sass-loader\": \"^6.0.6\", \"style-loader\": \"^0.19.1\", \"uglifyjs-webpack-plugin\": \"^1.1.5\", \"url-loader\": \"^0.6.2\", \"webpack\": \"^3.10.0\", \"webpack-dev-server\": \"^2.9.7\", \"webpack-merge\": \"^4.1.1\" &#125;, \"dependencies\": &#123; \"babel-polyfill\": \"^6.26.0\" &#125;&#125; post-css-loader、auto-prefixer配合完成前缀修复工作 babel-core、babel-preset-env、babel-polyfill是babel编译es6所必须的文件；babel-loader是用来处理es6的；babel-polyfill是垫片文件 clean-webpack-plugin是清除文件夹的 css-loader、style-loader是加载样式的 extract-text-webpack-plugin用来提取css到一个单独文件的 file-loader可以用来加载图片字体等资源 url-loader作用类似file-loader，不同的是可以将低于某大小的文件直接转成dataUrl插入到页面中 html-webpack-plugin可根据模板自动生成html页面，并插入需要的js文件 node-sass、sass-loader配合完成编译sass(scss)的工作 uglifyjs-webpack-plugin用来压缩js文件 webpack-dev-server生产环境用的静态服务器 webpack-merge用来合并不同的配置文件 配置文件 config.js主要放置了一些全局配置文件，如各种路径… 12345678910111213141516171819202122232425// 全局配置，比如 HTML 文件的路径、publicPath 等const path = require('path');// __dirname是当前文件所在目录，process.cwd()是node当前工作的目录，即package.json所在目录const PROJECT_PATH = process.cwd(); // 项目目录const config = &#123; PROJECT_PATH, // 项目目录 CONFIG_PATH: path.join(__dirname), // 配置文件目录 SRC_PATH: path.join(PROJECT_PATH, './src/'), // 源文件目录 BUILD_PATH: path.join(PROJECT_PATH, './dist/'), // 打包目录 PUBLIC_PATH: '/assets/', // 静态文件存放目录 HTML_PATH: path.join(PROJECT_PATH, './src/html/'), VENDORS_PATH: path.join(PROJECT_PATH, './src/vendors/'), // vendors目录 NODE_MODULES_PATH: path.join(PROJECT_PATH, './node_modules/'), // node_modules目录 ignorePages: ['test'], // 没有入口js文件的html&#125;;console.log('\\n/-----相关路径-----/\\n');console.log(config);console.log('\\n/-----相关路径-----/\\n');module.exports = config; webpack.config.base.js是基础配置文件，包含了一些通用配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 基础配置文件，包含了不同环境通用配置const path = require('path'); // nodejs路径模块，用于读取路径const fs = require('fs'); // nodejs文件模块，用于读取文件const config = require('./config.js'); // 获取配置const HTMLWebpackPlugin = require('html-webpack-plugin'); // 用于生成html// 获取html文件名，用于生成入口const getFileNameList = (path) =&gt; &#123; let fileList = []; let dirList = fs.readdirSync(path); dirList.forEach(item =&gt; &#123; if (item.indexOf('html') &gt; -1) &#123; fileList.push(item.split('.')[0]); &#125; &#125;); return fileList;&#125;;let htmlDirs = getFileNameList(config.HTML_PATH);let HTMLPlugins = []; // 保存HTMLWebpackPlugin实例let Entries = &#123;&#125;; // 保存入口列表// 生成HTMLWebpackPlugin实例和入口列表htmlDirs.forEach((page) =&gt; &#123; let htmlConfig = &#123; filename: `$&#123;page&#125;.html`, template: path.join(config.HTML_PATH, `./$&#123;page&#125;.html`) // 模板文件 &#125;; let found = config.ignorePages.findIndex((val) =&gt; &#123; return val === page; &#125;); if (found === -1) &#123; // 有入口js文件的html，添加本页的入口js和公用js，并将入口js写入Entries中 htmlConfig.chunks = [page, 'commons']; Entries[page] = `./src/$&#123;page&#125;.js`; &#125; else &#123; // 没有入口js文件，chunk为空 htmlConfig.chunks = []; &#125; const htmlPlugin = new HTMLWebpackPlugin(htmlConfig); HTMLPlugins.push(htmlPlugin);&#125;);module.exports = &#123; context: config.PROJECT_PATH, // 入口、插件路径会基于context查找 entry: Entries, output: &#123; path: config.BUILD_PATH, // 打包路径，本地物理路径 &#125;, module: &#123; rules: [&#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, include: [config.SRC_PATH], exclude: [config.VENDORS_PATH], // 忽略第三方的任何代码 use: [&#123; // 导入字体文件，并最打包到output.path+ options.name对应的路径中 loader: 'file-loader', options: &#123; name: 'fonts/[name].[ext]' &#125; &#125;] &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, include: [config.SRC_PATH], exclude: [config.VENDORS_PATH], use: [&#123; // 图片文件小于8k时编译成dataUrl直接嵌入页面，超过8k回退使用file-loader loader: 'url-loader', options: &#123; limit: 8192, // 8k name: 'img/[name].[ext]', // 回退使用file-loader时的名称 fallback: 'file-loader', // 当超过8192byte时，会回退使用file-loader &#125; &#125;] &#125;, &#123; test: /\\.js$/, include: [config.SRC_PATH], exclude: [config.VENDORS_PATH, config.NODE_MODULES_PATH], use: ['babel-loader'] &#125;] &#125;, plugins: [ ...HTMLPlugins, // 扩展运算符生成所有HTMLPlugins ]&#125;; 自动生成html文件是通过getFileNameList函数来实现的，主要利用node的fs模块，读取src/html/下的所有直接子文件，并通过后缀结合config.js中ignore进行筛选过滤，返回需要生成的html的名字数组，遍历此数组生成相关入口文件路径和HTMLWebpackPlugin实例 webpack.config.dev.js开发环境配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 开发环境配置文件const webpackBase = require('./webpack.config.base.js'); // 引入基础配置const config = require('./config.js'); // 引入配置const webpack = require('webpack'); // 用于引用官方插件const webpackMerge = require('webpack-merge'); // 用于合并配置文件const webpackDev = &#123; // 开发配置文件 output: &#123; filename: 'js/[name].[hash:8].bundle.js', // 开发环境用hash &#125;, devtool: 'cheap-module-eval-source-map', // 开发环境设置sourceMap，生产环境不使用 devServer: &#123; // 启动devServer，不会在本地生成文件，所有文件会编译在内存中(读取速度快) contentBase: './dist/', // 这个目录下的内容可被访问 overlay: true, // 错误信息直接显示在浏览器窗口中 inline: true, // 实时重载的脚本被插入到你的包(bundle)中，并且构建消息将会出现在浏览器控制台 hot: true, // 配合webpack.NamedModulesPlugin、webpack.HotModuleReplacementPlugin完成MHR // publicPath: config.PUBLIC_PATH, // 静态资源存放位置，根目录的assets文件夹，确保publicPath总是以斜杠(/)开头和结尾。可以设置为CDN地址。这个选项类似url-prefix host: \"0.0.0.0\", // 设置为0.0.0.0并配合useLocalIp可以局域网访问 useLocalIp: true, // 使用本机IP打开devServer，而不是localhost // proxy: &#123;// 可以通过proxy代理其他服务器的api // \"/api\": \"http://localhost:3000\" // &#125; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, // 开发环境不提取css include: [config.SRC_PATH], exclude: [config.VENDORS_PATH], use: ['style-loader', 'css-loader', 'postcss-loader'] &#125;, &#123; test: /\\.scss$/, // 开发环境不提取css include: [config.SRC_PATH], exclude: [config.VENDORS_PATH], use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'] &#125;] &#125;, plugins: [ new webpack.NamedModulesPlugin(), // 开发环境用于标识模块id new webpack.HotModuleReplacementPlugin(), // 热替换插件 ]&#125;;module.exports = webpackMerge(webpackBase, webpackDev); webpack.config.prod.js生产环境配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 生产环境配置文件const webpackBase = require('./webpack.config.base.js'); // 引入基础配置const config = require('./config.js'); // 引入配置const webpack = require('webpack'); // 用于引用官方插件const webpackMerge = require('webpack-merge'); // 用于合并配置文件const CleanWebpackPlugin = require('clean-webpack-plugin'); // 用于清除文件夹const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); // 用于压缩文件const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin'); // 提取css，提取多个来源时，需要实例化多个，并用extract方法const cssExtracter = new ExtractTextWebpackPlugin(&#123; filename: './css/[name]-css.[contenthash:8].css', // 直接导入的css文件，提取时添加-css标识 allChunks: true, // 从所有的chunk中提取，当有CommonsChunkPlugin时，必须为true&#125;);const sassExtracter = new ExtractTextWebpackPlugin(&#123; filename: './css/[name]-sass.[contenthash:8].css', // 直接导入的sass文件，提取时添加-sass标识 allChunks: true,&#125;);const webpackProd = &#123; // 生产配置文件 output: &#123; filename: 'js/[name].[chunkhash:8].bundle.js', // 生产环境用chunkhash &#125;, module: &#123; rules: [&#123; test: /\\.css$/, // 生产环境提取css include: [config.SRC_PATH], exclude: [config.VENDORS_PATH], use: cssExtracter.extract(&#123; fallback: 'style-loader', use: [&#123; loader: 'css-loader', options: &#123; minimize: true //css压缩 &#125; &#125;, 'postcss-loader'] &#125;) &#125;, &#123; test: /\\.scss$/, // 生产环境提取css include: [config.SRC_PATH], exclude: [config.VENDORS_PATH], use: sassExtracter.extract(&#123; fallback: 'style-loader', use: [&#123; loader: 'css-loader', options: &#123; minimize: true //css压缩 &#125; &#125;, 'postcss-loader', 'sass-loader'] &#125;) &#125; ] &#125;, plugins: [ cssExtracter, sassExtracter, new webpack.DefinePlugin(&#123; // 指定为生产环境，进而让一些library可以做一些优化 'process.env.NODE_ENV': JSON.stringify('production') &#125;), new webpack.HashedModuleIdsPlugin(), // 生产环境用于标识模块id new CleanWebpackPlugin(['./dist/'], &#123; root: config.PROJECT_PATH, // 默认为__dirname，所以需要调整 &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; // 抽取公共chunk name: 'commons', // 指定公共 bundle 的名称。HTMLWebpackPlugin才能识别 filename: 'js/commons.[chunkhash:8].bundle.js' &#125;), new UglifyJSPlugin(), ]&#125;;module.exports = webpackMerge(webpackBase, webpackProd); .babelrc为babel配置文件 1234567891011121314&#123; \"presets\": [ [\"env\", &#123; \"targets\": &#123; \"browsers\": [\"android&gt;=4.0\", \"ios&gt;=7.0\", \"ie&gt;=8\", \"&gt; 1% in CN\"] &#125;, \"useBuiltIns\": \"usage\", \"modules\": false, \"loose\": true &#125;] ]&#125; 使用babel-preset-env预设，它包含了babel-preset-es2015, babel-preset-es2016,babel-preset-es2017，并可设置targets让其自动为目标浏览器进行polyfill和代码转换工作； &quot;useBuiltIns&quot;: &quot;usage&quot;使用自带的polyfill即babel-polyfill，并只在使用了某个目标浏览器不支持的es6语法时自动import相关垫片；https://github.com/babel/babel/tree/master/packages/babel-preset-env 1234567891011121314151617//入口文件a.jsvar a = new Promise();b.jsvar b = new Map();//Out (如果目标浏览器不支持)import \"core-js/modules/es6.promise\";var a = new Promise();import \"core-js/modules/es6.map\";var b = new Map();//Out (如果目标浏览器支持)var a = new Promise();var b = new Map(); &quot;modules&quot;: false不将ES6的模块转为其他模块类型(AMD、UMD…) &quot;loose&quot;:true使用更简单 ES5 代码来兼容老浏览器 postcss.config.jspostcss配置文件1234567891011module.exports = &#123; plugins: &#123; 'autoprefixer': &#123; browsers: [\"android&gt;=4.0\", \"ios&gt;=7.0\", \"ie&gt;=8\", \"&gt; 1% in CN\"], //是否美化属性值 默认：true cascade: true, //是否去掉不必要的前缀 默认：true remove: true &#125; &#125;&#125;; 总结 webpack已经成为前端必须会的东西，网上也有很多现成的配置文件可以直接使用，但是想配一个适合自己的还是需要花费很多时间的，因为官方文档暴露出的细节太少，必须查阅大量资料、阅读相关源码再加上大量的实践才能基本了解。 参考 https://www.jianshu.com/p/2cc4a1078953https://zhuanlan.zhihu.com/p/29161762https://segmentfault.com/a/1190000006843916https://doc.webpack-china.org/api/","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack","date":"2017-12-21T06:59:17.000Z","path":"2017/12/21/webpack/","text":"webpack官方指南学习笔记 webpack官方指南学习笔记起步 packagejson.js必须是纯正的json文件，用双引号，结尾不能有逗号 npm init -y会默认全选yes来初始化package.json npm中可以直接使用模块名来引用本地安装的包，而不需要写出完整路径 ./node_modules/.bin/webpack src/index.js dist/bundle.js可替换为webpack src/index.js dist/bundle.js webpack命令默认会查找webpack.config.js配置文件。可以通过--config来使用其他配置文件打包 可以使用npm run 命令名的形式来运用package.json中scripts声明的自定义命令 1234567 ... \"scripts\": &#123; \"build\": \"webpack\" &#125;,// 使用npm run build 管理资源 加载css 在webpack所有资源都可以看成模块，css也不例外 通过css-loader可以在js文件中使用import &#39;./css/style.css&#39;的形式导入样式 通过style-loader可以将样式文件提取出来生成一个&lt;style&gt;标签插入到&lt;head&gt;中，如果是单页面应用，则可以减少请求(当前也可以分离样式到单独的文件中)12345678910111213141516// nodejs获取路径const path = require('path');module.exports = &#123; entry: './src/index.js', // 入口 output: &#123; // 出口 filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), //__dirname是nodejs中的全局变量用于获取当前文件的完整绝对路径 &#125;, module: &#123; rules: [&#123; // 针对收集到的.css结尾的依赖，先使用css-loader，再使用style-loader test: /\\.css$/, use: ['style-loader', 'css-loader'],// 同一个依赖依次使用多个loader时要按照从右往左的顺序 &#125;] &#125;&#125;; 加载图片 通过file-loader可以在js文件中使用import Img from &#39;./img/icon.jpg&#39;形式来使用图片，并Img变量包含该图像在处理后的最终url；当使用了css-loader后，css中的url(&quot;./img/icon/jpg&quot;)路径也会被替换；当使用html-loader后，html中的&lt;img src=&quot;./my-image.png&quot; /&gt;路径也会被替换123456789101112131415161718192021222324252627 import Cat from './img/cat.jpg'; function component() &#123; ... var image = new Image(); image.src = Cat; image.onload = function() &#123; element.appendChild(image); &#125;; return element; &#125; ``` - 加载字体 - 加载字体的策略和加载图片的策略基本一致，可以通过`file-loader`实现- 加载CSV、XML - 可以通过对应的loader来处理## 管理输出- 生成模板 - 使用`html-webpack-plugin`插件，可以动态生成html文件，并自动添加上生成的包 ```javascript plugins: [ new HtmlWebpackPlugin(&#123; title: '我是标题' &#125;) ], 清理文件夹 使用clean-webpack-plugin插件，来清理指定文件夹123456plugins: [ new CleanWebpackPlugin(['dist']),// 指定要清理的文件夹 new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;)], 使用webpack自带插件时，需要先require(&#39;webpack&#39;) 开发 sourceMap 可以将编译后的代码映射回原始源代码 通过配置webpack的devtool devtool: &#39;inline-source-map&#39;, 自动编译 webpack watch模式 使用webpack --watch观测文件的变动，有变动，则自动编译，可以将webpack --watch写入到package.json的scripts中；缺点是无法自动刷新浏览器，重新编译后需要手动刷新浏览器12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"watch\": \"webpack --watch\", \"build\": \"webpack\" &#125;, 使用webpack-dev-server 包含一个简单web服务器，并能实现自动刷新 需配置devServer 123devServer: &#123; contentBase: './dist' // 将dist文件夹下的文件作为可访问文件&#125;, 使用webpack-dev-server --open启动，可将其写到package.json的scripts中 使用webpack-dev-middleware 它是一个中间件容器，可以将webpack处理后的文件发布到另外一个服务器中，webpack-dev-server中也使用了它，可以配合express来使用 模块热替换MHR 可以在不刷新浏览器的情况下替换模块，如css、图片、js。重要的是在替换js模块时还能保留js模块运行时的相关环境 使用 webpack-dev-server中可以通过配置devServer的hot为true，并使用webpack自带的HotModuleReplacementPlugin插件来实现 Tree Shaking 通过uglifyjs-webpack-plugin插件实现，此插件自带Tree Shaking功能，能剔除掉未用到的模块 使用Tree Shaking功能必须使用ES2015的模块语法 生产环境构建 为了区分开发环境和生产环境，可以提取出一个公用配置文件并分别配置不同的配置文件。 不同配置文件的合并需要使用到webpack-merge工具 可以使用webpack自带的DefinePlugin插件指定环境12345new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify('production'),// 定义的NODE_ENV可以被/src下的所有文件访问到 &#125;&#125;) 代码分离 分离代码的方法 配置不同的入口起点，手动分离代码 1234entry: &#123; index: './src/index.js', another: './src/another-module.js'&#125;, 使用CommonsChunkPlugin去重和分离块 不同模块A、B，可能会引用同一个模块C,打包后的A、B会默认包含C，使用webpack自带的CommonsChunkPlugin插件可以提取相同代码到同一个包中 123new webpack.optimize.CommonsChunkPlugin(&#123; name: 'common' // 指定公共 bundle 的名称。&#125;) 可以使用ExtractTextPlugin将css从主程序中分离出来 promise-loader用于分离代码和延迟加载生成的 bundle，主要用promise 动态导入 使用import()函数，并设置chunkFilename 懒加载 在需要某个模块的时候使用import()动态导入 注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。 缓存 [hash]可以给文件打上统一的项目指纹 [chunkhash]可以给文件打上唯一的文件指纹 创建Library 可以通过指定externals来外部化一些依赖 Shimming 可以使用ProvidePlugin在合适时机加载一些全局变量。 Typescript 可以使用ts-loader来编译typescript 构建性能 后期补 环境变量 后期补 管理依赖 后期补 Public Path 后期补 集成 后期补","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"构建","slug":"构建","permalink":"http://yoursite.com/tags/构建/"}]},{"title":"CSS_Secrets","date":"2017-12-13T01:42:03.000Z","path":"2017/12/13/CSS-Secrets/","text":"如果让我推荐基本css方面的书籍，我会推荐精通CSS（第2版）、CSS权威指南以及Lea Verou大神的CSS Secrets最近花了点时间将CSS Secrets看了遍，将所有代码敲了一遍。特在此做个记录，可以右键查看源码，绝大部分都写了注释。源码可以查看(https://github.com/BryanAdamss/SourceSave/tree/master/CssSecrets) CSS_Scerts00_减少代码重复 01_currentColor 02_使用inherit完成一些reset 03_半透明边框 04_多重边框 05_多重边框_outline 06_灵活背景图定位 07_灵活背景图定位_origin 08_灵活背景图定位_calc 09_边框内圆角_两个元素实现 10_边框内圆角_一个元素实现 11_水平条纹 12_垂直条纹 13_斜向条纹 14_更好的斜向条纹 15_灵活的同色系条纹 16_渐变生成网格 17_格子可调的网格 18_更加逼真的可调网格 19_径向渐变生成波点 20_错落有致的波点 21_渐变生成棋盘 22_渐变生成棋盘优化 23_伪随机背景 24_连续的背景边框 25_老式信封 26_蚂蚁行军边框 27_脚注 28_椭圆 29_平行四边形 30_菱形图片 31_斜向切角 32_弧形切角 33_梯形标签页 34_饼图 35_饼图_svg 36_饼图_svg优化 37_单侧、邻边、双侧投影 38_不规则投影 39_染色效果_滤镜 40_染色效果_混合模式 41_毛玻璃 42_折角效果 43_其它角度折角 44_更加逼真的折角 45_插入换行 46_代码斑马纹 47_控制tab的大小 48_自定义下划线 49_凸版文字 50_空心文字 51_文字发光效果 52_伪3d文字 53_长阴影文字 54_环形文字 55_使用禁用标志标识禁用按钮 56_扩大点击区域 57_自定义复选框 58_模糊背景 59_滚动阴影提示 60_图片对比控件 61_范围输入的图片对比控件 62_自适应内部元素 63_根据兄弟元素的数量来设置样式 64_根据兄弟元素数量范围来匹配元素 65_满幅背景定宽内容 66_弹性过渡 67_延时过渡 68_逐帧动画 69_文字闪烁动画 70_打字动画 71_状态平滑的动画 72_用两个元素实现沿环形路径平移的动画","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"ES6-learning","date":"2017-09-26T08:56:17.000Z","path":"2017/09/26/ES6-learning/","text":"ES6学习笔记 最近在看阮老师的ES6教程，所以特此记录一些重点。例子使用的大都是阮老师的例子，感谢阮老师的无私奉献。 简介 es6泛指下一代js标准，主要涵盖了es2015,es2016,es2017；一般说的es6主要指的es2015 let let实际为js提供了块级作用域，用法类似var，但它所声明的变量，仅在let所在的代码块中有效。 1234if(true)&#123; let a=3;&#125;console.log(a);// 报错 for循环中的计数变量非常适合使用let 使用var声明的 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10，因为i是全局变量，全局有效，调用时得到的是最后一次的值 使用let声明的 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6，使用let后，每轮循环的i，仅在本轮循环中有效，这样其实每轮循环都有一个新的i值。后台负责记录上一次的i值； for循环设置循环变量的部分是一个父作用域，循环体是一个子作用域，使用let声明相同的变量不会相互干扰 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 使用let，不存在变量声明提升 1234567// var 的情况console.log(foo); // 输出undefined，因为存在var foo;被提升了var foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区 个人理解：ES6在执行时，可能存在一个预先检查的过程，只要检查到某个代码块中使用let声明某变量后，那在let声明之前任何使用此变量的操作(包括带有安全防范机制的typeof)都将报错。 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError，检查到这个代码块使用了let声明了temp，所以在let声明之前使用tmp报错，即使外部有全局变量。 let tmp;&#125; 使用typeof也会报错 12typeof x;// 报错，显示x还未定义，如果没有let，因为typeof存在安全防范机制，所以返回的是'undefined'let x; 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 不能在函数内部重新声明参数 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; ES6块级作用域 let实际上为 JavaScript 新增了块级作用域 块级作用域的任意嵌套 1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量 123456789&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;;&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 最好不要在块级作用域中使用function声明函数(可以使用函数表达式来创建函数) const const基本和let类似，只在声明所在的块级作用域内有效、存在暂时性死区、同一作用域不可重复声明；重要的是一旦声明，常量的值就不能改变。 1234const PI = 3.1415;PI // 3.1415PI = 3; const声明一个变量时，必须立即给其赋值，不能先声明，后期再赋值 12const foo;// SyntaxError: Missing initializer in const declarationfoo=3; 解构赋值 ES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这过程称之为解构过程Destructuring 数组的解构赋值1let [a, b, c] = [1, 2, 3]; 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 解构不成功时，变量的值就等于undefined 1let [bar, foo] = [1];// bar为1，foo为undefined 不完全解构 等号左边的模式，只匹配一部分的等号右边的数组；解构依然会成功12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错 1234567// 报错let [foo] = 1;// 转为对象以后不具备 Iterator 接口let [foo] = false;// 转为对象以后不具备 Iterator 接口let [foo] = NaN;// 转为对象以后不具备 Iterator 接口let [foo] = undefined;// 转为对象以后不具备 Iterator 接口let [foo] = null;// 转为对象以后不具备 Iterator 接口let [foo] = &#123;&#125;;// 本身就不具备 Iterator 接口 解构时可以有默认值 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 默认值只有在当一个成员严格相等于(===)undefined时(本身值为undefined，或者没有值)，才会生效，这就是上面，最后的y为&#39;b&#39;的原因12345678let [a = 1] = [];// 无值，默认值生效a // 1let [x = 1] = [undefined];// 值为undefined，默认值生效x // 1let [x = 1] = [null];// 因为null!==undefined，默认值并未生效x // null 对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 数组是有顺序的，所以解构是按照顺序来匹配，而对象没有固定的顺序，所以结构时变量必须和属性同名，才能取到正确的值 123456let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;// 匹配和顺序无关foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;// 找不到同名的属性，所以变量取值不成功baz // undefined 如果想把取到的值赋给另外一个变量则必须用下面的写法 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;// foo取到的值'aaa'被赋给了baz变量baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象解构赋值的本质 {模式名:变量名,模式名:变量名…}={属性名:值,属性名:值…} 通过左侧模式名去找对应的属性名，取到对应属性名的值后，将值赋值给模式名后面的变量名； 当左侧模式后面的变量名没有时，会取模式的名字； 12let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;// 和下面的是等价的let &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 对应关系:模式名-&gt;属性名；变量名-&gt;值 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined，foo不是变量而是一个模式 对象解构和数组解构一样可以嵌套解构 这时的p是模式并非变量 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 取得p的值 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;// 相当于let &#123; p:p, p: [x, &#123; y &#125;] &#125; = objx // \"Hello\"y // \"World\"p // [\"Hello\", &#123;y: \"World\"&#125;] 多层嵌套 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;// 相当于let &#123; loc:loc, loc: &#123; start:start &#125;, loc: &#123; start: &#123; line:line &#125;&#125; &#125; = nodeline // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 默认值 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;// 模式是x，变量是y，并且y有个默认值3y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于undefined12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;// null!==undefined，所以默认值不生效x // null 解构失败，则变量的值为undefined 12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;// 因为foo根本就没找到此时foo为undefined，在undefined下找bar肯定报错 针对已经声明的变量使用解构赋值时，需要在最外围加上括号 1234567// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 语法块不能被赋值// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 可以将原生对象的属性方法解构到变量上 1let &#123; log, sin, cos &#125; = Math; 运用解构获取数组的首个和末尾元素 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 非对象的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象(包装对象)。12345678const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\"let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 函数参数的解构赋值 例子 1234567function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 参数解构使用默认值 123456789101112131415161718function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]；&#123;x = 0, y = 0&#125;=&#123;x: 3, y: 8&#125;move(&#123;x: 3&#125;); // [3, 0]；&#123;x = 0, y = 0&#125;=&#123;x: 3&#125;move(&#123;&#125;); // [0, 0]；&#123;x = 0, y = 0&#125;=&#123;&#125;move(); // [0, 0]；&#123;x = 0, y = 0&#125;=&#123;&#125;// 另一种写法function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]；&#123;x, y&#125;=&#123;x: 3, y: 8&#125;move(&#123;x: 3&#125;); // [3, undefined]；&#123;x, y&#125;=&#123;x: 3&#125;move(&#123;&#125;); // [undefined, undefined]；&#123;x, y&#125;=&#123;&#125;move(); // [0, 0]；&#123;x, y&#125;=&#123; x: 0, y: 0 &#125; undefined会触发函数参数的默认值 12[1, undefined, 3].map((x = 'yes') =&gt; x);// 索引1为undefined，所以默认值生效// [ 1, 'yes', 3 ] 圆括号问题 对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道.ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。建议只要有可能，就不要在模式中放置圆括号。 不能用圆括号的情况 变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数 函数参数也属于变量声明，因此不能带有圆括号1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; 赋值语句的模式中 123456// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况 赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 解构赋值的用途 交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 123456789101112131415// 返回一个数组，然后通过解构赋值赋值给变量function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象，然后通过解构赋值赋值给变量function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 12345678910111213141516171819const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 字符串的扩展使用大括号表示超过ffff的字符1234567\"𠮷\"的unicode编码为\\u20BB7，超过ffff，在es5中必须拆分成两个来写\"\\uD842\\uDFB7\"// \"𠮷\"es6中可以使用&#123;&#125;包裹来完成超过ffff字符的显示\"\\u&#123;20BB7&#125;\"// \"𠮷\" codePointAt codePointAt方法会正确返回32位的UTF-16字符的十进制表示。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同 123let s = '𠮷a';s.codePointAt(0).toString(16) // \"20bb7\" codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(\"𠮷\") // trueis32Bit(\"a\") // false String.fromCodePoin String.fromCharCode的升级版本能将超过ffff的编码转换成字符1234String.fromCharCode(0x20BB7)// \"ஷ\"String.fromCodePoint(0x20BB7)// \"𠮷\" at charAt的升级版，返回对应位置字符，可识别超过ffff的字符12345'abc'.charAt(0) // \"a\"'𠮷'.charAt(0) // \"\\uD842\",𠮷是32bit的，它返回的是高16位的编码'abc'.at(0) // \"a\"'𠮷'.at(0) // \"𠮷\" 字符串的遍历器接口 es6为字符串提供遍历接口，可以使用for…of遍历，并能遍历超过ffff编码的字符123456789101112131415161718for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\"let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// \" \"// \" \"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" includes(), startsWith(), endsWith() includes返回布尔值，表示是否找到了参数字符串 startsWith返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith返回布尔值，表示参数字符串是否在原字符串的尾部。12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true repeat 重复某个字符串，并返回新的字符串123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" padStart(),padEnd() 补齐字符串长度 123456789101112131415'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba'// 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx'// 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。'abc'.padStart(10, '0123456789')// '0123456abc'// 如果省略第二个参数，默认使用空格补全长度。'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数 123'1'.padStart(10, '0') // \"0000000001\"'12'.padStart(10, '0') // \"0000000012\"'123456'.padStart(10, '0') // \"0000123456\" 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 模板字符串中嵌入变量，需要将变量名写在${}之中。 12345678910111213141516171819202122232425262728293031323334function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125;// 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// \"3\"// 模板字符串之中还能调用函数function fn() &#123; return \"Hello World\";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 模板字符串甚至还能嵌套 123456789101112131415161718192021222324const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`;const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 标签模板 函数名后紧跟一个模板字符串 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 123alert`123`// 等同于alert(123) 如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数 会将除模板字符串中变量以外的字符串分隔成一个个字符串保存到数组中并传入函数中，并将模板字符串中变量按顺序依次传入函数中 1234567891011121314151617let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50);function tag(stringArr, value1, value2)&#123; // stringArr为['Hello ', ' world ', ''],value1为15,value2为50 // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // stringArr为['Hello ', ' world ', ''],values[15,20] // ...&#125; 用途 过滤用户恶意输入、i18n国际化12345678910111213141516171819202122232425// 一般$&#123;sender&#125;为用户的输入let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0];// 原有字符串数组 for (let i = 1; i &lt; arguments.length; i++) &#123;// i从1开始 let arg = String(arguments[i]);// 实际取到的为用户输入 // 转义用户输入中的特殊符号 s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // 拼接上原有字符串的后面部分 s += templateData[i]; &#125; return s;&#125;let sender = '&lt;script&gt;alert(\"abc\")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;console.log(message);// &lt;p&gt;&amp;lt;script&amp;gt;alert(\"abc\")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; String.raw 返回用\\转移的字符串串12345String.raw`Hi\\n$&#123;2+3&#125;!`;// \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 'Hi\\\\u000A!' 正则的扩展 老正则还不会用…先放着，后期再补吧(希望我能想起来吧…) 数值的扩展 扩展了一大批方法…(先过一遍，留个印象，用的时候再查吧) 函数的扩展函数参数的默认值 利用=直接写在形参后面 1234567function log(x, y = 'World') &#123;// y如果===undefined，则y的默认值生效 console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 参数默认值不是传值的，而是每次都重新计算默认值表达式的值 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 与解构赋值默认值结合使用 1234567891011121314function foo(&#123;x, y = 5&#125;) &#123;// 解构赋值默认值 console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5；&#123;x, y = 5&#125;=&#123;&#125;foo(&#123;x: 1&#125;) // 1 5；&#123;x, y = 5&#125;=&#123;x:1&#125;foo(&#123;x: 1, y: 2&#125;) // 1 2；&#123;x, y = 5&#125;:&#123;x:1,y:2&#125;foo() // TypeError: Cannot read property 'x' of undefined；&#123;x, y = 5&#125;=undefined所以报错function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;// 解构赋值默认值+形参默认值，就不会出现报错 console.log(x, y);&#125;foo() // undefined 5 不同写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 写法1function m1(x,y) &#123;// 形参(无默认值) return [x, y];&#125;m1(1,3);//[1,3]m1();//[undefined,undefined]// 写法2function m1(x,y=5) &#123;// 形参(有默认值) return [x, y];&#125;m1(1,3);//[1,3]m1(3);//[3,5]m1();//[undefined,5]// 写法3function m1(&#123;x , y&#125;) &#123;// 解构赋值(无默认值) return [x, y];&#125;m1(1,3);//[undefined,undefined];&#123;x,y&#125;=1,3;左右模式不一致，所以解构赋值不成功，得到undefinedm1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x,y&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x,y&#125;=&#123;x:1&#125;m1(&#123;&#125;);[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;；未找到对应属性名，所以得到undefinedm1();// err；&#123;x,y&#125;=undefined-&gt;所以报错// 写法4function m1(&#123;x = 0, y = 5&#125;) &#123;// 解构赋值(有默认值) return [x, y];&#125;m1(1,3);//[0,5];&#123;x = 0, y = 5&#125;=1,3；左右模式不匹配，得到undefined，因而解构默认值生效m1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x = 0, y = 5&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x,y&#125;=&#123;x:1&#125;m1(&#123;&#125;);//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未找到对应属性名，所以得到undefined，因而解构默认值生效m1();// err；&#123;x = 0, y = 5&#125;=undefined-&gt;所以报错// 写法5function m1(&#123;x , y&#125;=&#123;&#125;) &#123;// 解构赋值(无默认值)+形参(有默认值，空对象) return [x, y];&#125;m1(1,3);//[undefined,undefined];&#123;x,y&#125;=1,3;左右模式不一致，所以解构赋值不成功，得到undefinedm1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x , y&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x , y&#125;=&#123;x:1&#125;m1(&#123;&#125;);//[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;；未找到对应属性名，所以得到undefinedm1();//[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;// 写法6function m1(&#123;x , y&#125;=&#123;x:3,y:4&#125;) &#123;// 解构赋值(无默认值)+形参(有默认值，非空对象) return [x, y];&#125;m1(1,3);//[undefined,undefined];&#123;x,y&#125;=1,3;左右模式不一致，所以解构赋值不成功，得到undefinedm1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x , y&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,undefined]；&#123;x , y&#125;=&#123;x:1&#125;m1(&#123;&#125;);//[undefined,undefined]；&#123;x , y&#125;=&#123;&#125;；未找到对应属性名，所以得到undefinedm1();//[3,4]；&#123;x , y&#125;=&#123;x:3,y:4&#125;；未传参数，所以形参的默认值&#123;x:3,y:4&#125;生效，参与解构// 写法7function m1(&#123;x = 0, y = 5&#125;=&#123;&#125;) &#123;// 解构赋值(有默认值)+形参(有默认值，空对象) return [x, y];&#125;m1(1,3);//[0,5];传入参数跟想要的类型不一致，所以行参默认值生效&#123;x = 0, y = 5&#125;=&#123;&#125;;未找到对应属性名，所以解构默认值生效m1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x = 0, y = 5&#125;=&#123;x:1,y:3&#125;// 默认值&#123;&#125;不生效m1(&#123;x:1&#125;);//[1,5]；&#123;x = 0, y = 5&#125;=&#123;x:1&#125; m1(&#123;&#125;);//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未找到对应属性名，所以得到undefined，解构的默认值生效m1();//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未传参数，所以形参的默认值&#123;&#125;生效，参与解构，未解构到对应属性名，所以解构的默认值生效// 写法8function m1(&#123;x = 0, y = 5&#125;=&#123;x:4,y:8&#125;) &#123;// 解构赋值(有默认值)+形参(有默认值，非空对象) return [x, y];&#125;m1(1,3);//[0,5];传入参数跟想要的类型不一致，所以行参默认值生效&#123;x = 0, y = 5&#125;=&#123;&#125;;未找到对应属性名，所以解构默认值生效m1(&#123;x:1,y:3&#125;);//[1,3]；&#123;x = 0, y = 5&#125;=&#123;x:1,y:3&#125;m1(&#123;x:1&#125;);//[1,5]；&#123;x = 0, y = 5&#125;=&#123;x:1&#125; m1(&#123;&#125;);//[0,5]；&#123;x = 0, y = 5&#125;=&#123;&#125;；未找到对应属性名，所以得到undefined，解构的默认值生效m1();//[4,8]；&#123;x = 0, y = 5&#125;=&#123;x:4,y:8&#125;；未传参数，所以形参的默认值&#123;x:4,y:8&#125;生效，参与解构 参数默认值的位置 要设置默认值的参数，应该放在参数列表的尾部，因为这样方便看出调用时省略了哪些参数12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 函数的length 返回没有指定默认值的参数个数，指定了默认值后，length属性将失真 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的； 设置默认值时，会在形参声明处生成一个单独的作用域。它只可以受全局作用影响，不受函数体内的作用域影响123456789101112131415161718192021222324252627282930313233var x = 1;function f(x, y = x) &#123;// 等价于let x;let y=x;因为形参处已经声明了x，所以y=x后，xy都为同一个值-&gt;实际传进来的值，而不是全局的x console.log(x,y);&#125;f(2) // 2function f(y = x) &#123;// let y=x;外部没有定义x所以报错(形参不受函数体内影响) let x = 2; console.log(y);&#125;f() // ReferenceError: x is not definedvar x = 1;function foo(x = x) &#123;// let x=x;由于tdz，x在声明结束前无法使用x // ...&#125;foo() // ReferenceError: x is not definedlet foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outervar x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123;// 因为形参出已经有了x,所以y的匿名函数中的x指向的也就是形参处的x，它就不会再受外界影响了 var x = 3;// 在函数体内重新声明了一个x和外界的x不是同一个 y();//调用后，改变的是形参的x console.log(x);// 根据就近原则，找到的是函数体中的x，所以打印不是行参的x，如果去掉var x=3;则打印的是形参的x&#125;foo() // 3x // 1 参数默认值的应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter rest参数 用于获取函数的剩余参数，将其保存到一个数组中，这样就不需要使用arguments对象了 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 和arguments的区别 arguments是一个类数组，并不是真正的数组 rest得到的是一个真正的数组，可以直接调用数组的方法1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); rest参数必须放在形参列表的尾部 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。 123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 严格模式 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;; 解决方法 设置全局的严格模式，不推荐 12345'use strict';function doSomething(a, b = a) &#123; // code&#125; 函数包在一个无参数的立即执行函数里面 123456const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;()); name属性 返回函数名，es5就有，但es6做了一些修改123456789101112131415161718var f = function () &#123;&#125;;// ES5f.name // \"\"// ES6f.name // \"f\"const bar = function baz() &#123;&#125;;// ES5bar.name // \"baz\"// ES6bar.name // \"baz\"(new Function).name // \"anonymous\"function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // \"bound foo\"(function()&#123;&#125;).bind(&#123;&#125;).name // \"bound \" 箭头函数 基础语法 1234567891011(param1, param2, paramN) =&gt; &#123; 多条语句；return 表达式; &#125;(param1, param2, paramN) =&gt; 表达式// 等价于：(param1, param2, paramN) =&gt; &#123; return 表达式; &#125;/* 当删除大括号时，它将是一个隐式的返回值，这意味着我们不需要指定我们返回*/// 如果只有一个参数，圆括号是可选的:(singleParam) =&gt; &#123; statements;return 表达式; &#125;singleParam =&gt; &#123; statements; return 表达式;&#125;// 如果箭头函数 无参数 , 必须使用 ()圆括号:() =&gt; &#123; statements; return 表达式;&#125; 高级语法 123456789//返回一个对象时，函数体外要加圆括号，否则会被当成语法块，进而语法错误params =&gt; (&#123;foo: bar&#125;)// 支持 剩余参数和默认参数:(param1, param2, ...rest) =&gt; &#123; statements; return 表达式; &#125;(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements; return 表达式; &#125;// 也支持参数列表中的解构赋值let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c; // a=1; b=2; x=c; c=a+b=3;f(); // 6 注意事项 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 准确的说应该是，箭头函数本身没有this，它的this是继承最近父作用域的(更准确的说是直接使用的最近父作用域的this)，即最近父作用域被调用时的this是什么，它的this就是什么；这过程类似变量的溯源查找过程。 1234567891011121314151617181920212223242526// 正常情况function foo()&#123; setTimeout(function()&#123; console.log('id',this.id); &#125;,100); // 会输出21，setTimeout内部是这样的 function setTimeout(fn,delay)&#123; fn();// fn不是做为方法调用，也不是new，更没有使用call、apply、bind做显示绑定，而是属于直接调用，所以内部this指向了window，进而最终输出21 &#125;&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// 21// 箭头函数function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100); // 箭头函数没有this,它的this是用的最近父作用域foo被调用时的this， // foo调用时，this被绑定到了&#123; id: 42 &#125;，所以箭头函数用的this也是&#123; id: 42 &#125;，进而最终输出了42&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// 42 如何快速判断箭头函数的this，直接找它定义时的直接父函数或者直接父对象 12345678function foo() &#123; setTimeout(() =&gt; &#123;// 这个箭头函数定义时，直接父函数为foo，所以它的this是foo被调用时的this console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// 42 箭头函数没有arguments、super、new.target，如果要使用arguments，可以用rest参数代替 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 箭头函数没有自己的this，所以更不能使用call、apply、bind，这些方法无法改变this的指向 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;);// [&apos;outer&apos;] 箭头函数不能使用new，否则会报错 尾调用优化 尾调用 指某个函数的最后一步是调用另一个函数 12345678910111213141516171819function f(x)&#123; return g(x);&#125;// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 尾调用优化 如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误1234567891011121314// 普通递归function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120// 尾递归function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 递归函数的改写 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的 非严格模式下，可以通过将递归改写成循环，进而模拟尾递归调用的优化效果(减少调用帧) 数组的扩展扩展运算符 可以理解为rest参数的逆运算；rest参数是将逗号分隔的参数列表转换成数组，而扩展运算符号则是将数组转换成逗号分隔的列表 1234567891011121314151617console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]let arr=[];const numbers = [4, 38];function push(array, ...items) &#123;// arr,[4,38] array.push(...items);// items为数组，无法做为push的参数，所以使用了扩展运算符，转换成了参数列表&#125;push(arr,...numbers);// 相当于push(arr,4,38)console.log(arr);//[4,38] 扩展运算符与正常的函数参数可以结合使用，非常灵活 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 用途 替代数组的apply方法 1234567891011121314151617181920212223// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args);// 取最大值// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 合并数组 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 扩展运算符可以与解构赋值结合起来，用于生成数组 12345678910111213141516// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = listconst [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 函数返回值 12let dateFields = readDateFields(database);let d = new Date(...dateFields);// Data不接收数组，所以转换成参数列表 字符串转数组 12[...'hello']// [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 实现了Iterator接口的对象，都能转换成数组 12345678910111213141516let nodeList = document.querySelectorAll('div');// nodelist有Iterator接口，所以可以转换成数组let array = [...nodeList];let map = new Map([// Map有Iterator接口 [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]const go = function*()&#123;// Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] Array.from 将类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）转换成数组 所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换12345678910111213141516171819202122232425262728293031let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125;Array.from('hello')// es6中字符串有Iterator接口// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b']Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// 对象有length，所以是类数组对象，可以用from转换// ['jack', 'jack'] Array.of() Array.of方法用于将一组值，转换为数组。弥补数组构造函数Array()的不足，因为参数个数的不同，会导致Array()的行为有差异。 Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。1234567Array() // []Array(3) // [, , ,]，只有一个参数时，是指定的数组长度Array(3, 11, 8) // [3, 11, 8]Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组，所以会修改当前数组1234567891011121314151617181920212223242526272829Array.prototype.copyWithin(target, start = 0, end = this.length)target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。[1, 2, 3, 4, 5].copyWithin(0, 3)// 读取从索引3开始到结束的数据4,5并替换从0开始的数据// [4, 5, 3, 4, 5]// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined 123456[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5[1, 5, 10, 15].find(function(value, index, arr) &#123;//当前值，索引，原数组 return value &gt; 9;&#125;) // 10 返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 数组实例的fill() fill方法使用给定值，填充一个数组。12345678['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// 将7填充到[1,2)区间// ['a', 7, 'c'] 数组实例的 entries()，keys() 和 values() entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 数组实例的 includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 数组的空位 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位；ES6 则是明确将空位转为undefined。 12345678910111213141516171819202122232425262728293031Array.from(['a',,'b'])// [ \"a\", undefined, \"b\" ][...['a',,'b']]// [ \"a\", undefined, \"b\" ][,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]new Array(3).fill('a') // [\"a\",\"a\",\"a\"]let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1// entries()[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,\"a\"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 对象的扩展属性的简洁表示法 ES6允许直接写入变量和函数，作为对象的属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于const baz = &#123;foo: foo&#125;;// 属性简写function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;// 方法简写const o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;;// 实际例子let birth = '2000/01/01';const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;;// 用在函数返回值function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125;// 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125;// 简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果const obj = &#123; class () &#123;&#125;&#125;;// 等同于var obj = &#123; 'class': function() &#123;&#125;&#125;;// 如果某个方法的值是一个 Generator 函数，前面需要加上星号const obj = &#123; * m() &#123; yield 'hello world'; &#125;&#125;; 属性名表达式 ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。12345678910111213141516171819202122232425262728293031323334let lastWord = 'last word';const a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // \"hello\"a[lastWord] // \"world\"a['last word'] // \"world\"// 表达式还可以用于定义方法名let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi// 属性名表达式与简洁表示法，不能同时使用，会报错// 报错const foo = 'bar';const bar = 'abc';const baz = &#123; [foo] &#125;;// 正确const foo = 'bar';const baz = &#123; [foo]: 'abc'&#125;;// 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: \"valueB\"&#125; 方法的 name 属性 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性123456789101112const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // \"sayName\"(new Function()).name // \"anonymous\"var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // \"bound doSomething\" Object.is() ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。 Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。和===不同点在于一是+0不等于-0，二是NaN等于自身12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() 类似jQuery的$.extend()方法，可用来合并对象 1234567891011121314const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;// 重名属性，后面对象会覆盖前面的const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false） 1234567Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;))// &#123; b: 'c' &#125; Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用 12345678910const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2// 同名属性，直接替换引用const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source);// &#123; a: &#123; b: 'hello' &#125; &#125; Object.assign可以用来处理数组，但是会把数组视为对象 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 用途 为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;);// 将x属性和y属性添加到Point类的对象实例 &#125;&#125; 为对象添加方法 12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 克隆对象 12345678910// 克隆原始对象自身的值，不能克隆它继承的值function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125;// 克隆同时保持继承链function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象 12345// 将多个对象合并到某个对象const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);// 合并后返回一个新对象const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值 12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; 属性的可枚举性和遍历 Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 四个操作会忽略enumerable为false的属性 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。 属性遍历 for…in for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性） Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性） Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。 Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。 遍历规则 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] Object.getOwnPropertyDescriptors 返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 1234567891011121314151617181920212223242526272829303132const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target1 = &#123;&#125;;Object.assign(target1, source);Object.getOwnPropertyDescriptor(target1, 'foo')// &#123; value: undefined,// writable: true,// enumerable: true,// configurable: true &#125;// 正确拷贝set方法const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, 'foo')// &#123; get: undefined,// set: [Function: foo],// enumerable: true,// configurable: true &#125;// 上面代码中，两个对象合并的逻辑可以写成一个函数。const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); 配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝 1234567const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));// 或者const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); proto属性，Object.setPrototypeOf()，Object.getPrototypeOf() proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象，浏览器内部方法 123456789// es6的写法const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es5的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; Object.setPrototypeOf() Object.setPrototypeOf方法的作用与proto相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法12345678910// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null);// 等同于function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; Object.getPrototypeOf() 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象123456789101112function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false Object.keys()，Object.values()，Object.entries() Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组 123456789101112131415161718var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// [\"foo\", \"baz\"]let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; Object.entries的基本用途是遍历对象的属性 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// \"one\": 1// \"two\": 2 对象的扩展运算符 解构赋值 123456789101112let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125;// 解构赋值不会拷贝继承自原型对象的属性。let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 可用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，这等同于使用Object.assign方法。它只拷贝了对象实例的属性 1234567891011121314151617181920let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125;let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a);// 想完整克隆一个对象，还拷贝对象原型的属性// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj); 用于合并两个对象 123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); Null 传导运算符 如果读取对象内部的某个属性，往往需要判断一下该对象是否存在 123456789101112131415// 以前写法const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default';// 现在写法// 如果 a 是 null 或 undefined, 返回 undefined// 否则返回 a.b.c().da?.b.c().d// 如果 a 是 null 或 undefined，下面的语句不产生任何效果// 否则执行 a.b = 42a?.b = 42// 如果 a 是 null 或 undefined，下面的语句不产生任何效果delete a?.b Symbol是啥？ Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，用它创建的属性名是绝对唯一的，不会产生冲突；Symbol 数据类型是一个原始数据类型； 创建 12345let s = Symbol();typeof s // \"symbol\"let s1 = Symbol('foo');s1 // Symbol(foo) 通过Symbol()创建的symbol与其他任何值都不相等 123456789// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false Symbol 值不能与其他类型的值进行运算 12345let sym = Symbol('My symbol');\"your symbol is \" + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string Symbol 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。 123456789101112131415// Symbol 值可以显式转为字符串let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)'let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 做为属性名使用 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123;// 对象的增强属性名写法 [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 做为属性名使用时，不能使用.语法，使用点语法会被当成字符串处理123456const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // \"Hello!\" 属性名的遍历 Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。1234567891011const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] Symbol的共享(重复使用) 有时，我们想重复使用某个Symbol，我们知道通过Symbol()方法，生成的symbol是绝对唯一的，即使描述符一样 123let s1 = Symbol('foo');let s2 = Symbol('foo');s1===s2 // false Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值 123456789let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // trueSymbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false 用Symbol实现单例模式 传统实现 123456789101112// mod.jsfunction A() &#123; this.foo = 'hello';&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo;// 加载const a = require('./mod.js');console.log(a.foo); 全局变量global._foo是可写的，任何文件都可以修改 使用Symbol 123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() &#123; this.foo = 'hello';&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写12const a = require('./mod.js');global[Symbol.for('foo')] = 123; Set和Map数据结构Set数据结构 它类似于数组，但是成员的值都是唯一的，没有重复的值。 使用new Set()创建 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4，重复值不会被保留 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化 1234567891011121314151617181920// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]，自动删除了重复的值，可利用这方法实现数组去重// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;const set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 Set判断值是否重复，类似===，不过NaN等于自身；任意两个对象是不相等的 123456789101112let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125;let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 属性和方法 属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // falselet set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"]// 可直接使用for..of遍历let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// bluelet set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 使用forEach做附加操作// 2// 4// 6// set配合filter完成交集、并集、差集let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; Array.from方法可以将 Set 结构转为数组。 12345678const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);// 利用from方法完成数组的去重function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别 WeakSet 的成员只能是对象，而不能是其他类型的值 垃圾回收机制不考虑 WeakSet 对该对象的引用；如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中 WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失 WeakSet 的成员是不适合引用的，因为它会随时消失 由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历1234567891011121314const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set// WeakSet 可以接受一个数组或类似数组的对象作为参数(实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数)const a = [[1, 2], [3, 4]];const ws = new WeakSet(a);// 会将a数组的成员添加到ws中，而不是a数组自身；所以数组成员必须是对象// WeakSet &#123;[1, 2], [3, 4]&#125;const b = [3, 4];const ws = new WeakSet(b); // b的成员不是对象，所以会出错// Uncaught TypeError: Invalid value used in weak set(…) 方法 add、delete、has，同set相比没有clear方法1234567891011121314151617const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false// WeakSet没有size属性，没有办法遍历它的成员。ws.size // undefinedws.forEach // undefinedws.forEach(function(item)&#123; console.log('WeakSet has ' + item)&#125;)// TypeError: undefined is not a function Map数据结构 类似Object结构，都是key-value结构，不同的地方是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 提供了一种更加灵活方便的一一映射的结构 123456789101112131415161718192021222324252627282930const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false// 接收数组做为参数const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\"// 上面的等同于const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach(// 取得每个item的key,value，然后再添加到map中 ([key, value]) =&gt; map.set(key, value)); 属性和方法 属性 size属性返回 Map 结构的成员总数。 操作方法 set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 get方法读取key对应的键值，如果找不到key，返回undefined。 has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete方法删除某个键，返回true。如果删除失败，返回false。 clear方法清除所有成员，没有返回值。 遍历方法 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// sizeconst map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2// setconst m = new Map();m.set('edition', 6) // 键是字符串m.set(262, 'standard') // 键是数值m.set(undefined, 'nah') // 键是 undefined// set方法返回的是当前的Map对象，因此可以采用链式写法。let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');// getconst m = new Map();const hello = function() &#123;console.log('hello');&#125;;m.set(hello, 'Hello ES6!') // 键是函数m.get(hello) // Hello ES6!// hasconst m = new Map();m.set('edition', 6);m.set(262, 'standard');m.set(undefined, 'nah');m.has('edition') // truem.has('years') // falsem.has(262) // truem.has(undefined) // true// deleteconst m = new Map();m.set(undefined, 'nah');m.has(undefined) // truem.delete(undefined)m.has(undefined) // false// clearlet map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0// 遍历方法const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// forEach，第二个参数可以绑定thisconst reporter = &#123; report: function(key, value) &#123; console.log(\"Key: %s, Value: %s\", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); map转数组可以使用...扩展运算符 1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法） 1234567891011121314const map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');const map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;const map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 与其他数据结构的互相转换 Map 转为数组 12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 数组 转为 Map 12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; Map 转为对象 12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 对象转为 Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;\"yes\" =&gt; true, \"no\" =&gt; false&#125; Map 转为 JSON 12345678910111213141516// Map 的键名都是字符串，这时可以选择转为对象 JSON。function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;\"yes\":true,\"no\":false&#125;'// Map 的键名有非字符串，这时可以选择转为数组 JSONfunction mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' JSON 转为 Map 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;\"yes\": true, \"no\": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; WeakMap 类似WeakSet 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = &#123;foo: 1&#125;;wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2) // \"bar\" WeakMap与Map的区别有两点。 WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名 WeakMap的键名所指向的对象，不计入垃圾回收机制1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏 WeakMap 应用的典型场合就是 DOM 节点作为键名 1234567891011let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false);// 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 部署私有属性 123456789101112131415161718192021222324const _counter = new WeakMap();const _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;const c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec()// DONE Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器” Proxy相当于在目标对象上添加了一层拦截器，在某些操作生效之前，可以在拦截器中做一些操作，例如在设置某个值前，检查值是否符合要求123456789101112131415161718192021222324252627282930313233343536var proxy = new Proxy(&#123;&#125;, &#123;// 代理了&#123;&#125;对象的所有get操作，在实际操作生效前，拦截了并返回新值 get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35// 拦截器可以代理很多类型的操作，在这些操作真正生效前，进行拦截var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // \"Hello, foo\" Proxy中的this问题 在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true，代理后，this指向了proxy而不是原先的target Reflect 应该是js在设计之初有些不合理的地方，例如将一些明显是语言内部的方法放到了Object上，现在要改正，需要一个容器来装载这些方法，所以将这些改良方法都放在了Reflect对象上 特点 现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。 让Object操作都变成函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。 Promise对象 可以和jQuery中的延迟对象以及promise对比理解 基本用法 123456789101112131415var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; return resolve(value); &#125; else &#123; return reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise新建后就会立即执行 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); return resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 返回另一个异步操作 12345678var p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);var p2 = new Promise(function (resolve, reject) &#123; // ... return resolve(p1);// p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行&#125;); p.then promise.then(resolvedFn,rejectFn); 基于前一个promise的状态分别调用不同的回调函数1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"rejected: \", err);&#125;); p.catch Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); p.all Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 当多个promise都resolve了，则调用then的resolvFn，否则都调用rejectFn1234567891011// promises是包含6个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); p.race Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例，哪个promise状态先改变，则后面的回调将根据其状态做不同的调用123456789101112var p = Promise.race([p1, p2, p3]);// 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error));// 如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数 Promise.resolve 用来将一个对象转换成ES6的Promise对象 参数是一个Promise实例，则直接返回这个Promise实例 参数是一个thenable对象，Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 参数不是具有then方法的对象，或根本就不是对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved 123456var p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 不带有任何参数，直接返回一个resolved状态的Promise对象。 12345var p = Promise.resolve();p.then(function () &#123; // ...&#125;); Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Iterator 和 for…of 循环Iterator 遍历器（Iterator）它是一种接口，为各种不同的数据结构提供统一的访问机制； 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable） 123456let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;// done表示本次遍历结束 原生具备 Iterator 接口的数据结构如下，对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，原生的Obj不具备遍历器接口 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 某些情况下，会默认调用Iterator 接口 解构赋值 扩展运算符 yield* 任何接受数组作为参数的场合，其实都调用了遍历器接口 for…of 所有部署了Iterator接口的数据结构，都可以使用for…of来进行遍历 所有原生具备Iterator接口的都可以直接使用for…of遍历 123456789101112131415161718192021222324252627282930313233// 数组const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125;const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for(let v of obj) &#123; console.log(v); // red green blue&#125;// Set、Mapvar engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set(\"edition\", 6);es6.set(\"committee\", \"TC39\");es6.set(\"standard\", \"ECMA-262\");for (var [name, value] of es6) &#123; console.log(name + \": \" + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map 都部署了keys()、values()、entries方法，调用后都返回遍历器对象 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 类似数组的对象 1234567891011121314151617181920212223// 字符串let str = \"hello\";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll(\"p\");for (let p of paras) &#123; p.classList.add(\"test\");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 对象不可直接使用for…of遍历 1234567891011121314151617let es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6[Symbol.iterator] is not a function 使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 遍历语法的对比 for 繁琐123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; forEach方法 无法中途跳出forEach循环，break命令或return命令都不能奏效。123myArray.forEach(function (value) &#123; console.log(value);&#125;); for…in for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键 遍历顺序在某些情况下还不固定 主要是为对象部署的 for…of 只要部署了遍历接口的数据结构都可使用 不同于forEach方法，它可以与break、continue和return配合使用。12345for (var n of fibonacci) &#123; if (n &gt; 1000) break; console.log(n);&#125; Generator 函数的语法基本概念 Generator函数总是返回一个遍历器对象，通过调用遍历器对象的next()方法，让函数一步一步的执行 语法形式 123456789101112131415161718function* helloWorldGenerator() &#123;// function后跟一个* yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();// 被调用时，返回一个遍历器对象，可在遍历器对象上调用next()方法hw.next() // 每次调用next()返回的对象的value值都是yield后表达式对应的值// &#123; value: 'hello', done: false &#125;hw.next() // 每次调用next()时，会寻找下一个yield表达式// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; yield 表达式 yield是暂停标志，调用next()时，遇到yield会暂停，并将后面表达式的值返回，下次调用next()时会按顺序寻找下一个yield；如果是最后一个yield，则继续执行，直到遇到return，将return后面的值做为返回的对象的value值，如果没有return，则返回对象的value值为undefined yield后面的表达式是惰性求值 123function* gen() &#123; yield 123 + 456; // yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值&#125; yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 1234(function ()&#123; yield 1;&#125;)()// SyntaxError: Unexpected number 与 Iterator 接口的关系 由于Generator 函数返回的是一个遍历器对象，所以可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] next方法的参数 yield表达式本身没有返回值，或者说总是返回undefined next方法的参数代表上一个yield表达式返回的值123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;，第一次调用next，找到yield，此时i为0，暂停后面的执行并返回0做为返回对象的value值g.next() // &#123; value: 1, done: false &#125;，在上一次yield后继续执行寻找下一个yield，由于第一次yield默认返回undefined，所以rest为undefined,所以i=-1并未执行，进入第二轮循环，找到yield，此时i为1，暂停后面的执行并返回1做为返回对象的value值g.next(true) // &#123; value: 0, done: false &#125;，传入参数true，true被当成上一个yield表达式的返回值，所以rest为true，进而i=-1被执行，进入第三次循环(此时i已经加1了为0)，找到yield，此时i为0，暂停后面的执行并返回0做为返回对象的value值 for…of for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5，不会返回return后的值，所以for...of只会按顺序返回yield后的值 Generator.prototype.throw()、Generator.prototype.return() throw用来抛出错误 return可以返回给定的值，并且终结遍历 Generator 函数 在Generator函数内调用另外一个Generator函数 使用yield*表达式12345678910111213141516171819202122232425function* inner() &#123; yield 'hello!';&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'close';&#125;var gen = outer1()gen.next().value // \"open\"gen.next().value // 返回一个遍历器对象gen.next().value // \"close\"function* outer2() &#123; yield 'open' yield* inner() yield 'close'&#125;var gen = outer2()gen.next().value // \"open\"gen.next().value // \"hello!\"gen.next().value // \"close\" 作为对象属性的Generator函数可以采用简写形式 123456789101112let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;;// 简写形式let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 应用 异步操作的同步化表达 1234567891011121314function* main() &#123; var result = yield request(\"http://some.url\");// 1.此处被暂停，进行request异步请求 var resp = JSON.parse(result);// 对2处异步请求的返回值做相应处理 console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123;// 异步请求成功 it.next(response);// 2.手动调用next，并将异步请求的返回值做为上一次yield表达式的值 &#125;);&#125;var it = main();// 返回遍历器对象it.next();// 执行next，寻找第一个yield 控制流管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;);// promise改写Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done();// generator改写function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125; 部署 Iterator 接口 原生obj上因为没有Iterator 接口无法使用for…of，可以利用Generator 函数，可以在任意对象上部署 Iterator 接口。12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7 作为数据结构 Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。123456789function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125;for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; Generator 函数的异步应用传统方法完成异步 回调 容易出现callback hell12345fs.readFile(fileA, 'utf-8', function (err, data) &#123; fs.readFile(fileB, 'utf-8', function (err, data) &#123; // ... &#125;);&#125;); Promise 允许将回调函数的嵌套，改成链式调用 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚 Generator 函数完成异步任务 利用Generator中的yield暂停函数的执行，等到恢复后，继续从此处执行； 遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。 通过next方法接收参数，向Generator函数体内输入数据。12345678910111213141516var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url);// 返回的结果保存在result中 console.log(result.bio);&#125;var g = gen();var result = g.next();// 得到异步读取的结果result.value.then(function(data)&#123;// Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next方法。 return data.json();// 转换为json&#125;).then(function(data)&#123; g.next(data);// 传入Generator函数&#125;); async 函数async函数是Generator函数的语法糖12345678910111213141516171819202122232425const fs = require('fs');const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function* () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;// 使用async改写const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 改进 内置执行器 Generator必须手动一步一步的调用next()方法或者是用第三方的执行器自动执行，而async函数内部了执行器，能自动执行 更好的语义 更广的适用性 如果使用第三放的执行器，例如co则yield后只能是Thunk 函数或 Promise 对象，而async函数内的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作） async返回值是Promise，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作 async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖 基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name);// 等待getStockSymbol异步完成，再执行下面的 const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123;// getStockPriceByName是一个async函数，所以返回的是Promise，可以使用then console.log(result);&#125;); async 函数有多种使用形式 123456789101112131415161718192021222324252627// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function () &#123;&#125;;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// Class 的方法class Storage &#123; constructor() &#123; this.cachePromise = caches.open('avatars'); &#125; async getAvatar(name) &#123; const cache = await this.cachePromise; return cache.match(`/avatars/$&#123;name&#125;.jpg`); &#125;&#125;const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; &#123;&#125;; 语法 async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。 123456async function f() &#123;// 整体返回一个Promise对象 return 'hello world';// 内部的return返回的值将当做then方法回调的参数&#125;f().then(v =&gt; console.log(v))// 'heollo world'传递给了v// \"hello world\" 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象 123456async function f() &#123; return await 123;// 123会被转换成Promise对象，并立即resolved&#125;f().then(v =&gt; console.log(v))// 123 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数 1234567async function getTitle(url) &#123;// 所有await命令都执行完成，才会执行then的回调 let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle('https://tc39.github.io/ecma262/').then(console.log)// \"ECMAScript 2017 Language Specification\" 注意点 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到 123456789async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// 出错了 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行 1234async function f() &#123; await Promise.reject('出错了'); await Promise.resolve('hello world'); // 不会执行&#125; 前一个异步操作失败，也不要中断后面的异步操作，可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。或者await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 123456789101112131415161718192021async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123; &#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// hello world// await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v))// 出错了// hello world 多个await命令后面的异步操作，如果不存在继发关(依赖)系，最好让它们同时触发。 123456// getBar、getFoo这两个异步请求并无依赖关系，但这种写法getBar必须在getFoo完成后再请求let foo = await getFoo();let bar = await getBar();// 使用Promise.alllet [foo, bar] = await Promise.all([getFoo(), getBar()]);// 二者可以同时请求 await命令只能用在async函数之中，如果用在普通函数，就会报错 12345678async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; // 报错 docs.forEach(function (doc) &#123;// forEach参数为普通函数，所以无法使用await await db.post(doc); &#125;);&#125; 实例:按顺序完成异步操作 Promise 的写法如下 12345678910111213// 使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; async写法 1234567891011121314151617181920async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125;// 上面的代码，下一个请求必须在上一个请求完成后再请求，而请求之间无依赖关系，所以可以同时请求，优化如下async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125;// 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。 异步遍历器 类似同步遍历器，不过它调用next()方法后返回的是一个Promise对象，可以使用then方法 12345asyncIterator .next() .then( (&#123; value, done &#125;) =&gt; /* ... */ ); 异步遍历器接口返回的是一个异步遍历器，可以使用for await...of来遍历 1234567async function f() &#123; for await (const x of createAsyncIterable(['a', 'b'])) &#123; console.log(x); &#125;&#125;// a// b 异步 Generator 函数 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。 语法上，异步 Generator 函数就是async函数与 Generator 函数的结合 123456789101112131415161718192021222324252627// gen是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用next方法，返回一个 Promise 对象async function* gen() &#123; yield 'hello';&#125;const genObj = gen();genObj.next().then(x =&gt; console.log(x));// &#123; value: 'hello', done: false &#125;// 同步 Generator 函数function* map(iterable, func) &#123; const iter = iterable[Symbol.iterator](); while (true) &#123; const &#123;value, done&#125; = iter.next(); if (done) break; yield func(value); &#125;&#125;// 异步 Generator 函数async function* map(iterable, func) &#123; const iter = iterable[Symbol.asyncIterator](); while (true) &#123; const &#123;value, done&#125; = await iter.next(); if (done) break; yield func(value); &#125;&#125; 异步 Generator 函数出现以后，JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘）存在明显的先后顺序才能得到正确结果时，可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数 Class的基本语法Class ES6的class(类)可以看做是ES5中类写法的一个语法糖 12345678910111213141516171819202122232425//ES5function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2);//ES6class Point &#123; constructor(x, y) &#123;// 使用new时，会自动调用这个方法 this.x = x; this.y = y; &#125; toString() &#123;// toString实际是定义在原型对象上的，所以所有实例对象都可以使用此方法 return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var p=new Point(1,2); 类的所有方法都定义在类的prototype属性上面，所以所有实例对象都可以使用此方法 123456789101112131415161718192021class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 类的内部所有定义的方法，都是不可枚举的（non-enumerable） 1234567891011121314151617181920212223242526272829// ES6class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"]//ES5写法中，方法是可枚举的var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [\"toString\"]Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 类内，默认采用严格模式 与函数一样，类也可以使用表达式的形式定义。123456789101112const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined// 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式const MyClass = class &#123; /* ... */ &#125;; constructor方法 类中的constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法；一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加；constructor方法默认返回的实例对象 12345678// 没有显示添加constructor方法，会默认添加class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 类必须使用new调用，否则会出错 12class B&#123;&#125;B();// error 不存在变量提升 类不存在变量提升（hoist），这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 私有属性、方法 ES6暂不提供私有属性、方法，不过可以模拟123456789101112131415161718192021// 私有方法class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125;// 私有属性，新提案使用#标识class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125;&#125; this 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错123456789101112131415161718192021222324252627282930313233class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;// 将logger的printName方法单独提取出来printName(); // TypeError: Cannot read property 'print' of undefined，因为此时this已经不指向logger实例了，所以找不到print方法，解决方法如下// 直接绑定thisclass Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125;// 使用箭头函数class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; Class 的取值函数（getter）和存值函数（setter） 存值函数和取值函数是设置在属性的 Descriptor 对象上的1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \"html\");\"get\" in descriptor // true\"set\" in descriptor // true Class 的 Generator 方法 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123;// 返回一个同步遍历器对象，可以使用for...of遍历 for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world 类的静态方法 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function，无法在实例上调用 静态方法包含this关键字，这个this指的是类，而不是实例 12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log('hello'); &#125; baz () &#123; console.log('world'); &#125;&#125;Foo.bar() // hello 父类的静态方法，可以被子类继承 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 类的静态属性 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 1234567891011121314151617// 暂时只能用下面这种写法class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 新提案对实例属性和静态属性都规定了新的写法 1234567891011121314151617// 类的实例属性可以用等式，写入类的定义之中。以前，我们定义实例属性，只能写在类的constructor方法里面。class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 &#125;&#125;// 类的静态属性，类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; new.target属性 一般用在构造函数之中，返回new命令调用的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 构造函数不是通过new调用的，报错 用在ES6中的class时，new.target返回的是new后跟着的类名(其实本质一样) 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 子类继承父类时，new.target会返回子类，而不是父类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // Square===Rectangle，所以输出 false， 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 class的继承extends Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。123456// 定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; super ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 123456class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y)，获取父类的实例(this对象) this.color = color; &#125;&#125; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123;// 指定了constructor，但没有调用super方法 &#125;&#125;let cp = new ColorPoint(); // ReferenceError 当未显示指定constructor方法时，会默认添加constructor方法，并在内部自动调用super方法 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError，子类没有自己的this，必须先获得父类的this super(x, y); this.color = color; // 正确 &#125;&#125; super的使用 super关键字可以当函数使用，也可以当作对象使用 super作为函数调用时，代表父类的构造函数 1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super();// 调用父类的constructor，得到父类的this(实例对象)，进而可以进行加工得到自己的实例对象 &#125;&#125; super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。这里其实就可以理解为，先调用父类的构造函数方法创建一个父类的实例对象，然后拷贝一份给子类，这样子类就拥有了自己的实例对象，然后通过子类自己的构造函数对拷贝过来的实例对象进行修改加工。 123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 1234567class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 普通方法中// 子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B();// 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p;// super代表的是A.prototype，实例方法无法引用到 &#125;&#125;let b = new B();b.m // undefined// 如果属性定义在父类的原型对象上，super就可以取到。class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125;&#125;let b = new B(); ES6 规定，通过super调用父类的方法时，super会绑定子类的this 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print();// 调用父类原型对象上的print方法，但是this绑定的是子类的，实际上执行的是super.print.call(this) &#125;&#125;let b = new B();b.m() // 2 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性 1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象 123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 12345678class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); // 报错 &#125;&#125; 原生构造函数的继承 ES5中是无法继承原生构造函数，或者继承出来的行为不一致 123456789101112131415161718192021// 子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。// ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;);var colors = new MyArray();colors[0] = \"red\";colors.length // 0colors.length = 0;colors[0] // \"red\" ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。 123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined Decorator修饰器 用来修改类、方法的行为 修饰类 1234567891011121314151617181920212223242526272829303132@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123;// target就是要修饰的类 target.isTestable = true;&#125;MyTestableClass.isTestable // true// 等同于class MyTestableClass &#123; // ...&#125;MyTestableClass = testable(MyTestableClass) || MyTestableClass;// 一个参数不够用，可以在修饰器外面再封装一层函数function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true) // 返回一个函数，用这个函数来修饰MyTestableClassclass MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 修饰方法 1234567891011121314151617181920class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', descriptor);// 类似于Object.defineProperty(Person.prototype, 'name', descriptor); 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升 1234567891011121314151617181920212223var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125;// 等同于@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; Module语法简介 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 import、export命令实现的是静态加载，是在编译阶段加载，而不是运行时再加载，所以效率要比CommonJS 模块的加载方式高12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 严格模式 ES6 的模块自动采用严格模式 ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export命令 export命令用于规定模块的对外接口 123456789101112// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;// 等同于下面的// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; export命令除了输出变量，还可以输出函数或类（class）。 1234567export function multiply(x, y) &#123; return x * y;&#125;;export class Person&#123; ...&#125; 使用as关键字给对外接口重新取名 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123;// v2对外有两个接口名 v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456789101112131415161718192021222324252627282930// 报错export 1;// 报错var m = 1;export m;// 正确写法// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;;// function、class也必须遵守// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); export、import命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() import命令 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块 123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile';// 使用解构赋值获得./profile导出值function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 同export一样，可对导入的变量使用as重新取名 1import &#123; lastName as surname &#125; from './profile'; import命令具有提升效果，会提升到整个模块的头部，首先执行 123foo();import &#123; foo &#125; from 'my_module'; import命令是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 12345678910111213// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; 模块的整体加载 用星号（*）指定一个对象，所有export输出值都加载在这个对象上面。 12345678910111213141516171819// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;// main.js，单独加载import &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14));// main.js，整体加载import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); 用于挂载输出值的对象不可以改写 12345import * as circle from './circle';// 下面两行都是不允许的circle.foo = 'hello';circle.area = function () &#123;&#125;; 注意，直接使用import * as xxx时，是不会导入默认值，会忽略默认值，如果需要同时导入默认值和所有的非默认值需要这么写 1import myDefault,* as myObj from './a' export default 命令 使用export命令时，可以添加default来指定默认输出值，import加载时可用任意的变量名来接收输出值 显然，一个模块只能有一个默认输出，因此export default命令只能使用一次 12345678910111213141516171819202122// export-default.jsexport default function () &#123; console.log('foo');&#125;// import-default.jsimport customName from './export-default';// 这时import命令后面，不使用大括号。customName(); // 'foo'// export default可用在非匿名函数前，加载的时候，视同匿名函数加载。// export-default.jsexport default function foo() &#123; console.log('foo');&#125;// 或者写成function foo() &#123; console.log('foo');&#125;export default foo; 默认输出值，在导入时，不用加{}，非默认导出值需要添加{} 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样 1import _, &#123; each, each as forEach &#125; from 'lodash'; export 与 import 的复合写法 用在一个模块之中，先输入后输出同一个模块 注意，export *命令会忽略模块的default方法1234567891011121314151617181920212223export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;// 模块的接口改名和整体输出，也可以采用这种写法// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module';// 默认接口的写法export &#123; default &#125; from 'foo';// 具名接口改为默认接口的写法export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6;// 默认接口也可以改名为具名接口export &#123; default as es6 &#125; from './someModule'; 模块的继承123456789101112131415// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125;// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125;// 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法(因为后面有自己的默认方法)。然后，上面代码又输出了自定义的e变量和默认方法。 跨模块常量 可以将不同常量放在不同的js文件中，然后集中导入到一个js文件中，并集体输出；使用时只用导入集中的js文件即可12345678910111213141516// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];// constants/index.js，将不同常量导入到一个文件，并到处export &#123;db&#125; from './db';export &#123;users&#125; from './users';// script.js，使用时直接导入集中的文件import &#123;db, users&#125; from './index'; import() import命令是编译时加载，无法做到运行时加载(动态加载)，新提案通过import()函数实现运行时加载 import()返回一个 Promise 对象 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); 场景 123456789101112131415161718192021// 按需加载button.addEventListener('click', event =&gt; &#123; import('./dialogBox.js') .then(dialogBox =&gt; &#123; dialogBox.open(); &#125;) .catch(error =&gt; &#123; /* Error handling */ &#125;)&#125;);// 条件加载if (condition) &#123; import('moduleA').then(...);&#125; else &#123; import('moduleB').then(...);&#125;// 动态的模块路径import(f()).then(...); Module 的加载实现浏览器加载ES6模块 传统方法，加载普通模块 12345678910111213&lt;!-- 页面内嵌的脚本 --&gt;&lt;script type=\"application/javascript\"&gt; // module code&lt;/script&gt;&lt;!-- 外部脚本 --&gt;&lt;script type=\"application/javascript\" src=\"path/to/myModule.js\"&gt;&lt;/script&gt;&lt;!-- defer是“渲染完再执行” --&gt;&lt;script src=\"path/to/myModule.js\" defer&gt;&lt;/script&gt;&lt;!-- async是“下载完就执行” --&gt;&lt;script src=\"path/to/myModule.js\" async&gt;&lt;/script&gt; 浏览器上加载ES6模块 12345&lt;!-- 需要指定type为module，异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了&lt;script&gt;标签的defer属性。 --&gt;&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=\"module\" src=\"foo.js\" defer&gt;&lt;/script&gt; 对于外部的模块脚本（上例是foo.js），有几点需要注意。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。12345678import utils from 'https://example.com/js/utils.js';const x = 1;console.log(x === window.x); //falseconsole.log(this === undefined); // truedelete x; // 句法错误，严格模式禁止删除变量 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。ES6模块输出的变量是实时更新的 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 ES6模块的循环加载 注意，ES6输出的是一个引用 当一个模块已经加载后，不会重复执行12345678910111213141516171819202122// a.js如下import &#123;bar&#125; from './b.js';console.log('a.js');console.log(bar);export let foo = 'foo';// b.jsimport &#123;foo&#125; from './a.js';console.log('b.js');console.log(foo);export let bar = 'bar';// 执行a.js$ babel-node a.jsb.jsundefineda.jsbar// 由于a.js的第一行是加载b.js，所以先执行的是b.js。而b.js的第一行又是加载a.js，这时由于a.js已经开始执行了，所以不会重复执行，而是继续往下执行b.js，所以第一行输出的是b.js。// 接着，b.js要打印变量foo，这时a.js还没执行完，取不到foo的值，导致打印出来是undefined。b.js执行完，开始执行a.js，这时就一切正常了。 ArrayBuffer简介 先做个简单了解，后期用到再补 ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口 这个接口的原始设计目的，与 WebGL 项目有关，与显卡交换数据使用传统文本格式，需要转换效率低下，直接使用二进制交流，效率高 编程风格块级作用域 let 取代 var 123456789'use strict';if (true) &#123; let x = 'hello';&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 在全局环境，不应该设置变量，只应设置常量。建议优先使用const 所有的函数都应该设置为常量123456789101112// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3];const add=(x,y)=&gt;x+y; 字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = \"foobar\";const b = 'foo' + a + 'bar';// acceptableconst c = `foobar`;// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 解构赋值 使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象 多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义 12345678910111213// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写 1234567891011121314151617181920212223var ref = 'some value';// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组 使用扩展运算符（…）拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 函数 立即执行函数可以写成箭头函数的形式 123(() =&gt; &#123; console.log('Welcome to the Internet.');&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 使用默认值语法设置函数参数的默认值 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map 只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class 总是用Class，取代需要prototype的操作； 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块 Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require，使用export取代module.exports。 1234567891011121314151617181920212223242526272829// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from 'moduleA';// commonJS的写法var React = require('react');var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from 'react';class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用 12345678910111213// badconst add=(x,y)=&gt;x+y;const PI=3.14;export add;export default PI;// goodconst add=(x,y)=&gt;x+y;const PI=3.14;export add;export PI; 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。因为import *会忽略模块的默认值 12345// badimport * as myObject from './importModule';// goodimport myObject from './importModule'; 东西很多，先做个大概了解，后期用到再做更加细致的了解。以上。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Deferred_Promise","date":"2017-09-07T12:56:31.000Z","path":"2017/09/07/Deferred-Promise/","text":"在最近项目中经常会遇到异步处理的相关问题，在查阅相关资料后，特在此做一篇笔记。 使用Deferred、Promise解决jQuery中异步相关问题问题 ABC是3个异步请求，现在要求C在AB三个异步请求都成功返回的情况下再执行。这种就比较麻烦，可以尝试设置请求完成状态变量，当AB的请求完成变量都true时再请求C；如果不只3个请求，这种方法就会很糟糕。 ABC是3个异步请求，现在要求ABC3个请求按顺序依次执行，A-&gt;B-&gt;C。这种用传统方法可能就需要用回调嵌套的方法来实现 以上两种情况是在异步中经常遇到的，用传统方法编写，会导致嵌套层次过多，不仅影响可读性，还不易于维护。为了解决这种问题，CommonJs组织制定了异步编程规范Promises/A。这个规范有很多实现，如when.js、ES6的Promise等。今天就借助jQuery的Deferred、Promise对象来做个简单了解。 Promise状态Promise对象存在3种状态 pending(未完成状态) resolved(肯定状态) rejected(否定状态) 这三种状态的转换关系 pending-&gt;resolved pending-&gt;rejected pending-&gt;pending 当转换到resolved或者rejected状态时，状态是无法再发生变化，即下面的状态转换都是不可行的 resolved-&gt;rejected resolved-&gt;pending rejected-&gt;resolved rejected-&gt;pending 创建一个Promise对象在jQuery中Deferred可以理解为Promise的加强版，先不做区分，可以将Deferred当成就是Promise，后面会介绍二者区别。123456789var dfr=$.Deferred();// 创建一个Deferred对象(就是Promise对象)console.log(dfr.state());// 获取当前状态,pendingdfr.resolve();// 将Deferred对象状态改变为resolvedconsole.log(dfr.state());// resolvedvar dfr2=$.Deferred();console.log(dfr2.state());// 获取当前状态,pendingdfr.reject();// 将Deferred对象状态改变为rejectedconsole.log(dfr2.state());// rejected 状态的作用 通过上面的例子，我们可以知道，可以人为的改变Deferred对象的状态。状态不一样有什么用呢？我们可以根据不同的状态进行不同的操作(添加不同的回调函数)。 给Promise对象添加回调添加回调，并触发12345678910111213var dfr=$.Deferred();// 创建Deferred对象dfr.done(function()&#123;// Deferred对象状态变为resolved时的回调 alert('成功');&#125;).fail(function()&#123;// Deferred对象状态变为reject时的回调 alert('失败');&#125;).progress(function()&#123;// Deferred对象状态为pending时的回调 alert('进行中...');&#125;);dfr.notify(); // 触发Deferred对象pending状态的回调dfr.resolve();// 触发Deferred对象resolved状态的回调 通过done()、fail()、progress()给Deferred对象的不同状态分别添加了回调，并通过notify()、resolve触发了响应的回调 传递数据 通过done()、fail()、progress()触发Deferred对象的回调时，可传递一些数据(任何类型)给回调函数12345678910111213var dfr2=$.Deferred();// 创建Deferred对象dfr2.done(function(msg)&#123;// Deferred对象状态变为resolved时的回调 alert(msg+'成功');&#125;).fail(function(msg)&#123;// Deferred对象状态变为reject时的回调 alert(msg+'失败');&#125;).progress(function(msg)&#123;// Deferred对象状态为pending时的回调 alert(msg+'进行中...');&#125;);dfr2.notify('dfr2'); // dfr2进行中...dfr2.reject('dfr2');// dfr2失败 链式调用 done()、fail()、progress()会返回调用者对象Deferred对象，因此可以进行无限的链式调用；可以在done()后再添加done()、fail()、progress()，他们会在对应状态被激活时，依次按照添加顺序调用。12345678910111213141516var dfr=$.Deferred();dfr.done(function()&#123; // 回调1 alert('成功1');&#125;).fail(function()&#123; alert('失败');&#125;).progress(function()&#123; alert('进行中...');&#125;).done(function()&#123;// 回调2 alert('成功2');&#125;);dfr.resolve();// 成功1-&gt;成功2 deferred.always() 通过deferred.always()添加的回调，无论状态是resolved还是rejected都会在最后被调用12345678910111213141516var dfr=$.Deferred();dfr.done(function()&#123;// alert('成功1');&#125;).fail(function()&#123; alert('失败');&#125;).progress(function()&#123; alert('进行中...');&#125;).always(function()&#123; alert('我总会被执行');&#125;);dfr.resolve();// 成功1-&gt;我总会被执行 Deferred对象使用方式1234567891011var dfr = $.Deferred();// 创建一个Deferred对象var task = function(dtd) &#123; setTimeout(function() &#123; console.log('timeOut'); dtd.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dtd;// 返回Deferred对象，供$.when()使用&#125;;$.when(task(dfr)).done(function() &#123; alert('success');// 3s后弹出&#125;); 上面例子由于dfr是全局对象，并且包含改变状态的方法resolve、reject，所以可以在外部提前终止任务 123456789101112var dfr = $.Deferred();// 创建一个Deferred对象var task = function(dtd) &#123; setTimeout(function() &#123; console.log('timeOut'); dtd.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dtd;// 返回Deferred对象，供$.when()使用&#125;;$.when(task(dfr)).done(function() &#123; alert('success');// 立即弹出&#125;);dfr.resolve();// 外部resolve后会立即执行done 防止外部终止，可以将全局的dfr放到函数内部 123456789101112var task = function() &#123; var dfr = $.Deferred();// 创建一个Deferred对象 setTimeout(function() &#123; console.log('timeOut'); dfr.resolve(); // 异步任务结束，手动resolve &#125;, 3000); return dfr;// 返回Deferred对象，供$.when()使用&#125;;$.when(task()).done(function() &#123; alert('success');// 立即弹出&#125;);dfr.resolve();// 无法调用 jQuery中Deferred和Promise的区别 Deferred对象可以理解为Promise对象的加强版。 Deferred对象包含改变状态的方法，如dfr.resolve()、dfr.reject()、dfr.notify() Promise对象则不包含以上方法； 要想改变状态必须在Deferred对象上调用相关方法，Promise对象没有相关方法。 通过deferred.promise()可以将Deferred对象转换为Promise对象 在ajax中使用Promiseajax和Promise的关系 在jQuery1.5之前$.ajax()返回的是一个jqXHR对象，1.5之后返回的是一个类Promise对象，它在原先的jqXHR对象基础上又添加一些Promise方法，因此我们能在$.ajax()之后链式调用Promise相关方法； 注意返回的是一个类Promise对象，因此它不包含改变状态的相关方法； 改变相关状态由ajax内部完成，无需手动调用相关方法(也无法调用)；1234567891011121314151617// 老的ajax写法 $.ajax(&#123; url: \"a.html\", success: function()&#123; alert(\"成功\"); &#125;, error:function()&#123; alert(\"错误\"); &#125; &#125;); // 使用promise后的写法 $.ajax(\"test.html\") .done(function()&#123;&#125;) .fail(function()&#123;&#125;) .done(function()&#123;&#125;) .fail(function()&#123;&#125;); 解决问题1 问题1要求C在AB都执行完后再执行。即A&amp;&amp;B-&gt;C；这时候就需要使用jQuery提供的$.when()函数。$.when()返回一个Promise对象。所以可以调用done、fail、progress等函数 12345678$.when($.ajax(url1),$.ajax(url2)).done(function()&#123; console.log('url1、url2都请求成功'); $.ajax(url3)&#125;).fail(function()&#123; console.log('url1、url2有一个或者两个没请求成功');&#125;); $.when()实现了多个ajax请求完成后再执行某些操作；即实现了A&amp;&amp;B-&gt;C的效果 解决问题2 问题2的要求是ABC3个异步请求顺序执行。传统写法可能是 1234567891011121314$.ajax(&#123; url:'a.json', success:function()&#123; $.ajax(&#123; url:'b.json', success:function()&#123; $.ajax(&#123; url:'c.json', success:function()&#123; console.log('gg'); &#125; &#125; &#125;&#125;); 可读性很差，还不方便维护。为解决问题2需要使用到jQuery提供的Deferred.then()方法； then方法可以传入3个回调，分别是resolved、rejected、pending状态的回调； 123456789101112131415161718192021222324252627function success(data) &#123; alert(\"success data = \" + data); &#125; function fail(data) &#123; alert(\"fail data = \" + data); &#125; function progress(data) &#123; alert(\"progress data = \" + data); &#125; var deferred = $.Deferred(); // 一起注册回调 deferred.then(success, fail, progress); // 分别注册回调 deferred.done(success); deferred.fail(fail); deferred.progress(progress); deferred.notify(\"10%\"); deferred.resolve(\"ok\"); 其实在执行then方法后将返回一个新的Promise对象 可以在后面无限级联调用相关Promise方法.then().then().done().fail()…. 这就意味着在then后就无法在返回对象(返回的是Promise对象)上手动改变状态了。 必须在原先的Deferred对象上调用方法改变状态12345678910111213141516171819202122232425function success(data) &#123; alert(\"success data = \" + data); &#125; function fail(data) &#123; alert(\"fail data = \" + data); &#125; function progress(data) &#123; alert(\"progress data = \" + data); &#125; var dfr=$.Deferred();var pro=dfr.then(success,fail,progress);console.log(dfr===pro);// false// 没有改变状态的方法console.log('resolve' in pro); // falseconsole.log('reject' in pro); // falseconsole.log('notify' in pro); // false// 只能在原先的Deferred对象调用相关方法dfr.resolve('resolved'); // success data = resolved 其实then()中传入的不是回调函数，官方说法又叫做过滤函数；前面说过Deferred对象在调用改变状态方法时，可以传递数据，其实通过then注册的回调可以对数据进行过滤，然后通过return将数据传递给下一个回调函数(done、fail、progress)，如果下一个回调函数是通过then注册的，则可以继续对数据进行过滤，并传递给下一个对应状态的回调函数； 我们知道deferred.resolve()、deferred.reject()、deferred.notify()可以指定参数值，这个参数会传递给相应状态下的回调函数。 如果我们使用的是done()、fail()、progress()注册的回调函数，那么某个状态下的所有回调函数得到的都是相同参数。 不是通过then注册的回调函数，无法对数据过滤并通过return传递给下一个回调，他们得到的都是相同值，可看下面例子 1234567891011121314var dfr = $.Deferred();dfr.done(function(type) &#123; console.log(type);// resolved return type + 'first';&#125;).done(function(type) &#123; console.log(type);// resolved return type + 'last';&#125;).done(function(type) &#123; console.log(type);// resolved&#125;);dfr.resolve('resolved'); 但是如果我们使用了then()注册回调函数，那么第一回调函数的返回值将作为第二个回调函数的参数，同样的第二个函数的返回值是第三个回调函数的参数。 12345678910111213141516var deferred = $.Deferred(); // then()返回的是一个新Promise对象 //then注册的回调函数的返回值将作为这个新Promise的参数 var then_ret = deferred.then(function(data)&#123; alert(\"data=\"+data);//5 对数据进行过滤 return 2 * data; // 并通过return 传递给下一个done&#125;); alert(then_ret == deferred);//false then_ret.done(function(data)&#123; alert(\"data=\"+data);//10 &#125;); deferred.resolve( 5 ); 如果仔细观察，会发现在上面例子中，我们返回的是普通值，如果我们返回的是Deferred或者Promise对象，它会将返回的Deferred、Promise对象的状态和返回值传递给下一个回调函数，做为其触发依据和参数。可以用这种方法解决问题2 12345678910var promise1 = $.ajax(url1); var promise2 = promise1.then(function(data)&#123; return $.ajax(url2, &#123; \"data\": data &#125;);// 返回一个promise，它的状态将决定触发promise2.then中的哪个回调，它的返回值将传递给对应的回调函数&#125;); var promise3 = promise2.then(function(data)&#123; return $.ajax(url3);// 返回一个promise，它的状态将决定触发promise3中的哪个回调，它的返回值将传递给对应的回调函数&#125;); promise3.done(function(data)&#123; console.log(data);&#125;); 这样其实我们可以得到一个范式，处理有依赖关系的异步请求时，可以.then().then().done().fail()，通过then中的回调(过滤)函数，对数据进行加工，最后交给不是通过then注册的done或者fail来进行最后处理；done其实就预示着对传过来的数据不进行加工了； 总结 jQuery中的Deferred、Promise对象主要用来解决异步任务中嵌套问题 Deferred可以理解为Promise对象的加强版 Deferred对象拥有方法resolve、reject、notify来手动改变状态 Promise对象无法手动改变状态 deferred.promise()可以将一个Deferred对象转换成Promise对象 jQuery中异步任务返回的都是Promise对象或者类Promise对象(ajax返回的)，它们都无法手动改变状态，它们状态的改变是jQuery在内部自动完成的 $.Deferred()返回一个Deferred对象 deferred.done、deferred.fail、deferred.progress用来定义Deferred对象状态对应的回调函数 deferred.always()来用定义无论成功还是失败都会调用回调函数 deferred.resolve()、deferred.reject()手动改变Deferred对象的状态 改变状态时，可以传递数据给回调函数 deferred.resolve(‘msg’) 防止改变状态方法在异步任务外调用 可将Deferred对象定义为异步任务内的局部变量 可以使用deferred.promise()转换成Promise对象 deferred.notify()用来触发deferred.progress定义的回调函数，实际可以用来完成进度条效果 deferred.then()会返回一个新的promise对象 then中定义的回调函数可以理解为过滤函数，可对resolve、reject中传递的数据进行加工、过滤，然后通过return传递给下一个回调函数 如果return的是Deferred或者Promise对象，它会将返回的Deferred、Promise对象的状态和返回值传递给下一个回调函数，做为其触发依据和参数。 A&amp;&amp;B-&gt;C类型异步任务可以使用$.when()来解决；见上面例子 范式123456$.when($.ajax(url1),$.ajax(url2)).done(function()&#123; $.ajax(url3);&#125;).fail(function()&#123; console.log('出错');); A-&gt;B-&gt;C类型异步任务可以使用Promise对象的then()来解决；见上面例子 范式12345678910111213$.ajax(url1).then(function(url1Data)&#123; return $.ajax(url2);&#125;).then(function(url2Data)&#123; return $.ajax(url3);&#125;).done(function(url3Data)&#123; // 最终成功处理&#125;).fail(function(url3Data)&#123; // 最终失败处理&#125;);","tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"Bootstrap-table_API","date":"2017-09-07T12:44:29.000Z","path":"2017/09/07/Bootstrap-table-API/","text":"最近在项目中需要使用到表格控件，调研几个常用的表格控件(jquery-dataTable、list.js、jqGrid、Bootstrap-table)后，决定使用Bootstrap-table，特意将常用API记录下来，以备后用。源码可在这https://github.com/BryanAdamss/SourceSave/tree/master/Practice 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入bootstrap样式 --&gt; &lt;link rel=\"stylesheet\" href=\"./vendors/bootstrap-3.3.7-dist/css/bootstrap.min.css\"&gt; &lt;!-- 引入bootstrap-table样式 --&gt; &lt;link rel=\"stylesheet\" href=\"./vendors/bootstrap-table/bootstrap-table.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"btn-group hidden-xs\" id=\"js_caremaTableToolBar\" role=\"group\"&gt; &lt;a href=\"#\" class=\"btn btn-outline btn-default\"&gt;&lt;i class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;table id=\"js_caremaTable\" data-height=\"400\" data-icon-size=\"outline\" data-striped=\"true\"&gt; &lt;/table&gt; &lt;script src=\"./js/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 引入bootstrap.js --&gt; &lt;script src=\"./vendors/bootstrap-3.3.7-dist/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap-table主js --&gt; &lt;script src=\"./vendors/bootstrap-table/bootstrap-table.js\"&gt;&lt;/script&gt; &lt;!-- bootstrap-table本地化文件 --&gt; &lt;script src=\"./vendors/bootstrap-table/locale/bootstrap-table-zh-CN.js\"&gt;&lt;/script&gt; &lt;script&gt; var caremaTable = $('#js_caremaTable').bootstrapTable(&#123; url: './json/bootstrap_table_test.json', method: 'get', // 请求方式 uniqueId: 'id', // 每一行的唯一id，一般设置为主键列，此处用数据中的'id'做为每一行的唯一标识；可用在一些方法中如removeByUniqueId，不设置uniqueId时，调用此类方法会出错 search: true, // 启用搜索 sortable: true, // 全局配置，是否启用列排序；若为false，即使列上设置了sortable:true，列也无法进行排序 pagination: true, // 启用分页 sidePagination: 'client', // 设置在哪里进行分页，可选值为 'client' 或者 'server'。设置 'server'时，必须设置 服务器数据地址（url）或者重写ajax方法 showRefresh: true, // 启用刷新 showColumns: true, // 启用内容列下拉框 showToggle: true, // 是否显示 切换试图（table/card）按钮 showPaginationSwitch: true, // 是否显示切换分页按钮 toolbar: '#js_caremaTableToolBar', // 工具栏 cache: true, // 设置为 false 禁用 AJAX 数据缓存 singleSelect: false, // 设置True 将禁止radio、checkbox多选，并隐藏选择全部按钮 class: 'cgh_dfjakdjfklasjdfklajslkdfjlkaf', columns: [&#123; checkbox: true, // 此列为checkbox &#125;, // &#123; // radio: true // 此列为radio // &#125;, &#123; field: 'id', title: '编号', sortable: true, // 此列表头点击，可进行排序，前提必须是表格的sortable为true titleTooltip: '点击可进行排序', // 悬停tooltip width: '100px' &#125;, &#123; field: 'name', title: '名称', &#125;, &#123; field: 'place', title: '预置位' &#125;, &#123; field: 'userName', title: '连接用户名' &#125;, &#123; field: 'password', title: '连接密码' &#125;, &#123; field: 'channel', title: '远程频道' &#125;, &#123; field: 'lng', title: '经度' &#125;, &#123; field: 'lat', title: '纬度', &#125;, &#123; title: '操作', formatter: function(value, row, index) &#123; return '&lt;a href=\"javascript:;\" class=\"text-danger m-l js_delete\"&gt;删除&lt;/a&gt;' &#125;, events: &#123; // 按钮点击事件 'click .js_delete': function(e, value, row, index) &#123; console.log(e, value, row, index); if (confirm('确定删除此行吗？')) &#123; caremaTable.bootstrapTable('removeByUniqueId', row.id); // 当表格配置了uniqueId: 'id'时，可通过removeByUniqueId来删除当前行 // caremaTable.bootstrapTable('remove', &#123; // 删除name列值为'测试0'的行 // field: 'name', // values: ['测试0'] // 注意values必须是一个数组 // &#125;); // caremaTable.bootstrapTable('remove', &#123; // 删除当前行，由于id在创建数据时是唯一的，所以通过点击获取row中的id数据，然后删除id列值为row.id的行；不过还是建议通过配置uniqueId然后通过removeByUniqueId方法来删除 // field: 'id', // values: [row.id] // &#125;); &#125; &#125; &#125; &#125; ], onCheck: function(row) &#123; // 单独选中某一个check时触发 console.log('onCheck', row); &#125;, onUncheck: function(row) &#123; console.log('onUncheck', row); // uncheck某一个check时触发 &#125;, onCheckAll: function(rows) &#123; console.log('onCheckAll', rows); // 全选check时触发 &#125;, onUncheckAll: function(rows) &#123; console.log('onUncheckAll', rows); // uncheck所有check时触发 &#125; &#125;); // 常用方法 // 调用方法的语法：$('#table').bootstrapTable('method', parameter); // 全部方法请参阅http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/#方法 // caremaTable.bootstrapTable('getSelections'); // 返回所选的行，当没有选择任何行的时候返回一个空数组。 // caremaTable.bootstrapTable('getAllSelections'); // 返回所有选择的行，包括搜索过滤前的，当没有选择任何行的时候返回一个空数组。 // caremaTable.bootstrapTable('getData'); // 获取当前加载的数据。 // caremaTable.bootstrapTable('getRowByUniqueId', 3); // 根据 uniqueId 获取行数据。 // caremaTable.bootstrapTable('load', data); // 加载数据到表格中，旧数据会被替换。 // caremaTable.bootstrapTable('showAllColumns'); // 显示所有列。 // caremaTable.bootstrapTable('hideAllColumns'); // 隐藏所有列。 // caremaTable.bootstrapTable('append'); // 添加数据到表格在现有数据之后。 // caremaTable.bootstrapTable('prepend'); // 插入数据到表格在现有数据之前。 // caremaTable.bootstrapTable('remove', &#123; field: 'id', values: someArr &#125;); // 从表格中删除数据，包括两个参数： field: 需要删除的行的 field 名称。values: 需要删除的行的值，类型为数组。 // caremaTable.bootstrapTable('removeAll'); // 删除表格所有数据。 // caremaTable.bootstrapTable('removeByUniqueId'); // 根据 uniqueId 删除指定的行。 // caremaTable.bootstrapTable('insertRow', &#123; index: 1, row: row &#125;); // 插入新行，参数包括：index: 要插入的行的 index。row: 行的数据，Object 对象。 // caremaTable.bootstrapTable('updateRow', &#123; index: 1, row: row &#125;); // 更新指定的行，参数包括：index: 要更新的行的 index。row: 行的数据，Object 对象。 // caremaTable.bootstrapTable('showRow', &#123; index: 1 &#125;); // 显示指定的行，参数包括：index: 要更新的行的 index 或者 uniqueId。isIdField: 指定 index 是否为 uniqueid。 // caremaTable.bootstrapTable('hideRow', &#123; index: 1 &#125;); // 隐藏指定的行，参数包括：index: 要更新的行的 index 或者 uniqueId。isIdField: 指定 index 是否为 uniqueid。 // caremaTable.bootstrapTable('checkAll'); // 选中所有行 // caremaTable.bootstrapTable('uncheckAll'); // uncheck所有行 // caremaTable.bootstrapTable('check', 0); // 选中第一行 // caremaTable.bootstrapTable('uncheck', 0); // 取消选中第一行 // caremaTable.bootstrapTable('checkBy', &#123; field: \"field_name\", values: [\"value1\", \"value2\", \"value3\"] &#125;); // 选中field_name为value1、value2、value3的行 // caremaTable.bootstrapTable('uncheckBy', &#123; field: \"field_name\", values: [\"value1\", \"value2\", \"value3\"] &#125;); // 取消选中field_name为value1、value2、value3的行 $(window).resize(function() &#123; // 防止thead和tbody在缩放情况下不对齐 caremaTable.bootstrapTable('resetView'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"表格","slug":"表格","permalink":"http://yoursite.com/tags/表格/"}]},{"title":"type-existence","date":"2017-08-04T08:08:31.000Z","path":"2017/08/04/type-existence/","text":"本来在《编写可维护性的javascript》中已经做过总结，但最近在使用上又出现一点问题，所以推翻以前的单独写篇关于类型检测和存在性检测的文章 类型检测和存在性检测必备知识点 哪些值会被转成false “”、0、NaN、false、null、undefined会在期待布尔值的地方被转成false; 非上面提及的值都会被转成true； 注意空对象(没有任何属性/方法的对象)也会视为true1234var a=&#123;&#125;;if(a)&#123; console.log(true);// true&#125; 声明和赋值 未声明(更未赋值)的变量 直接使用，会报错 1console.log(b);// Uncaught ReferenceError: b is not defined 如果通过typeof b来使用，则不会报错；因为typeof存在一个特殊的安全防范机制； 已声明未赋值的变量 会有默认值undefined123var a;console.log(a===undefined);// trueconsole.log(typeof a);// 'undefined' 注意:当未声明的变量使用typeof检测时，并不会报错，而且返回&#39;undefined&#39;；因为typeof存在一个特殊的安全防范机制； 1console.log(typeof b);// 'undefined'，并没有报错 总结 未声明和已声明未赋值的变量使用typeof检测时，都会返回&#39;undefined&#39; 访问对象上不存在的属性/方法时，并不会报错，而是返回一个undefined 1234var obj=&#123; a:3&#125;;console.log(obj.b);// undefined 类型检测-&gt;(判断值的类型) 首先变量是没有类型的，类型本质指的是变量持有的值的类型，一般说的变量类型，实际指的是变量持有的值的类型 判断类型主要用来，检测输入的参数是否为想要的类型 12345function test(fn)&#123; if(typeof fn==='function')&#123; // xxxxx &#125;&#125; 一般值 string、number、boolean、undefined-&gt;typeof来判断 null一般不用做类型检测，只有在变量是一个可预期的null值时，才用来判断1234var obj=null;if(obj===null)&#123; // xxx&#125; 引用值 自定义、非数组、非函数-&gt;使用obj instanceof constructor 12345678function People(name)&#123; this.name=name;&#125;var p=new People();console.log(p instanceof People);// truevar date=new Date();console.log(date instanceof Date);// true 函数-&gt;typeof 12function fn()&#123;&#125;console.log(typeof fn==='function');// 'function' 数组 es5的isArray 12var arr=[];console.log(Array.isArray(arr));// true Object.prototype.call(arr); 12var arr=[];console.log(Object.prototype.toString.call(arr)==='[object Array]'); 存在性 常用检测存在性的不足 12345var obj=&#123; b:0&#125;;if(b)&#123;&#125;// 如果b存在，则xxx；当b为\"\",0,NaN,false,null,undefined时，就无法检测；同理b&amp;&amp;b()也会出现类似问题，所以只有在明确知道要检测的值不会是\"\",0,NaN,false,null,undefined中的一种时才能用 变量是否存在(是否已经声明) 全局变量的存在性 1console.log('a' in window);// false;判断变量a在全局环境下是否声明 局部变量的存在性 局部变量无法用in判断，只能退而求其次用typeof，typeof无法准确判断出是未声明还是已声明未赋值，如下123var a;console.log(typeof a==='undefined');// true;a已经声明但未赋值 console.log(typeof b==='undefined');// true;b没有声明 对象的属性是否存在 一般属性-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty123456var obj_a=&#123; test:'测试'&#125;;console.log('test' in obj_a);// trueconsole.log('toString' in obj_a);// true，能检测到原型链上的方法console.log(obj_a.hasOwnProperty('toString'));//false,obj_a并没有实例属性(方法)`toString`，`toString`存在于其原型对象上，hasOwnProperty无法检测到","tags":[{"name":"类型检测","slug":"类型检测","permalink":"http://yoursite.com/tags/类型检测/"},{"name":"存在性","slug":"存在性","permalink":"http://yoursite.com/tags/存在性/"}]},{"title":"Vue-guide","date":"2017-08-01T02:35:14.000Z","path":"2017/08/01/Vue-guide/","text":"VueJs官网教程学习笔记安装 兼容性:不支持IE8及以下版本浏览器；因为使用了IE8无法模拟的Object.defineProperty 开发版本-&gt;包含了完整的警告和调试模式 CLI-&gt;可以构建一个完整的vue项目 介绍 是一套构建用户界面的框架，本身只关注视图层，但可以和第三方库结合来构建复杂的spa Vue实例 构造器 Vue(选项对象) 123var vm = new Vue(&#123; // 选项&#125;); 可扩展Vue构造器 12345var MyComponent = Vue.extend(&#123; // 扩展选项&#125;)// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建var myComponentInstance = new MyComponent() 属性与方法 每个vue实例会代理其data对象里有所有属性，这些属性都是响应式的； $开头的为vue实例属性/方法 不要在实例属性或者回调函数中使用箭头函数，箭头函数会绑定上级context，this预期将不会是vue实例 实例生命周期 生命周期钩子-&gt;自定义事件 可以在选项对象中进行配置 生命周期钩子中的this指向实例化后的对象12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)// -&gt; \"a is: 1\" 模板语法插值 文本 绑定文本 v-text 会将对应表达式求值后，当做字符串替换元素内的内容 {{ msg }} msg 改变时，视图也会发生改变;是v-text的简写，求值后，当做字符串替换 {{ }}处的内容;{{ }}中可以使用表达式，但不能使用语句，流程控制也不能用(使用三元表达式代替) {{ }}形式会和ng中的一样，存在首次加载闪烁的问题，如果是首屏内容，可以尝试使用v-text绑定 一次性插值 在元素上使用v-once指令，这样元素内部的所有数据绑定，只会显示第一次绑定时的数据，当数据发生变化时，它们都不会得到更新，可以用在不会发生改变的数据的绑定；1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;,&#123;&#123; test &#125;&#125;&lt;/span&gt; 纯html v-html {{ }}和v-text会将数据当做纯文本处理，不会对其做html解析;v-html会将对应表达表达式当做html解析后，输出到元素内 属性(特性) v-bind 主要用来绑定特性 v-bind:title=&quot;test&quot; 将test绑定到元素的title特性上； 缩写 v-bind:href=&quot;url&quot;-&gt;:href=&quot;url&quot; 指令 指令是v-开头(ng中以ng-开头)，它的预期是一个单一js表达式(v-for除外) 可以带参数 12&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt; 修饰符 指令后通过添加.来附加修饰符（Modifiers），用于指出一个指令应该以特殊方式绑定。1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;// submit时阻止默认行为 过滤器 vue2.0中没有预定义的过滤器了，所有filter都需要自定义 主要用在{{ }}和v-bind中，达到格式化输出文本的作用 可级联使用 可带参数1234567891011121314151617181920//使用&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;// 定义new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)// 级联使用&#123;&#123; message | filterA | filterB &#125;&#125;// 带参数&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;// 这里，filterA 是个拥有三个参数的函数。message 的值将会作为第一个参数传入。字符串 'arg1' 将作为第二个参数传给 filterA，表达式 arg2 的值将作为第三个参数。 缩写 v-bind 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on 1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 计算属性计算属性 可以将计算属性当成data中属性添加了一个getter方法，并返回一个新属性，但新属性依赖data中的属性； 123456789101112131415// jsvar vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` 指向vm实例，由于vm实例代理了所有data中的属性，所以this.message能被访问到 return this.message.split('').reverse().join('') &#125; &#125;&#125;);// 当data中的message发生变化时，reversedMessage也会重新计算 计算属性vsMethods 1&lt;p&gt;Reversed message: \"&#123;&#123; reversedMessage() &#125;&#125;\"&lt;/p&gt; 123456methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125;// 这样也能实现反转的效果 不同点 计算属性是基于它们的依赖进行缓存的；如上面计算属性的例子，只要data中的message没有发生变化，computed中的reversedMessage都不会重新计算，每次访问reversedMessage都将会是之前缓存的数据； methods则不存在缓存一说，如上面methods例子，只要`Reversed message: \"{{ reversedMessage() }}\"`需要重新渲染，reversedMessage就会被重新调用并计算一次 计算setter 计算属性默认只有getter，可以提供setter方法12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... watch 主要用来观测数据的变化，并进行一系列的操作 1234567&lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;&lt;!-- is able to remain small by not reinventing them. This also --&gt;&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;&lt;script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 question 发生改变，这个函数就会运行 question: function (newQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // ajax请求直到用户输入完毕才会发出 // 学习更多关于 _.debounce function (and its cousin // _.throttle), 参考: https://lodash.com/docs#debounce getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // 这是我们为用户停止输入等待的毫秒数 500 ) &#125;&#125;)&lt;/script&gt; 什么时候用computed、methods、watch computed主要用在根据原有属性，进行计算，返回新属性的操作；即适合用在对数据(属性)的set和get上 methods主要用来编写一些通用，没有什么依赖的方法。 watch主要用来观测数据(属性)的变化，当变化时进行一系列操作（异步操作或开销较大的操作） 总结 computed适合用来对数据进行set、get watch适合用来在数据变化时，进行大开销的操作 methods 用来编写通用的方法 Class与Style绑定绑定 HTML Class类似ng-class 对象语法 传一个对象，以动态切换class 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt;// isActive为true时，则添加active样式类，为false则去除 可以传多个属性，进行动态切换class；并v-bind:class可以和普通class属性共存 123&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 可以直接绑定data里的一个对象 12345678&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;// jsdata: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 也可以绑定一个computed里的对象 1234567891011121314&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;// jsdata: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal', &#125; &#125;&#125; 数组语法 可以把数组传递给v-bind:class，以应用一个class列表 123456&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;// jsdata: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 可以在数组中使用条件表达式 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt; 可以在数组中使用对象语法 1&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt; 绑定内联样式类似ng-style 对象语法 直接绑定一个对象，CSS属性名用驼峰式(camelCase) 123456&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;// jsdata: &#123; activeColor: 'red', fontSize: 30&#125; 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; 多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值1&lt;div :style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt; 条件渲染类似ng-if v-if 条件为true时，则渲染，将元素添加到DOM中，为false，则将其从dom中删除 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; 条件渲染一组 可以将需要条件渲染的元素放到&lt;template&gt;元素中，然后用v-if条件渲染12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以使用v-else指令来表示v-if的”else块” 123456&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else元素必须紧跟在v-if或者v-else-if元素的后面——否则它将不会被识别 v-else-if 充当”else if块”；可链式调用 123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 必须紧跟在 v-if 或者 v-else-if 元素之后 用 key 管理可复用的元素 默认情况下，vue会尽可能的高效渲染元素，通常会复用已有元素而不是从头开始渲染。 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt;// 这里的input会被复用，并不会因为if和else而渲染两个，只是改变placeholder，这样效率更高 有时，我们就是需要渲染两个，这是就需要使用key；如上面例子，为这两个input分别添加一个唯一的key值时，切换时，vue就不会复用他们，而是重新渲染一个 123456789&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt;// 注意, &lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性。 v-show 通过切换元素的display属性，元素会一直保留在DOM中，并不会因为为false，就把元素从DOM中删除，这点和v-if不同 v-if和v-show v-if是通过增加、删除元素来达到显示/隐藏 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show通过css切换(display属性)来显示/隐藏 v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 v-if和v-for一起使用 v-for 具有比 v-if 更高的优先级；先循环，再判断显示隐藏 列表渲染v-for 数组迭代 12345678910111213141516&lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;); 渲染多个元素块-&gt;使用&lt;template&gt;包裹 123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 对象迭代 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。1234567891011121314&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt;// jsnew Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;); 整数迭代 1234&lt;div&gt; &lt;!-- span会重复10次 --&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; v-for和v-if 当它们处于同一节点， v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。相当于在for循环中，再用if判断； 123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 如果想条件判断了再循环，可以先if再for 12345&lt;ul v-if=\"shouldRenderTodos\"&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt; key vue默认会采取”就地复用”的策略,如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。 数组更新检测 变异方法 会改变原数组的方法都为变异方法push()、pop()、shift()、unshift()、splice()、sort()、reverse()；所有变异方法(会改变原数组的方法)都会触发更新检测,若发现数组有变化，则会更新依赖它的地方 重塑数组 不会改变原数组的方法为非变异方法，非变异方法会返回一个新的数组；filter(), concat(), slice()都是非变异方法；当使用新返回的数组替换原先的数组时(重塑数组)，不用担心vue会丢弃现有DOM重新渲染，vue会智能的复用DOM元素，123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;); 注意 由于js的限制，vue不能检测下面变动的数组，将不会触发更新 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如： vm.items.length = newLength 解决方法 第一种问题，可以使用Vue.set或者splice方法 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// splice方法example1.items.splice(indexOfItem, 1, newValue) 第二种问题可以使用splice 1example1.items.splice(newLength) 显示过滤/排序结果 我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。123456789101112&lt;li v-for=\"n in evenNumbers\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;// jsdata: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 事件处理器监听事件 v-on 使用v-on监听事件 1234&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; 缩写 v-on:click=&quot;xxx&quot;-&gt;@click=&quot;xxx&quot; 方法事件处理器 为事件指定一个处理函数123456789101112131415161718192021222324&lt;div id=\"example-2\"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt;// jsvar example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用 JavaScript 直接调用方法example2.greet() // -&gt; 'Hello Vue.js!' 内联处理器方法 直接将处理逻辑写在v-on:click=之后 1234&lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; 传递event给内联处理器需要使用$event 1234567891011&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt;// jsmethods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 事件修饰符 事件中经常需要调用event.preventDefault() 或 event.stopPropagation()，为了简化操作，也为了让处理函数中只有业务逻辑没有事件相关细节，所以vue在v-on:上添加修饰符 .stop,.prevent,.capture,.self,.once 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。 键值修饰符 Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 123456&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 按键别名 .enter,.tab,.delete(捕获“删除”和“退格”键),.esc,.space,.up,.down,.left,.right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名12// 可以使用 v-on:keyup.f1Vue.config.keyCodes.f1 = 112 修饰键 .ctrl,.alt,.shift,.meta 1234&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 滑鼠按键修饰符 .left,.right,.middle 表单控件绑定基础用法 v-model v-model可以实现表单控件的双向绑定；它会根据控件类型自动选取正确的方法来更新元素；类似ng-model v-model会忽略所有表单元素的value、checked、selected特性的初始值。因为它会选择Vue实例数据来作为具体的值。应该通过data选项声明初始值。 v-model在中文输入(IME)时不会更新，可以监听input事件 简单的表单 12345678&lt;!-- 文本 --&gt;&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;!-- 多行文本 --&gt;&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=\"white-space: pre-line\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=\"message\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt;&lt;!-- 在文本区域插值( &lt;textarea&gt;&lt;/textarea&gt; ) 并不会生效，应用 v-model 来代替 --&gt; 复选框 单个复选框，逻辑值 12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，v-model需要绑定到同一个数组上 123456789101112131415&lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;&lt;label for=\"john\"&gt;John&lt;/label&gt;&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;); 单选按钮 同一组，v-model需要绑定到同一个数组上12345678910111213141516&lt;div id=\"example-4\"&gt; &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;); select 单选 12345678910&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// 如果 v-model 表达初始的值不匹配任何的选项，&lt;select&gt; 元素就会以”未选中”的状态渲染。在 iOS 中，这会使用户无法选择第一个选项，因为这样的情况下，iOS 不会引发 change 事件。因此，像以上提供 disabled 选项是建议的做法。 多选列表（绑定到一个数组） 12345678910111213141516&lt;div id=\"example-6\"&gt; &lt;select v-model=\"selected\" multiple style=\"width: 50px\"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;// jsnew Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;); 动态选项(使用v-for渲染) 123456789101112131415161718&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;// jsnew Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;); 绑定value 对于单选按钮，勾选框及选择列表选项， v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）;但有时我们想绑定value到Vue实例的一个动态属性上 复选框 123456&lt;input type=\"checkbox\" v-model=\"toggle\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"&gt;// 当选中时vm.toggle === vm.a// 当没有选中时vm.toggle === vm.b 单选按钮 123&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt;// 当选中时vm.pick === vm.a select 1234567&lt;select v-model=\"selected\"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt;// 当选中时typeof vm.selected // -&gt; 'object'vm.selected.number // -&gt; 123 v-model的修饰符 .lazy在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步 12&lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; .number如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值 1&lt;input v-model.number=\"age\" type=\"number\"&gt; .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入 1&lt;input v-model.trim=\"msg\"&gt; 组件vue中的组件很类似ng1中的directive，通过自定义的html元素扩展功能 使用组件 注册 全局注册 123456789101112131415161718// Vue.component('组件名',选项对象 );// 选项对象和new Vue()中的几乎一样，只有个别属性使用不一样；//组件名建议使用kebab-case(短横线隔开式)连接，不要使用camelCased(驼峰式)，因为html特性不区分大小写，类似ng1中的directive命名，为方便，同意使用kebab-case形式// Vue.component()；不存在类似函数的声明提升机制，所以全局组件必须在根实例之前注册&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 注册-&gt;在创建根实例之前注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' // template必须只有一个跟节点，类似ng1&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;);// 渲染为&lt;div id=\"example\"&gt; &lt;div&gt;A custom component!&lt;/div&gt; // vue中自定义元素将直接被替换，类似ng1中定义指令时配置了replace:true&lt;/div&gt; 局部注册 通过使用组件选项对象中的components来注册，让其仅在一个实例/组件的作用域中可用12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;;new Vue(&#123; el:'#test', components: &#123; // &lt;my-component&gt; 将只在父模板可用(#test实例的范围中使用) 'my-component': Child &#125;&#125;); is 在现有html上添加功能，类似ng1指令中的restrict:A-&gt;因为html的限制，某些标签下只能出现特定的标签，出现其他标签视为无效，如select下只能是option；所以变通的方法是采用is特性 12345678// 无效&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt;// 有效&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 下来源之一的字符串模板，此限制将不适用： &lt;script type=&quot;text/x-template&quot;&gt; JavaScript 内联模版字符串 .vue组件 data必须是函数 通过 Vue 构造器传入的各种选项大多数都可以在组件里用。data是一个例外，它必须是函数，若不是函数，Vue将发出警告 如果通过data函数返回一个对象(引用值)，那么注册的所有组件都将共用这个对象1234567891011121314151617&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;var data = &#123; counter: 0 &#125;;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们返回给每个组件的实例的却引用了同一个data对象 data: function () &#123; return data &#125;&#125;);new Vue(&#123; el: '#example-2'&#125;); 父子组件如何通信 props down, events up; 父组件通过子组件的props接口，将数据传递给子组件；子组件通过事件的形式给父组件发送消息 proprs 组件期望获得的数据，有点类似ng1指令中的scope属性 123456789Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像“this.message”这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;);// 通过child组件的message接口将数据传入&lt;child message=\"hello!\"&gt;&lt;/child&gt; 动态prop 在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件 12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 用v-bind绑定的数据发生发生变化时，会将变化传导到子组件 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;child message='纯文本'&gt;&lt;/child&gt; &lt;child message='test1'&gt;&lt;/child&gt; &lt;child message='test2'&gt;&lt;/child&gt; &lt;child v-bind:message='test2'&gt;&lt;/child&gt;&lt;/div&gt;&lt;button&gt;点击&lt;/button&gt;var vm = new Vue(&#123; el: '#app', data: &#123; test1: '我是变量1', test2: '我是变量2' &#125;, components: &#123; 'child': &#123; props: ['message'], template: '&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;' &#125; &#125;&#125;);document.querySelector('button').onclick = function() &#123; vm.test2 = '我是变量2，我被改变了'; console.log(vm);&#125;; 不要使用字面量形式传递数值，使用v-bind将其转化成表达式；下面例子，因为它是一个字面 prop，它的值是字符串 “1” 而不是 number。如果想传递一个实际的 number，需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算 1234&lt;!-- 传递了一个字符串 \"1\" --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt;&lt;!-- 传递实际的 number --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; 单向数据流 prop是单向的，只能父传递到子，反之则不行 父组件更新时，子组件的所有prop也将得到更新 遇到下面情况，可能需要修改prop中的数据 prop 作为初始值传入后，子组件想把它当作局部数据来用 解决方法 定义一个局部变量，并用 prop 的值初始化它1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; prop 作为初始值传入，由子组件处理成其它数据输出 解决方法 定义一个计算属性，处理 prop 的值并返回123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证 有时需要对传入组件的数据先进行验证再操作 12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object,// 注意是构造器，并不是字符串 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;); 验证时的type可以是:String、Number、Boolean、Function、Object、Array、Symbol 注意是构造器，不是字符串1234// 这样是错误的type:'Boolean'// 这样是对的type:Boolean 当 prop 验证失败，Vue 会在抛出警告 (如果使用的是开发版本)。注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 非Prop属性 所谓非 prop 属性，就是它可以直接传入组件，而不需要定义相应的 prop。 明确给组件定义 prop 是传参的推荐方式 非prop属性，将会被自动添加到模板的根元素上 123456&lt;!-- 有个非prop属性，data-3d-data-picker --&gt;&lt;bs-date-input data-3d-date-picker=\"true\"&gt;&lt;/bs-date-input&gt;&lt;!-- bs-data-input的模板 --&gt;&lt;input type=\"date\" class=\"form-control\"&gt;&lt;!-- 渲染后 --&gt;&lt;input type=\"date\" class=\"form-control\" data-3d-date-picker=\"true\"&gt; 替换/覆盖现有的特性 默认情况下，在发生特性冲突时，会采取覆盖策略，传递给组件的值会覆盖组件本身设定的值。即例如传递 type=”large” 将会覆盖 type=”date” class和style特性，在发生冲突时，会采取合并策略，而不是覆盖策略12345&lt;bs-date-input type=\"num\" data-3d-date-picker=\"true\" class=\"date-picker-theme-dark\"&gt;&lt;/bs-date-input&gt;&lt;!-- 模板 --&gt;&lt;input type=\"date\" class=\"form-control\"&gt;&lt;!-- 渲染后，传进来的type覆盖了原先的type，class实现了合并 --&gt;&lt;input type=\"num\" class=\"form-control date-picker-theme-dark\" data-3d-date-picker=\"true\"&gt; 自定义事件 可以通过props向子组件传递数据，子组件可以通过自定义事件向父组件发消息 每个vue实例都实现了事件接口 vm.$on(eventName)监听事件 vm.$emit(eventName)触发事件 父组件可以在使用子组件的地方直接用v-on来监听子组件触发的自定义事件，注意在子组件的自定义标签上直接使用v-on只能绑定子组件主动分发(通过$emit触发)的事件，这是一种特殊写法,告诉父组件要监听某个自定义事件。如果想直接使用v-on为子组件绑定事件，将无法触发；例子见下一小节 不能用 $on 侦听子组件抛出的事件，而必须在模板里直接用 v-on 绑定 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;!-- 这里的v-on:increment=\"incrementTotal\"，其实在告诉父组件(这里是根实例)要监听increment事件了 --&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt;// jsVue.component('button-counter', &#123; template: '&lt;button v-on:click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementCounter: function () &#123; this.counter += 1; this.$emit('increment');// 分发'increment'自定义事件 &#125; &#125;,&#125;);new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123;// 接收到子组件分发'increment'自定义事件后触发 this.total += 1 &#125; &#125;&#125;);// 在v1版本中，子组件分发的自定义事件的触发函数是写在父组件的events中;// 这样写，有个不好的地方就是父组件不知道这个事件到底是哪个子组件分发的，如果多个子组件分发了同个自定义事件，就无法分辨。// 所以作者为了清晰的知道具体是哪个组件分发了事件，就将v-on移到了子组件的自定义标签上// https://v1.vuejs.org/guide/components.html#Custom-Events// https://segmentfault.com/q/1010000004486740/a-1020000004487413 给组件绑定原生事件 有时候，你可能想在某个组件的根元素上监听一个原生事件。 注意：在子组件的自定义标签上直接使用v-on:mouseenter，这种事件是无法直接触发的(只有子组件主动$emit了mouseenter事件，才会触发)，在子组件上直接使用v-on绑定的只能是子组件主动分发的事件，它是在告诉父组件要监听某个自定义事件，是一种特殊写法； 想为某个组件绑定一个原生事件(在某个组件的根元素上监听一个原生事件)，必须在自定义标签上使用v-on:事件.native=xxx 1234&lt;!-- 这个mouseenter绑定的回调无法触发，除非子组件主动$emit了mouseenter，count才会被调用 --&gt;&lt;button-counter v-on:child_increment=\"incrementTotal\" v-on:mouseenter=\"count\"&gt;&lt;/button-counter&gt;&lt;!-- v-on:mouseenter.native这种写法，给button-counter的根标签绑定了一个原生mouseenter事件，鼠标移入，就会触发count --&gt;&lt;button-counter v-on:child_increment=\"incrementTotal\" v-on:mouseenter.native=\"count\"&gt;&lt;/button-counter&gt; 小结 子组件的自定义标签上直接使用v-on只适合子组件发消息给父组件这种情况，并且需要子组件主动$emit配合，经过这两步才能完成子组件给父组发消息，具体步骤如下 子组件的自定义标签上直接使用v-on:子组件主动分发的事件名=xxx 子组件在条件合适时主动$emit(事件名) 想在子组件自定义标签上直接使用v-on给组件根元素绑定事件，必须添加.native修饰符 双向绑定.sync 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。123456&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt;&lt;!-- 本质为下面的 --&gt;&lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt;&lt;!-- 子组件值变化时，主动触发update事件 --&gt;this.$emit('update:foo', newValue)&lt;!-- 其实这里的.sync也佐证了自定义标签上直接使用v-on绑定的事件，需要配合$emit才能触发 --&gt; v-model v-model常用来针对表单实行双向数据绑定，它的本质是个语法糖；value属性+input事件 123&lt;input v-model=\"something\"&gt;&lt;!-- 本质如下 --&gt;&lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; 创建自定义input组件时 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 下面2种效果一样 --&gt;&lt;currency-input v-model=\"price\"&gt;&lt;/currency-input&gt;&lt;currency-input v-bind:value=\"price\" v-on:input=\"price = arguments[0]\"&gt;&lt;/currency-input&gt;Vue.component('currency-input', &#123; template: '&lt;span&gt;$&lt;input ref=\"input\" v-bind:value=\"value\" v-on:input=\"updateValue($event.target.value)\"&gt;&lt;/span&gt;', props: &#123; value: Number &#125;, methods: &#123; // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制 updateValue: function(value) &#123; var formattedValue = value // 删除两侧的空格符 .trim() // 保留 2 小数位 .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) // 如果值不统一，手动覆盖以保持一致 if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; price: 3 &#125;&#125;); 定制v-model 从上节可知，v-model需要使用到表单的value属性和input事件，但单选、复选之类的表单会把value用做别的目的；此时使用组件选项对象的model选项即可避免冲突1234567891011121314151617181920Vue.component('my-checkbox', &#123; model: &#123;// v-model使用checked属性和change事件完成双向绑定，而不用原来的value属性和input属性 prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean, // this allows using the `value` prop for a different purpose，value属性可以用做其他用途 value: String &#125;, // ...&#125;);&lt;my-checkbox v-model=\"foo\" value=\"some value\"&gt;&lt;/my-checkbox&gt;&lt;!-- 等价于 --&gt;&lt;my-checkbox :checked=\"foo\" @change=\"val =&gt; &#123; foo = val &#125;\" value=\"some value\"&gt;&lt;/my-checkbox&gt; 非父子组件通信 有时，非父子关系的组件也需要通信，这时需要一个中介来传递信息，在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线 1234567var bus = new Vue();// 触发组件 A 中的事件bus.$emit('id-selected', 1);// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;); 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"app\"&gt; &lt;my-num :init-num=\"price\"&gt;&lt;/my-num&gt; &lt;my-div&gt;&lt;/my-div&gt;&lt;/div&gt;Vue.component('my-num', &#123; template: '&lt;input type=\"num\" v-model=\"num\" @input=\"numChanged\"&gt;', props: &#123; 'initNum': &#123; type: Number &#125; &#125;, data: function() &#123; return &#123; num: this.initNum &#125;; &#125;, methods: &#123; numChanged: function() &#123; console.log(this.num); bus.$emit('my-num-change', this.num); // 通过bus触发my-num-change &#125; &#125;&#125;);Vue.component('my-div', &#123; template: '&lt;h1&gt;&#123;&#123;text&#125;&#125;&lt;/h1&gt;', data: function() &#123; return &#123; text: '我将展示上面input的内容' &#125;; &#125;, created: function() &#123; // 创建后 var _self = this; bus.$on('my-num-change', function(str) &#123; // 监听my-num-change事件 _self.text = str; &#125;); &#125;&#125;);var bus = new Vue();var vm = new Vue(&#123; el: '#app', data: &#123; price: 3 &#125;&#125;); 使用Slot分发内容类似ng1中指令的transclude，用来混合父组件的内容和子组件的模板 编译作用域 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。1234567891011121314151617181920212223242526272829// message将在父组件/实例的作用域中编译，因为&#123;&#123;message&#125;&#125;实际是在父组件模板的内容中，而不是在子组件的模板内容中&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt;// 下例&#123;&#123;test&#125;&#125;、&#123;&#123;test2&#125;&#125;都将在根实例的作用域下编译&lt;div id=\"app\"&gt; &lt;parent-comp&gt; &#123;&#123;test&#125;&#125; &lt;br&gt; &lt;child-comp&gt; &#123;&#123;test2&#125;&#125; &lt;/child-comp&gt; &lt;/parent-comp&gt;&lt;/div&gt;// 假设someChildProperty是子组件上的属性，下面例子无效，将在父组件/实例的作用域中查找someChildProperty，你必须在child-component作用域中使用someChildProperty&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt;// 下面有效Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;); 分发内容 父组件/实例中嵌套在子组件自定义便签中的内容都称为分发内容 分发内容是在父作用域内编译 分发内容适合混合/嵌套多个组件时使用1234&lt;!-- &#123;&#123;message&#125;&#125;属于分发内容，他将在child-component的父作用域中编译 --&gt;&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; slot 除非子组件模板包含至少一个&lt;slot&gt;插口，否则父组件的内容将会被丢弃。类似ng1中directive模板中会指定一个标签，添加ng-transclude特性一样，这个标签将接收在父作用域中编译好的分发内容 当子组件模板只有一个没有属性的slot时，父组件整个内容片段将插入到slot所在的DOM位置，并替换掉slot标签本身 最初在 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。12345678910111213141516171819202122232425// 父组件模板 &lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;// 子组件my-component的模板&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。&lt;slot&gt;整个标签将被分发内容替换 &lt;/slot&gt;&lt;/div&gt;// 渲染后&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;!-- 下面是分发内容替换了&lt;slot&gt; --&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名slot &lt;slot&gt;元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素 仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot，这些找不到匹配的内容片段将被抛弃。 子组件模板上有个&lt;slot&gt;标签，通过标签上的name属性来给&lt;slot&gt;起个名字，分发内容上有个slot特性，通过这个slot特性的值找到子组件中对应名字的&lt;slot&gt;标签，并用分发内容将其替换掉。1234567891011121314151617181920212223242526272829303132// app-layout组件&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; // 这里将要放名字为header的分发内容 &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt;// 这里将要找不到匹配的分发内容 &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt;// 这里将要放名字为footer的分发内容 &lt;/footer&gt;&lt;/div&gt;// 父组件模板&lt;app-layout&gt;// 这里面的都是分发内容 &lt;h1 slot=\"header\"&gt;这里可能是一个页面标题&lt;/h1&gt; // 这个将放到header的slot中 &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=\"footer\"&gt;这里有一些联系信息&lt;/p&gt;// 这个将放到footer的slot中&lt;/app-layout&gt;// 渲染后&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 作用域插槽(Scoped Slot) 正常情况下，分发内容是在父组件的作用域中编译的；考虑下面情况:我们需要创建一个组件，能使用同一份数据，根据DOM的不同渲染出不一样的界面；同一个组件，有不同的DOM结构，我们肯定不能将DOM结构固死在组件内部，肯定需要外部传入，我们很快就想到需要使用分发内容和Slot来完成，但这样会出现一个问题。我们的DOM结构是通过分发内容传入组件内部的，但是分发内容在传入子组件时，已经在父组件的作用域中编译过了，也就是说它用的数据是父组件的而不是子组件的。Scoped Slot就能解决这一问题，它能让分发内容在传入子组件前使用子组件的数据；以前分发内容只能在父组件作用域中编译，根本无法使用到子组件的数据，现在使用Scoped Slot能实现分发内容使用子组件的数据编译。这样能提高组件的复用性。 如何使用 在子组件模板&lt;slot&gt;标签上绑定需要暴露的数据(提供给父组件使用的数据)，这些数据会被封装到一个对象上，传递给父级 在父级上，必须有一个包含scope属性的&lt;template&gt;元素，表示它是作用域插槽的模板 scope的值对应一个临时变量名，此变量接收从子组件中传递过来的对象 实际例子 现在要实现一个列表组件，可以让用户自定义DOM结构12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;my-awesome-list :items=\"items\"&gt; &lt;!-- 作用域插槽也可以是具名的,componProp就是子组件传递过来的对象 --&gt; &lt;template slot=\"list-item\" scope=\"componProp\"&gt; &lt;!-- 这里我可以使用任意的结构来渲染list --&gt; &lt;!-- &lt;h1&gt;&#123;&#123; componProp.text &#125;&#125;&lt;/h1&gt; --&gt; &lt;div style=\"font-style: italic;\"&gt;&#123;&#123; componProp.text &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/my-awesome-list&gt;&lt;/div&gt; Vue.component('my-awesome-list', &#123; props: &#123; items: &#123; type: Array, required: true &#125; &#125;, template: '&lt;div&gt;&lt;slot name=\"list-item\" v-for=\"item in items\" :text=\"item.text\"&gt;&lt;/slot&gt;&lt;/div&gt;'// 暴露text给分发内容使用&#125;); var vm = new Vue(&#123; el: '#app', data: &#123; items: [&#123; text: '11111' &#125;, &#123; text: '22222' &#125;] &#125;&#125;); 动态组件 通过使用保留的 元素，动态地绑定到它的 is 特性，我们让多个组件可以使用同一个挂载点，并动态切换 123456789101112131415&lt;component v-bind:is=\"currentView\"&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt;var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;); 也可以直接绑定到组件对象上 123456789var Home = &#123; template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; currentView: Home &#125;&#125;) 动态组件配合使用&lt;keep-alive&gt;来缓存非活动组件，避免重新渲染 12345&lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 杂项 编写可复用组件 Props 允许外部环境传递数据给组件 Events 允许从外部环境在组件内触发副作用 Slots 允许外部环境将额外的内容组合在组件中 子组件索引 尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 123456&lt;div id=\"parent\"&gt; &lt;user-profile ref=\"profile\"&gt;&lt;/user-profile&gt;&lt;/div&gt;var parent = new Vue(&#123; el: '#parent' &#125;);// 访问子组件var child = parent.$refs.profile 当 ref 和 v-for 一起使用时，ref 是一个数组，包含相应的子组件 $refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs。 异步组件 在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能 123456Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;) 你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数 1234Vue.component( &apos;async-webpack-example&apos;, () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册时，你也可以直接提供一个返回 Promise 的函数 123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;) 如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。Browserify 社区发现 一些解决方法，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持 高级异步组件 自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象 123456789101112const AsyncComp = () =&gt; (&#123; // 需要加载的组件. 应当是一个 Promise component: import(&apos;./MyComp.vue&apos;), // loading 时应当渲染的组件 loading: LoadingComp, // 出错时渲染的组件 error: ErrorComp, // 渲染 loading 组件前的等待时间。默认：200ms. delay: 200, // 最长等待时间。超出此时间则渲染 error 组件。默认：Infinity timeout: 3000&#125;) 注意，当一个异步组件被作为 vue- 的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用 2.4.0+。 组件命名约定 注册组件 (或者 props) 时，可以使用 kebab-case(短横线连接)，camelCase，或 PascalCase 在 HTML 模版中，使用组件推荐 kebab-case 形式 递归组件 组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以 当你利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置.局部注册需要手动设置 递归时，一定要设置终止条件 组件间的循环引用 假设你正在构建一个文件目录树，像在Finder或文件资源管理器中。你可能有一个 tree-folder组件12345678910111213// tree-folder组件&lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;&lt;/p&gt;// 然后 一个tree-folder-contents组件&lt;ul&gt; &lt;li v-for=&quot;child in children&quot;&gt; &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;// 当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点–这点是矛盾的。当使用Vue.component将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾 内联模版 如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容 123456&lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt; &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; 但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素 X-Templates 另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个 id 123456&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt;Vue.component(&apos;hello-world&apos;, &#123; template: &apos;#hello-world-template&apos;&#125;) 这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。 对低开销的静态组件使用 v-once 尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样12345678Vue.component(&apos;terms-of-service&apos;, &#123; template: &apos;\\ &lt;div v-once&gt;\\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\\ ... a lot of static content ...\\ &lt;/div&gt;\\ &apos;&#125;) 深入响应式原理如何追踪变化 Vue通过Object.defineProperty将属性转化为setter/getter，在setter/getter中进行依赖追踪 把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 变化检测问题 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 可以使用Vue.set(target,key,value)或者vm.$set(target,key,value)来添加响应式属性;注意target不能是 Vue 实例，或者 Vue 实例的根数据对象 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 声明响应式属性 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 之后设置 `message` vm.message = 'Hello!' 异步更新队列 Vue中的DOM更新是异步的；实际的DOM更新是发生在观察到数据变化后下一个eventLoop的tick中 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。(数据变化-&gt;开启队列-&gt;去重复/缓冲)-&gt;(DOM更新)，在同一个括号中，代表发生在同一个tick中 Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。 可以使用Vue.nextTick(callback),在 DOM 更新完成后立即调用callback 123456789101112&lt;div id=\"example\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) 组件内使用vm.$nextTick(callback),callback中的 this 将自动绑定到当前的 Vue 实例上 1234567891011121314151617Vue.component(&apos;example&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;, data: function () &#123; return &#123; message: &apos;没有更新&apos; &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = &apos;更新完成&apos; console.log(this.$el.textContent) // =&gt; &apos;没有更新&apos; this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &apos;更新完成&apos; &#125;) &#125; &#125;&#125;) 过渡效果单元素/组件的过渡 Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点 12345678910111213141516171819202122&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;.fade-enter-active, .fade-leave-active &#123; transition: opacity 0.5s&#125;.fade-enter, .fade-leave-to &#123; opacity: 0&#125;new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;); 当插入或删除包含在&lt;transition&gt;组件中的元素时，Vue 将会做以下处理 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和Vue的 nextTick 概念不同) 过渡的css类名类似ng中动画会添加合适的class 会有 6 个(CSS)类名在 enter/leave 的过渡中切换 v-enter-&gt;定义开始状态，会在元素插入时生效，并在下一frame被删除 v-enter-active-&gt;定义过渡状态，插入时生效，过渡结束时删除；这个可以被用来定义过渡的过程时间，延迟和曲线函数。 v-enter-to-&gt;定义过渡结束状态，在元素插入后的下一frame被加入(v-enter正好删除),过渡结束时删除 同理，leave也一样，有v-leave、v-leave-active、v-leave-to 过渡中的类名前缀是可以更换的，通过&lt;transtion&gt;组件的name特性可以指定过渡类的前缀12// 对应的过渡样式类就是.testAnim-enter、.testAnim-enter-active、.testAnim-enter-to&lt;transtion name=&quot;testAnim&quot;&gt;xxx&lt;/transition&gt; css过渡最常用的1234567891011121314151617181920212223242526&lt;div id=&quot;example-1&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;slide-fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; show: true &#125;&#125;);/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0;&#125; css动画animation CSS 动画用法同 CSS 过渡，区别是在动画中v-enter类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时(动画结束)删除。1234567891011121314151617181920212223242526272829&lt;div id=&quot;example-2&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt; &lt;transition name=&quot;bounce&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; show: true &#125;&#125;);.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡类名 可以通过以下特性来自定义过渡类名;主要用来配合第三方css动画库使用;他们的优先级高于普通的类名 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+)123456789101112131415161718192021&lt;link href=&quot;https://unpkg.com/animate.css@3.5.1/animate.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;!-- 进入离开时用特殊的class --&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; show: true &#125;&#125;); 同时使用 Transitions 和 Animations Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 显性的过渡效果持续时间 在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一序列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下你可以用 组件上的 duration 属性定制一个显性的过渡效果持续时间 (以毫秒计)：123&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;// 你也可以定制进入和移出的持续时间：&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt; ###JavaScript 钩子(Js动画)可以在属性中声明 JavaScript 钩子，通过钩子在特定时间调用特定动画函数来实现js动画 beforeEnter-&gt;进入前 enter-&gt;进入中 after-enter-&gt;进入后 enter-cancelled-&gt;取消后 同理leave也有类似钩子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡定义第一次渲染时，如何过渡 通过添加appear特性，可以开启初始渲染过渡动画 和enter、leave过渡一样可以自己定义css类名 12345678&lt;transition appear appear-class=&quot;custom-appear-class&quot; appear-to-class=&quot;custom-appear-to-class&quot; appear-active-class=&quot;custom-appear-active-class&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 也有相应的js钩子 123456789&lt;transition appear v-on:before-appear=&quot;customBeforeAppearHook&quot; v-on:appear=&quot;customAppearHook&quot; v-on:after-appear=&quot;customAfterAppearHook&quot; v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素 123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 组件中的多个元素设置 key 是一个更好的实践。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .3s ease-in-out; &#125; &lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;!-- 没有加key,根据vue的就地复用原则，他们将只替换内容，因此不会产生过渡动画 --&gt; &lt;!-- &lt;button v-if=&quot;isEditing&quot;&gt; Save &lt;/button&gt; &lt;button v-else&gt; Edit &lt;/button&gt; --&gt; &lt;!-- 添加key --&gt; &lt;!-- &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt; --&gt; &lt;!-- 在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为： --&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125; &lt;/button&gt; &lt;/transition&gt; &lt;button @click=&quot;isEditing=!isEditing&quot;&gt;点击&lt;/button&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isEditing: true &#125; &#125;); 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡 123456789101112131415161718192021222324252627&lt;transition&gt; &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt;&lt;!-- 重写 --&gt;&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case &apos;saved&apos;: return &apos;Edit&apos; case &apos;edited&apos;: return &apos;Save&apos; case &apos;editing&apos;: return &apos;Cancel&apos; &#125; &#125;&#125; 多元素的过渡模式多元素过渡时(一个enter、一个leave)默认是进入和离开同时发生；这样可能会发生过渡时画面抖动的问题；通过多元素的过渡模式可以解决 通过在&lt;transtion&gt;上添加mode特性便可指定过渡模式 in-out: 新元素先进行过渡进入，完成之后当前元素过渡离开。-&gt;先enter后leave out-in: 当前元素先进行过渡离开，完成之后新元素过渡进入。-&gt;先leave后enter1234567891011121314151617181920212223242526272829303132&lt;style type=&quot;text/css&quot;&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter &#123; transform: translateX(10px); &#125; .fade-leave-to &#123; transform: translateX(-10px); &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .3s ease-in-out; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;in-out&quot;&gt; &lt;button :key=&quot;isEditing&quot; @click=&quot;isEditing=!isEditing&quot; :style=&quot;&#123;position:&apos;absolute&apos;&#125;&quot;&gt; &#123;&#123; isEditing &#125;&#125; &lt;/button&gt; &lt;/transition&gt;&lt;/div&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isEditing: true &#125;&#125;); 多个组件的过渡 多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件1234567891011121314151617181920212223&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;new Vue(&#123; el: &apos;#transition-components-demo&apos;, data: &#123; view: &apos;v-a&apos; &#125;, components: &#123; &apos;v-a&apos;: &#123; template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos; &#125;, &apos;v-b&apos;: &#123; template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos; &#125; &#125;&#125;);.component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to&#123; opacity: 0;&#125; 列表过渡 那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用&lt;transition-group&gt;组件。 不同于&lt;transition&gt;，它会以一个真实元素呈现：默认为一个 。你也可以通过tag特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style type=&quot;text/css&quot;&gt; .list-item &#123; display: inline-block; margin-right: 10px; &#125; .list-enter-active, .list-leave-active &#123; transition: all 1s; &#125; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(30px); &#125;&lt;/style&gt;&lt;div id=&quot;list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt; &lt;!-- 因为指定了tag特性，所以transition-group将被p取代 --&gt; &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt; &lt;!-- 绑定唯一的key --&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9], nextNum: 10 &#125;, methods: &#123; randomIndex: function() &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function() &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function() &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;); 列表的位移过渡 上面的例子，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡 &lt;transition-group&gt;组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的v-move特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过name属性来自定义前缀，也可以通过move-class属性手动设置 12345678910111213141516171819202122232425&lt;style type=&quot;text/css&quot;&gt; /*设置-move*/ .flip-list-move &#123; transition: transform 1s; &#125;&lt;/style&gt;&lt;div id=&quot;flip-list-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;shuffle&quot;&gt;洗牌&lt;/button&gt; &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#flip-list-demo&apos;, data: &#123; items: [1, 2, 3, 4, 5, 6, 7, 8, 9] &#125;, methods: &#123; shuffle: function() &#123; this.items = _.shuffle(this.items) // 打乱 &#125; &#125;&#125;) 内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。 需要注意的是使用FLIP过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中 列表的渐进过渡 通过 data 属性与 JavaScript 通信 ，就可以实现列表的渐进过渡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;staggered-list-demo&quot;&gt; &lt;input v-model=&quot;query&quot;&gt; &lt;!-- 因为是全部用js完成动画，所以v-bind:css=&quot;false&quot;，避开css动画检查，提高效率；并在各个动画钩子处绑定动画函数 --&gt; &lt;transition-group name=&quot;staggered-fade&quot; tag=&quot;ul&quot; v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot;&gt; &lt;!-- 绑定唯一的key并绑定索引 --&gt; &lt;li v-for=&quot;(item, index) in computedList&quot; v-bind:key=&quot;item.msg&quot; v-bind:data-index=&quot;index&quot;&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#staggered-list-demo&apos;, data: &#123; query: &apos;&apos;, list: [ &#123; msg: &apos;Bruce Lee&apos; &#125;, &#123; msg: &apos;Jackie Chan&apos; &#125;, &#123; msg: &apos;Chuck Norris&apos; &#125;, &#123; msg: &apos;Jet Li&apos; &#125;, &#123; msg: &apos;Kung Fury&apos; &#125; ] &#125;, computed: &#123; computedList: function() &#123; var vm = this return this.list.filter(function(item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function(el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function(el, done) &#123; // 根据索引创建延迟 var delay = el.dataset.index * 150; setTimeout(function() &#123; Velocity( el, &#123; opacity: 1, height: &apos;1.6em&apos; &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function(el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function() &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125; &#125;) 可复用的过渡 过渡可以通过 Vue 的组件系统实现复用 要创建一个可复用过渡组件，你需要做的就是将 或者 作为根组件，然后将任何子组件放置在其中就可以了。1234567891011121314151617181920Vue.component(&apos;my-special-transition&apos;, &#123; template: &apos;\\ &lt;transition\\ name=&quot;very-special-transition&quot;\\ mode=&quot;out-in&quot;\\ v-on:before-enter=&quot;beforeEnter&quot;\\ v-on:after-enter=&quot;afterEnter&quot;\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ &apos;, methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;) 动态过渡 Vue 中即使是过渡也是数据驱动的，过渡中的各种状态能通过数据动态改变。 当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用 所有的过渡特性都是动态绑定。 它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。 这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;dynamic-fade-demo&quot; class=&quot;demo&quot;&gt; Fade In: &lt;input type=&quot;range&quot; v-model=&quot;fadeInDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; Fade Out: &lt;input type=&quot;range&quot; v-model=&quot;fadeOutDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt; &lt;transition v-bind:css=&quot;false&quot; v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:leave=&quot;leave&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=&quot;stop&quot; v-on:click=&quot;stop = false; show = false&quot; &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=&quot;stop = true&quot; &gt;Stop it!&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#dynamic-fade-demo&apos;, data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration,// 持续时间为动态绑定 complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration,// 持续时间为动态绑定 complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;) 过渡状态 Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。有些变化中间的过渡状态无法通过vue独自完成，例如 数字和运算(数字从1变为10中间的过渡) 颜色的显示(从一种颜色变化到另一种的过渡) SVG 节点的位置 元素的大小和其他的属性 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态，补间动画 状态动画 与 watcher 通过 watcher 我们能监听到任何数值属性的数值更新，然后调用一些辅助用的动画库(例如tween.js、color.js)完成相应的特殊过渡123456789101112131415161718192021222324252627282930&lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#animated-number-demo&apos;, data: &#123; number: 0, animatedNumber: 0 &#125;, watch: &#123; number: function(newValue, oldValue) &#123; var vm = this function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(&#123; tweeningNumber: oldValue &#125;) .easing(TWEEN.Easing.Quadratic.Out) .to(&#123; tweeningNumber: newValue &#125;, 500) .onUpdate(function () &#123; vm.animatedNumber = this.tweeningNumber.toFixed(0) &#125;) .start() animate() &#125; &#125;&#125;) 动态状态转换 类似动态过渡，每个状态都是可变的(响应式的) 通过组件组织过渡 管理太多的状态转换会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;script src=&quot;https://unpkg.com/tween.js@16.3.4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;example-8&quot;&gt; &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; + &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; = &#123;&#123; result &#125;&#125; &lt;p&gt; &lt;!-- 传入输入框的值 --&gt; &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; + &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; = &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt; &lt;/p&gt;&lt;/div&gt;// 这种复杂的补间动画逻辑可以被复用// 任何整数都可以执行动画// 组件化使我们的界面十分清晰// 可以支持更多更复杂的动态过渡Vue.component(&apos;animated-integer&apos;, &#123; template: &apos;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&apos;, props: &#123; value: &#123; // 接收的值 type: Number, required: true &#125; &#125;, data: function() &#123; return &#123; tweeningValue: 0 &#125; &#125;, watch: &#123; // 传过来的值有变化，触发tween value: function(newValue, oldValue) &#123; this.tween(oldValue, newValue) &#125; &#125;, mounted: function() &#123; // 刚载入，触发默认tween this.tween(0, this.value) &#125;, methods: &#123; tween: function(startValue, endValue) &#123; var vm = this; // raf function animate() &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; // 数值变化的补间动画 new TWEEN.Tween(&#123; tweeningValue: startValue &#125;) .to(&#123; tweeningValue: endValue &#125;, 500) .onUpdate(function() &#123; vm.tweeningValue = this.tweeningValue.toFixed(0) &#125;) .start(); // 调用一次 animate(); &#125; &#125;&#125;);new Vue(&#123; el: &apos;#example-8&apos;, data: &#123; firstNumber: 20, secondNumber: 40 &#125;, computed: &#123; result: function() &#123; return this.firstNumber + this.secondNumber &#125; &#125;&#125;) Render函数-&gt;用到再补自定义指令 vue2中代码复用的主要形式和抽象是组件,有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。 简介 注册 全局注册 12345678// 注册一个全局自定义指令 v-focusVue.directive(&apos;focus&apos;, &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 局部注册 12345directives: &#123; focus: &#123; // 指令的定义--- &#125;&#125; 使用-&gt;&lt;input v-focus&gt; 钩子函数 自定义指令提供下面钩子 bind-&gt;只调用一次，只在第一次绑定到元素时调用，主要用做初始化工作 inserted-&gt;被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中） componentUpdated-&gt;所在组件的 VNode 及其孩子的 VNode 全部更新时调用。 update-&gt;所在组件的 VNode 更新时调用,但是可能发生在其孩子的 VNode 更新之前。指令的值可能发生了改变也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 unbind-&gt; 只调用一次， 指令与元素解绑时调用 钩子函数参数 钩子函数的回调在被调用时，会自动传入一些参数el,bingding,vnode,oldVnode -el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性 name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。12345678910111213141516171819&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = &apos;name: &apos; + s(binding.name) + &apos;&lt;br&gt;&apos; + &apos;value: &apos; + s(binding.value) + &apos;&lt;br&gt;&apos; + &apos;expression: &apos; + s(binding.expression) + &apos;&lt;br&gt;&apos; + &apos;argument: &apos; + s(binding.arg) + &apos;&lt;br&gt;&apos; + &apos;modifiers: &apos; + s(binding.modifiers) + &apos;&lt;br&gt;&apos; + &apos;vnode keys: &apos; + Object.keys(vnode).join(&apos;, &apos;) &#125;&#125;);new Vue(&#123; el: &apos;#hook-arguments-example&apos;, data: &#123; message: &apos;hello!&apos; &#125;&#125;); 函数简写 大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数。 第二个参数不传入选项对象，而是一个函数，则表示此函数只会在bind和update时被调用123Vue.directive(&apos;color-swatch&apos;, function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量12345&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;&lt;/div&gt;Vue.directive(&apos;demo&apos;, function (el, binding) &#123; console.log(binding.value.color) // =&gt; &quot;white&quot; console.log(binding.value.text) // =&gt; &quot;hello!&quot;&#125;) 混合 当多个组件拥有相同的选项时，可以将这些公用选项抽象成一个mixin对象，然后通过配置组件的mixins字段来混入选项(类似jQuery.extend方法) 混入策略 数据对象在内部进行合并；数据冲突时，以组件数据优先 12345678910111213141516171819202122var mixin = &#123; data: function () &#123; return &#123; message: 'hello', foo: 'abc' &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: 'goodbye', bar: 'def' &#125; &#125;, created: function () &#123; console.log(this.$data) // =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125; &#125;&#125;) 同名钩子函数，将会混合成一个数组，混入的钩子函数将在组件自身钩子函数之前调用 123456789101112131415var mixin = &#123; created: function () &#123; console.log('混入对象的钩子被调用') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('组件钩子被调用') &#125;&#125;)// =&gt; \"混入对象的钩子被调用\"// =&gt; \"组件钩子被调用\" 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对 1234567891011121314151617181920212223242526var mixin = &#123; methods: &#123; foo: function () &#123; console.log('foo') &#125;, conflicting: function () &#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log('bar') &#125;, conflicting: function () &#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // =&gt; \"foo\"vm.bar() // =&gt; \"bar\"vm.conflicting() // =&gt; \"from self\" 插件1234import MyPlugin form 'xxxx';// 插件一定要通过use来注册一下Vue.use(MyPlugin, &#123; someOption: true &#125;); 单文件组件1234567891011121314151617181920212223&lt;!-- 每个.vue文件只能包含一个template，template内只能有一个根节点 --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 每个 .vue 文件最多包含一个 &lt;script&gt; 块 --&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt;&lt;!-- 可以有多个style，可以在根组件中导入一些全局样式 --&gt;&lt;style src=\"./assets/test.scss\" lang=\"scss\"&gt;&lt;/style&gt;&lt;style src=\"./assets/test2.scss\" lang=\"scss\"&gt;&lt;/style&gt;&lt;!-- 导入路径都是基于当前目录的，不过可以从NPM包中直接导入资源，如下 --&gt;&lt;!-- &lt;style src=\"todomvc-app-css/index.css\"&gt;&lt;/style&gt; --&gt;&lt;!-- 当style标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素 --&gt;&lt;!-- &lt;style scoped&gt;.example &#123;color: red;&#125;&lt;/style&gt; --&gt;&lt;!-- 在你的 &lt;style&gt; 上添加 module 属性，将为 css-loader 打开 CSS Modules 模式，生成的 CSS 对象将为组件注入一个名叫 $style 的计算属性，你可以在你的模块中使用动态 class 绑定 --&gt; 生产环境部署提示 记得定义process.env.NODE_ENV = &#39;production&#39; vue-cli的build命令已经预先定义了 路由简单路由 HTML5 History API12345678910111213141516171819const NotFound = &#123; template: '&lt;p&gt;Page not found&lt;/p&gt;' &#125;const Home = &#123; template: '&lt;p&gt;home page&lt;/p&gt;' &#125;const About = &#123; template: '&lt;p&gt;about page&lt;/p&gt;' &#125;const routes = &#123; '/': Home, '/about': About&#125;new Vue(&#123; el: '#app', data: &#123; currentRoute: window.location.pathname &#125;, computed: &#123; ViewComponent () &#123; return routes[this.currentRoute] || NotFound &#125; &#125;, render (h) &#123; return h(this.ViewComponent) &#125;&#125;) 官方路由Vue-router 基础使用 1234567891011121314151617181920212223242526272829303132333435363738394041// router/index.jsimport Vue from 'vue';import Router from 'vue-router';// 导入vue-router..import Recommend from 'components/recommend/recommend'import Singer from 'components/singer/singer'...Vue.use(Router); // 必须使用use方法来注册第三方插件export default new Router(&#123;// 导出一个vue-router实例 routes: [&#123; path: '/', redirect: '/recommend',// 没有匹配到的路径全部重定向到/recomend &#125;, &#123; path: '/recommend',// path一定是个路径，开头必须有/ name: 'Recommend', component: Recommend, children: [&#123;// 子路由 path: ':id',// 传递的参数 name: 'Disc', component: Disc &#125;]&#125;)// src/main.jsimport Vue from 'vue'...import router from './router'; // 导入...new Vue(&#123; el: '#app', router,// 注册 store, render: h =&gt; h(App)&#125;) 动态路由匹配 12345678910const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;',// 获取传递动态路由参数&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: '/user/:id', component: User &#125; ]&#125;) 响应路由参数的变化 使用动态路由时，如果组件相同，仅路由参数不同，vue会复用组件(导致组件的生命周期钩子，无法再被触发)，可以对路由参数的变化做个观测，来响应变化；1234567891011121314151617// 使用watch观测$route的变化，来做响应const User = &#123; template: '...', watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125;// 或者使用2.2+的beforeRouteUpdateconst User = &#123; template: '...', beforeRouteUpdate (to, from, next) &#123; // react to route changes... // don't forget to call next() &#125;&#125; 嵌套路由 在定义routes使用children字段来定义自路由，并在上层路由对应的组件中添加一个router-view 注意子路由开头不能以/开头，这代表根目录123456789101112131415161718192021222324252627282930// User.jsconst User = &#123; template: ` &lt;div class=\"user\"&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 路由跳转api router.push()，向历史记录栈中压入一条历史记录 123456789101112131415// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)// 如果提供了 path，params就会被忽略，上述例子中的 query 并不属于这种情况// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user router.replace()替换当前记录，用法类似push router.go()历史记录前进后台几步 可以给路由命名 12345678910111213const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user',// 取个名字 component: User &#125; ]&#125;)// 调用&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 也可以给视图命名，方便创建sidebar、main双视图的布局 1234567891011121314151617&lt;router-view class=\"view one\"&gt;&lt;/router-view&gt; // 默认视图的name为default&lt;router-view class=\"view two\" name=\"a\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view three\" name=\"b\"&gt;&lt;/router-view&gt;const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; // 匹配'/'路径时，default视图渲染Foo组件,a视图渲染Bar,b视图渲染Baz default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 重定向、别名 1234567891011121314// 重定向// 当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /bconst router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b' &#125; ]&#125;)// 别名// /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。const router = new VueRouter(&#123; routes: [ &#123; path: '/a', component: A, alias: '/b' &#125; ]&#125;) 向组件传递数据 12345678910111213141516171819202122232425262728293031// 利用动态路径参数来直接传递，组件和路由耦合性高const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;)// 通过 props 解耦const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true,// 参数会做为props传入到组件中 &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 注册导航守卫(事件) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const router = new VueRouter(&#123; ... &#125;)// 全局路由守卫// 全局前置守卫，路由确认时触发router.beforeEach((to, from, next) =&gt; &#123; // to: Route: 即将要进入的目标 路由对象 // from: Route: 当前导航正要离开的路由 // next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。&#125;)// 全局解析守卫，路由确认之后，组内守卫、异步路由组建被解析之后触发router.beforeResolve()// 全局后置守卫，路由到达后触发router.afterEach((to, from) =&gt; &#123; // ...&#125;)// 单独路由的守卫// 定义在一个单独路由上const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;)// 组件内路由守卫const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 因为当守卫执行前，组件实例还没被创建 // 不！能！获取组件实例 `this`，不过这个守卫中的next很特殊，可以接收一个回调，回调会接收到vm实例，可以通过vm实例来访问this next(vm=&gt;&#123; // do sth &#125;); &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; 路由解析流程 1234567891011121.导航被触发。2.在失活的组件里调用离开守卫。3.调用全局的 beforeEach 守卫。4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。5.在路由配置里调用 beforeEnter。6.解析异步路由组件。7.在被激活的组件里调用 beforeRouteEnter。8.调用全局的 beforeResolve 守卫 (2.5+)。9.导航被确认。10.调用全局的 afterEach 钩子。11.触发 DOM 更新。12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 路由元信息，可用来完成页面是否登录的需求 1234567891011121314151617181920212223242526272829303132333435363738const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, children: [ &#123; path: 'bar', component: Bar, // a meta field，定义/foo/bar需要登录 meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;);// 注册全局的路由前置守卫router.beforeEach((to, from, next) =&gt; &#123; // 一个路由匹配到的所有路由记录会暴露为 $route 对象的 $route.matched 数组 // 遍历$route.matched数组，检查meta字段 if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. // 未登录，则跳转登录，并附带一个返回的url if (!auth.loggedIn()) &#123; next(&#123; path: '/login', // 传递给登录页面一个返回的url地址 query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 路由过渡效果 12345678910111213141516171819202122232425262728293031323334353637383940414243// 所有路由设置一样的过渡效果&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;// 配合keep-alive&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt;// 单个路由设置过度效果const Foo = &#123; template: ` &lt;transition name=\"slide\"&gt; &lt;div class=\"foo\"&gt;...&lt;/div&gt; &lt;/transition&gt; `&#125;const Bar = &#123; template: ` &lt;transition name=\"fade\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt; &lt;/transition&gt; `&#125;// 动态过渡(进入用一个效果，退出用另一个效果)&lt;!-- 使用动态的 transition name --&gt;&lt;transition :name=\"transitionName\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;// 接着在父组件内// watch $route 决定使用哪种过渡watch: &#123; '$route' (to, from) &#123; const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length this.transitionName = toDepth &lt; fromDepth ? 'slide-right' : 'slide-left' &#125;&#125; 数据获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 导航完成后，在created中获取数据export default &#123; data () &#123; return &#123; loading: false, post: null, error: null &#125; &#125;, created () &#123; // 组件创建完后获取数据， // 此时 data 已经被 observed 了 this.fetchData() &#125;&#125;// 导航进入前获取数据export default &#123; data () &#123; return &#123; post: null, error: null &#125; &#125;, beforeRouteEnter (to, from, next) &#123; getPost(to.params.id, (err, post) =&gt; &#123; next(vm =&gt; vm.setData(err, post)) &#125;) &#125;, // 路由改变前，组件就已经渲染完了 // 逻辑稍稍不同 beforeRouteUpdate (to, from, next) &#123; this.post = null getPost(to.params.id, (err, post) =&gt; &#123; this.setData(err, post) next() &#125;) &#125;, methods: &#123; setData (err, post) &#123; if (err) &#123; this.error = err.toString() &#125; else &#123; this.post = post &#125; &#125; &#125;&#125; 记录上次滚动位置 12345678910111213141516171819202122232425262728const router = new VueRouter(&#123; routes: [...], scrollBehavior (to, from, savedPosition) &#123; // return 期望滚动到哪个的位置 &#125;&#125;)const router = new VueRouter(&#123; routes: [...], scrollBehavior (to, from, savedPosition) &#123; // 如果savedPosition，存在则滚动到特定位置，否则滚动到顶部 if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;&#125;)// 如果你要模拟『滚动到锚点』的行为scrollBehavior (to, from, savedPosition) &#123; if (to.hash) &#123; return &#123; selector: to.hash &#125; &#125;&#125; 路由懒加载 路由被访问时，才加载对应的组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)const Recommend = (resolve) =&gt; &#123; import('components/recommend/recommend').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Singer = (resolve) =&gt; &#123; import('components/singer/singer').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Rank = (resolve) =&gt; &#123; import('components/rank/rank').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Search = (resolve) =&gt; &#123; import('components/search/search').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const SingerDetail = (resolve) =&gt; &#123; import('components/singer-detail/singer-detail').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const Disc = (resolve) =&gt; &#123; import('components/disc/disc').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const TopList = (resolve) =&gt; &#123; import('components/top-list/top-list').then((module) =&gt; &#123; resolve(module) &#125;)&#125;const UserCenter = (resolve) =&gt; &#123; import('components/user-center/user-center').then((module) =&gt; &#123; resolve(module) &#125;)&#125;export default new Router(&#123; routes: [&#123; path: '/', redirect: '/recommend' &#125;, &#123; path: '/recommend', name: 'Recommend', component: Recommend, children: [&#123; path: ':id', name: 'Disc', component: Disc &#125;] &#125;, &#123; path: '/singer', name: 'Singer', component: Singer, children: [&#123; path: ':id', name: 'SingerDetail', component: SingerDetail &#125;] &#125;, &#123; path: '/rank', name: 'Rank', component: Rank, children:[&#123; path:':id', name: 'TopList', component:TopList &#125;] &#125;, &#123; path: '/search', name: 'Search', component: Search, children: [&#123; path: ':id', name: 'SingerDetail', component: SingerDetail &#125;] &#125;,&#123; path:'/user', name:'User', component:UserCenter &#125; ]&#125;) router-link 默认被渲染为a标签 激活时，会自动加上router-link-active样式类12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to=\"home\"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=\"home\"&gt;Home&lt;/a&gt; &lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=\"'home'\"&gt;Home&lt;/router-link&gt; &lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=\"'home'\"&gt;Home&lt;/router-link&gt; &lt;!-- 同上 --&gt;&lt;router-link :to=\"&#123; path: 'home' &#125;\"&gt;Home&lt;/router-link&gt; &lt;!-- 命名的路由 --&gt;&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt; &lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"&gt;Register&lt;/router-link&gt; router-view 可以通过name定义命名视图 配合keep-alive、transition12345&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 状态管理类 Flux 状态管理的官方实现 由于多个状态分散的跨越在许多组件和交互间各个角落，大型应用复杂度也经常逐渐增长。为了解决这个问题，Vue 提供 vuex： 我们有受到 Elm 启发的状态管理库 简单状态管理起步使用 Vue 应用中原始数据对象的实际来源 - 当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享 1234567const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) 现在当 sourceOfTruth 发生变化，vmA 和 vmB 都将自动的更新引用它们的视图。子组件们的每个实例也会通过 this.$root.$data 去访问。现在我们有了唯一的实际来源，但是，调试将会变为噩梦。任何时间，我们应用中的任何部分，在任何数据改变后，都不会留下变更过的记录 为了解决这个问题，我们采用一个简单的 store 模式： 1234567891011121314var store = &#123; debug: true, state: &#123; message: &apos;Hello!&apos; &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log(&apos;setMessageAction triggered with&apos;, newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log(&apos;clearMessageAction triggered&apos;) this.state.message = &apos;&apos; &#125;&#125; 所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理,这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么 此外，每个实例/组件仍然可以拥有和管理自己的私有状态：123456789101112var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) 重要的是，注意你不应该在 action 中 替换原始的状态对象 - 组件和 store 需要引用同一个共享对象，mutation 才能够被观察 接着我们继续延伸约定，组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构 这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation) 、保存状态快照、历史回滚/时光旅行的先进的调试工具 vuex1234567891011121314151617181920const store = new Vuex.Store(&#123; state: &#123; // 需要全局共享的数据 count: 1 &#125;, mutations: &#123; // 注册一个increment mutations increment (state,payload) &#123; // 变更状态 state.count += payload.amount &#125; &#125;, actions: &#123; incrementAsync (context,payload) &#123; setTimeout(() =&gt; &#123; context.commit('increment') &#125;, 1000) &#125; &#125;&#125;) states 需要全局共享的基础数据，派生数据(计算数据)可以通过编写getters来实现 getters 类似计算属性，可以用来访问基于state派生出的一些state，主要用来访问states mutations 很类似事件，只能通过提交mutations来改变state(方便开发工具跟踪)，主要用来设置states 提交mutaions是改变state的唯一方式 只能是同步任务，异步任务需要actions来完成 每一个mutation，store会传入state和可选的payload commit 用来提交mutaions 可以传递额外的参数payload给mutaions123store.commit('increment', &#123; amount: 10&#125;) actions 主要用来完成异步任务;需要请求后台的任务全部放在actions中 action不会直接变更状态，而是通过提交mutation来改变state， 每个action，store会传入一个context和可选的payload，context包含store实例的所有方法和属性。因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters dispatch 用来分发(提交)action 可以传递额外的参数(payload)给actions123store.dispatch('incrementAsync', &#123; amount: 10&#125;) 辅助函数 123456789101112131415161718192021222324252627282930313233343536// mapState、mapGetters、mapMutations、mapActions，都是返回一个对象，可以使用扩展预算符解析出来new Vue(&#123; el:'#app', store, computed: &#123; localComputed () &#123;&#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState([ count,// 将this.count 映射为 store.state.count ]), ...mapGetters([ 'doneTodosCount',// 将this.doneTodosCount 映射为 store.getters.doneTodosCount 'anotherGetter',// 将this.anotherGetter 映射为 store.getters.anotherGetter ]) &#125;, methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;), ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125;); 实际项目目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311|---store/ actions.js // 保存所有异步任务 getters.js // 保存所有getters index.js // 导入state、getter...来实例化vuex mutations-type.js // 保存所有mutations类型 mutations.js // 实际的mutation函数 state.js // 所有需要共享的数据// state.js// 首先确定哪些数据需要vuex来管理，并给定默认值import &#123;playMode&#125; from 'common/js/config'import &#123;loadSearch,loadPlay,loadFavorite&#125; from 'common/js/cache'const state = &#123; singer: &#123;&#125;, playing: false, fullScreen: false, playlist: [], sequenceList: [], mode: playMode.sequence, currentIndex: -1, disc:&#123;&#125;, topList:&#123;&#125;, searchHistory:loadSearch(), playHistory:loadPlay(), favoriteList:loadFavorite(),&#125;;export default state;// 导出state对象// mutation-types.js// 确定针对state的修改export const SET_SINGER = 'SET_SINGER'export const SET_PLAYING_STATE = 'SET_PLAYING_STATE'export const SET_FULL_SCREEN = 'SET_FULL_SCREEN'export const SET_PLAYLIST = 'SET_PLAYLIST'export const SET_SEQUENCE_LIST = 'SET_SEQUENCE_LIST'export const SET_PLAY_MODE = 'SET_PLAY_MODE'export const SET_CURRENT_INDEX = 'SET_CURRENT_INDEX'export const SET_DISC = 'SET_DISC'export const SET_TOP_LIST = 'SET_TOP_LIST'export const SET_SEARCH_HISTORY = 'SET_SEARCH_HISTORY'export const SET_PLAY_HISTORY = 'SET_PLAY_HISTORY'export const SET_FAVORITE_LIST = 'SET_FAVORITE_LIST'// mutations.js// 根据mutaion-types编写具体的mutation来设置stateimport * as types from './mutation-types'const mutations = &#123; [types.SET_SINGER](state, singer) &#123; state.singer = singer &#125;, [types.SET_PLAYING_STATE](state, flag) &#123; state.playing = flag &#125;, [types.SET_FULL_SCREEN](state, flag) &#123; state.fullScreen = flag &#125;, [types.SET_PLAYLIST](state, list) &#123; state.playlist = list &#125;, [types.SET_SEQUENCE_LIST](state, list) &#123; state.sequenceList = list &#125;, [types.SET_PLAY_MODE](state, mode) &#123; state.mode = mode &#125;, [types.SET_CURRENT_INDEX](state, index) &#123; state.currentIndex = index &#125;, [types.SET_DISC](state, disc) &#123; state.disc = disc &#125;, [types.SET_TOP_LIST](state, topList) &#123; state.topList = topList &#125;, [types.SET_SEARCH_HISTORY](state, history) &#123; state.searchHistory = history &#125;, [types.SET_PLAY_HISTORY](state, history) &#123; state.playHistory = history &#125;, [types.SET_FAVORITE_LIST](state, list) &#123; state.favoriteList = list &#125;,&#125;export default mutations; // 导出mutations对象// getters.js// 编写getter来读取stateexport const singer = state =&gt; state.singerexport const playing = state=&gt;state.playingexport const fullScreen = state=&gt;state.fullScreenexport const playlist = state=&gt;state.playlistexport const sequenceList = state=&gt;state.sequenceListexport const mode = state=&gt;state.modeexport const currentIndex = state=&gt;state.currentIndexexport const currentSong = (state)=&gt; &#123; return state.playlist[state.currentIndex] || &#123;&#125;;&#125;export const disc = state=&gt;state.discexport const topList = state=&gt;state.topListexport const searchHistory = state=&gt;state.searchHistoryexport const playHistory = state=&gt;state.playHistoryexport const favoriteList = state=&gt;state.favoriteList// actions.js// 异步操作import * as types from './mutation-types'import &#123; playMode &#125; from 'common/js/config'import &#123; shuffle &#125; from 'common/js/util'import &#123; saveSearch, deleteSearch, clearSearch, savePlay, saveFavorite, deleteFavorite &#125; from 'common/js/cache'function findIndex(list, song) &#123; return list.findIndex((item) =&gt; &#123; return item.id === song.id; &#125;)&#125;export const selectPlay = function(&#123; commit, state &#125;, &#123; list, index &#125;) &#123; commit(types.SET_SEQUENCE_LIST, list); if (state.mode === playMode.random) &#123; let randomList = shuffle(list); commit(types.SET_PLAYLIST, randomList); index = findIndex(randomList, list[index]); &#125; else &#123; commit(types.SET_PLAYLIST, list); &#125; commit(types.SET_CURRENT_INDEX, index); commit(types.SET_FULL_SCREEN, true); commit(types.SET_PLAYING_STATE, true);&#125;;export const randomPlay = function(&#123; commit &#125;, &#123; list &#125;) &#123; commit(types.SET_PLAY_MODE, playMode.random); commit(types.SET_SEQUENCE_LIST, list); let randomList = shuffle(list); commit(types.SET_PLAYLIST, randomList); commit(types.SET_CURRENT_INDEX, 0); commit(types.SET_FULL_SCREEN, true); commit(types.SET_PLAYING_STATE, true);&#125;;export const insertSong = function(&#123; commit, state &#125;, song) &#123; let playlist = state.playlist.slice(); let sequenceList = state.sequenceList.slice(); let currentIndex = state.currentIndex; // 记录当前歌曲 let currentSong = playlist[currentIndex]; // 修改playlist // 查询当前列表中是否有待插入的歌曲并返回其索引 let fpIndex = findIndex(playlist, song); // 因为是插入歌曲，所以索引要+1 currentIndex++; // 插入这首歌当当前索引位置 playlist.splice(currentIndex, 0, song); // 如果已经包含这首歌曲 if (fpIndex &gt; -1) &#123; // 如果当前插入的索引大于列表中的序号 if (currentIndex &gt; fpIndex) &#123; playlist.splice(fpIndex, 1); currentIndex--; &#125; else &#123; playlist.splice(fpIndex + 1, 1); &#125; &#125; // 修改sequenceList let currentSIndex = findIndex(sequenceList, currentSong) + 1; let fsIndex = findIndex(sequenceList, song); sequenceList.splice(currentSIndex, 0, song); if (fsIndex &gt; -1) &#123; if (currentSIndex &gt; fsIndex) &#123; sequenceList.splice(fsIndex, 1); &#125; else &#123; sequenceList.splice(fsIndex + 1, 1); &#125; &#125; commit(types.SET_PLAYLIST, playlist); commit(types.SET_SEQUENCE_LIST, sequenceList); commit(types.SET_CURRENT_INDEX, currentIndex); commit(types.SET_FULL_SCREEN, true); commit(types.SET_PLAYING_STATE, true);&#125;;export const saveSearchHistory = function(&#123; commit &#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, saveSearch(query));&#125;;export const deleteSearchHistory = function(&#123; commit &#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, deleteSearch(query));&#125;;export const clearSearchHistory = function(&#123; commit &#125;) &#123; commit(types.SET_SEARCH_HISTORY, clearSearch());&#125;;export const deleteSong = function(&#123; commit, state &#125;, song) &#123; let playlist = state.playlist.slice() let sequenceList = state.sequenceList.slice() let currentIndex = state.currentIndex let pIndex = findIndex(playlist, song) playlist.splice(pIndex, 1) let sIndex = findIndex(sequenceList, song) sequenceList.splice(sIndex, 1) if (currentIndex &gt; pIndex || currentIndex === playlist.length) &#123; currentIndex-- &#125; commit(types.SET_PLAYLIST, playlist) commit(types.SET_SEQUENCE_LIST, sequenceList) commit(types.SET_CURRENT_INDEX, currentIndex) if (!playlist.length) &#123; commit(types.SET_PLAYING_STATE, false) &#125; else &#123; commit(types.SET_PLAYING_STATE, true) &#125;&#125;export const deleteSongList = function(&#123; commit &#125;) &#123; commit(types.SET_CURRENT_INDEX, -1) commit(types.SET_PLAYLIST, []) commit(types.SET_SEQUENCE_LIST, []) commit(types.SET_PLAYING_STATE, false)&#125;export const savePlayHistory = function(&#123; commit &#125;, song) &#123; commit(types.SET_PLAY_HISTORY, savePlay(song))&#125;export const saveFavoriteList = function(&#123; commit &#125;, song) &#123; commit(types.SET_FAVORITE_LIST, saveFavorite(song))&#125;export const deleteFavoriteList = function(&#123; commit &#125;, song) &#123; commit(types.SET_FAVORITE_LIST, deleteFavorite(song))&#125;// index.js// 入口文件，实例化vueximport Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'import createLogger from 'vuex/dist/logger';// 调试工具，可以打印出logVue.use(Vuex);// vuex是个插件，需要useconst debug = process.env.NODE_ENV !== 'production';// 导出一个store实例，供main.js使用export default new Vuex.Store(&#123; actions, getters, state, mutations, strict: debug,// strict模式会针对不通过commit提交mutation报错 plugins: debug ? [createLogger()] : [],// 使用打印log插件&#125;)// main.js// 导入vuex的stroe实例，并注入到vue根组件中import store from './store'...new Vue(&#123; el: '#app', router, store,// 导入vuex的stroe实例 render: h =&gt; h(App)&#125;); 单元测试-&gt;用到再补服务器端渲染-&gt;用到再补Typescript支持-&gt;用到再补","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"how-does-timer-work","date":"2017-07-31T02:55:32.000Z","path":"2017/07/31/how-does-timer-work/","text":"最近看了些关于js中定时器原理解析的文章，所以特在此做一个记录本文带有个人理解，若有错误，望指正。 JS中的定时器(setTimeout)是如何工作的?定时器js中的setTimeout主要用来完成一些超时调用的任务，可以指定函数在未来的某个时间执行。123setTimeout(function()&#123; console.log('hi');&#125;,500); 理论情况下，’hi’会在500ms后被打印出来。 考虑下面这种情况12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 最后输出的顺序是1,3,2，你可能在想因为2被延迟了1000ms，所以最后输出的。 再看下面的12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 这次我们将延迟的时间从1000调成了0，这次应该输出1,2,3了吧，但实际上最后的输出结果还是1,3,2这是为什么呢？要解释清楚这个就必须了解setTimeout的工作原理了。 工作原理js是单线程的，它同一时间它只能干一件事情。那你可能会问为什么不多弄几个线程，这样多管齐下，不是执行效率更高了吗？当时js的用途(交互、操作dom)决定了它只能是单线程的，如果多线程，就会存在多线程同步的问题。我在一个线程中删除了节点a，另一个线程在节点a上添加了一些内容，这样就会导致冲突，将一个简单的问题负责化了，所以最终js是单线程的。 解释下下面代码的执行过程12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,1000);console.log(3); 首先js中存在一个callstack(调用栈)的东西，它会将函数/方法压入(push)到栈中，并依次出栈(pop)执行。 默认上面代码外围有个main函数 main入栈 console.log(1)入栈 console.log(1)出栈并调用打印出1 setTimeout入栈 发现setTimeout是个延迟执行，出栈时，将需要延迟执行的回调函数交给浏览器的timer模块，timer模块负责观察延迟执行的回调函数是否到达触发条件，此时call stack会继续将后面的方法压入栈中 console.log(3)入栈 console.log(3)出栈并调用打印出3 main出栈 timer模块观察到延迟执行的函数到达触发条件后，将延迟执行的回调函数推入任务队列(task queue)中 当调用栈处于空闲状态时，它会将任务队列中的第一个任务压入callstack中，并调用，并一直重复这个过程直到任务队列为空。这个过程称为event loop 上面的setTimeout的延迟是1000，为0的时候其实也是一样的，只不过在timer模块中，它会立即到达触发条件，并被推入任务队列中，等待call stack空闲时，再压入到call stack中并调用。 上面是关于setTimeout延迟函数的调用过程，其实js中的事件、ajax的执行流程也一样(其实你会发现他们有个共同点，都有回调函数)。只不过setTimeout有一个具体的延迟时间，延迟时间到达了触发。事件是在用户进行某种操作后(点击)，立即将回调函数推入任务队列中，call stack空闲时取第一个并执行。ajax则是在返回数据后(满足触发条件)，将回调推入任务队列中，call stack空闲时取第一个并执行。 其实js的任务(代码)可以分为同步任务和异步任务(事件、ajax、setTimeout)，异步任务的回调一定是在所有同步任务都执行完了以后再被调用;12345console.log(1);setTimeout(function()&#123; console.log(2);&#125;,0);console.log(3); 如上面，即使setTimeout的延迟时间为0，它的回调函数也没有直接被调用，而是等到console.log(3)执行完，call stack为空时，再被调用执行的。所以setTimeour(fn,0)常用来在所有同步任务执行完后，尽可能早的执行； 再看下面的代码12345var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 和12345var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 二者效果一样。 onload和onerror的位置无关紧要，不用担心先send了,load和error不会触发。因为load和error事件都属于异步任务(事件)，他们的回调函数一定是在所有同步任务完成后再被调用的。 总结： 通过上面可以发现，js中的异步任务(事件、ajax、setTimeout)，是需要call stack、浏览器中的对应模块(DOM Binding、network、timer)、task queue三者配合来完成异步任务； call stack负责压入待执行的方法/函数，遇到异步任务时，会将异步任务交给对应模块处理； 浏览器对应模块负责判断异步任务是否满足触发条件，若满足触发条件，则将异步任务的回调推入task queue中 task queue负责保存所有已经满足触发条件可以压入call stack中执行的异步任务回调。 当call stack空闲时，会将task queue中的第一个回调压入call stack中并执行，并一直循环这一过程直到task queue为空；-&gt;event loop 所有异步任务的回调一定是在所有同步任务都执行完了后再被调用 setTimeout(fn,0)无论写在哪，它的作用都是在所有同步任务执行完后，尽可能早的执行fn 参考链接 http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/http://www.ruanyifeng.com/blog/2014/10/event-loop.htmlhttps://vimeo.com/96425312http://latentflip.com/loupe/","tags":[{"name":"timer","slug":"timer","permalink":"http://yoursite.com/tags/timer/"}]},{"title":"AngularJs-todoMVC","date":"2017-07-13T03:23:52.000Z","path":"2017/07/13/AngularJs-todoMVC/","text":"AngularJs-todoMVC 源码解释 github上的todoMVC仓库是一个帮助你选择前端MVC框架的项目项目中包含了绝大多数前端MVC框架实现Todo application的范例，让你能比较不同的框架实现同一个应用的差异。进而让你做出最佳选择。Todo application的具体效果，可以看这个http://todomvc.com/examples/angularjs/#/对于新手来说，是个很不错的学习范例。本文选取的是其中的angularJs范例，对其做了简单分析。分析源码已经上传至github，https://github.com/BryanAdamss/SourceSave/tree/master/TodoMVC/angularjs源码下载后，请在服务器中打开 目录结构主要根据功能不同，放在了不同文件夹中 angularjs/ js/ controllers/ todoCtrl.js-&gt;最主要的一个控制器 directives/ todoEscape.js-&gt;实现按下esc键，恢复到原先编辑状态的指令 todoFocus.js-&gt;再编辑input显示，聚焦的指令 services/ todoStorage.js-&gt;实现本地localStorge app.js-&gt;入口文件，包含了路由配置 node_modules/ angular/ angular-resource/ angular-route/ todomvc-app-css/-&gt;页面主要样式文件 todomvc-common/-&gt;一些通用的css样式和js helper index.html index.html相关说明全部写在注释里了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta name=\"keywords\" content=\"我是关键字\"&gt; &lt;meta name=\"description\" content=\"我是网站描述\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta content=\"telephone=no,email=no\" name=\"format-detection\" /&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no,minimal-ui\" /&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/todomvc-common/base.css\"&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/todomvc-app-css/index.css\"&gt; &lt;title&gt;Angular | TodoMVC&lt;/title&gt; &lt;style&gt; [ng-cloak] &#123; /*防止闪屏*/ display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app=\"todomvc\"&gt; &lt;ng-view&gt;&lt;/ng-view&gt; &lt;script type=\"text/ng-template\" id=\"todomvc-index.html\"&gt; &lt;!-- 模板 --&gt; &lt;section id=\"todoapp\"&gt; &lt;header id=\"header\"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;!-- form提交时，触发addTodo()事件 --&gt; &lt;form id=\"todo-form\" ng-submit=\"addTodo()\"&gt; &lt;!-- 新todo的输入框，值绑定到newTodo上，根据状态saving来禁用 --&gt; &lt;input id=\"new-todo\" placeholder=\"What needs to be done?\" ng-model=\"newTodo\" ng-disabled=\"saving\" autofocus&gt; &lt;/form&gt; &lt;/header&gt; &lt;!-- #main根据todos的长度来显示隐藏 --&gt; &lt;section id=\"main\" ng-show=\"todos.length\" ng-cloak&gt; &lt;!-- #toggle-all 布尔值绑定到allChecked上，点击时触发markAll --&gt; &lt;input id=\"toggle-all\" type=\"checkbox\" ng-model=\"allChecked\" ng-click=\"markAll(allChecked)\"&gt; &lt;label for=\"toggle-all\"&gt;Mark all as complete&lt;/label&gt; &lt;ul id=\"todo-list\"&gt; &lt;!-- 遍历每个todo，并通过statusFilter进行过滤，通过todo.completed、editedTodo来切换class --&gt; &lt;li ng-repeat=\"todo in todos | filter:statusFilter track by $index\" ng-class=\"&#123;completed: todo.completed, editing: todo == editedTodo&#125;\"&gt; &lt;div class=\"view\"&gt; &lt;!-- todo前的复选框，值绑定到todo.completed，change时触发toggleCompleted事件，并传入对应todo --&gt; &lt;input class=\"toggle\" type=\"checkbox\" ng-model=\"todo.completed\" ng-change=\"toggleCompleted(todo)\"&gt; &lt;!-- 展示用label，双击时触发editTodo，并传入对应todo --&gt; &lt;label ng-dblclick=\"editTodo(todo)\"&gt;&#123;&#123;todo.title&#125;&#125;&lt;/label&gt; &lt;!-- 删除按钮，点击时，移除对应todo --&gt; &lt;button class=\"destroy\" ng-click=\"removeTodo(todo)\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;!-- 隐藏的再编辑表单，在表单提交时触发saveEdits --&gt; &lt;form ng-submit=\"saveEdits(todo, 'submit')\"&gt; &lt;!-- 再编辑input，值绑定到todo.title并不去除前后空格；按下esc时触发reverEdits事件，恢复到之前状态；失去焦点时自动提交；当双击展示用label时，todo和editedTodo相等，会触发todo-focus指令，显示再编辑input--&gt; &lt;input class=\"edit\" ng-trim=\"false\" ng-model=\"todo.title\" todo-escape=\"revertEdits(todo)\" ng-blur=\"saveEdits(todo, 'blur')\" todo-focus=\"todo == editedTodo\"&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer id=\"footer\" ng-show=\"todos.length\" ng-cloak&gt; &lt;!-- #todo-count 展示剩余待做todo数量 --&gt; &lt;span id=\"todo-count\"&gt;&lt;strong&gt;&#123;&#123;remainingCount&#125;&#125;&lt;/strong&gt; &lt;!-- 当count为1显示'item left'，否则显示'items left' --&gt; &lt;ng-pluralize count=\"remainingCount\" when=\"&#123; one: 'item left', other: 'items left' &#125;\"&gt;&lt;/ng-pluralize&gt; &lt;/span&gt; &lt;ul id=\"filters\"&gt; &lt;!-- 过滤状态，点击时触发$routeChangeSuccess事件，改变statusFilter，进而改变展示的数据 --&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == ''&#125; \" href=\"#/\"&gt;All&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == 'active'&#125;\" href=\"#/active\"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a ng-class=\"&#123;selected: status == 'completed'&#125;\" href=\"#/completed\"&gt;Completed&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 清除所有已完成todo，点击时触发clearCompletedTodos --&gt; &lt;button id=\"clear-completed\" ng-click=\"clearCompletedTodos()\" ng-show=\"completedCount\"&gt;Clear completed&lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;/script&gt; &lt;!-- 资源文件 --&gt; &lt;script src=\"node_modules/todomvc-common/base.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular-route/angular-route.js\"&gt;&lt;/script&gt; &lt;script src=\"node_modules/angular-resource/angular-resource.js\"&gt;&lt;/script&gt; &lt;!-- 逻辑文件 --&gt; &lt;script src=\"js/app.js\"&gt;&lt;/script&gt; &lt;script src=\"js/controllers/todoCtrl.js\"&gt;&lt;/script&gt; &lt;script src=\"js/services/todoStorage.js\"&gt;&lt;/script&gt; &lt;script src=\"js/directives/todoFocus.js\"&gt;&lt;/script&gt; &lt;script src=\"js/directives/todoEscape.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.jsapp.js是入口文件，主要是创建了模块，并配置了路由12345678910111213141516171819202122232425262728293031/*global angular *//** * The main TodoMVC app module * * @type &#123;angular.Module&#125; */angular.module('todomvc', ['ngRoute', 'ngResource']) .config(['$routeProvider', function($routeProvider) &#123; 'use strict'; var routeConfig = &#123; controller: 'TodoCtrl', templateUrl: 'todomvc-index.html', // 指定模板 resolve: &#123; store: function(todoStorage) &#123; // 在跳转路由之前载入正确的module // Get the correct module (API or localStorage). return todoStorage.then(function(module) &#123; module.get(); // Fetch the todo records in the background. return module; &#125;); &#125; &#125; &#125;; // 路由跳转 $routeProvider .when('/', routeConfig) .when('/:status', routeConfig) .otherwise(&#123; redirectTo: '/' &#125;); &#125;]); todoStorage.js这个文件是一个服务，主要实现了数据在localStorge中的存储和读写其实这一块没怎么看懂，主要是不太理解ngResource模块的作用，不过大概知道是存储和读取数据用的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/*global angular *//** * Services that persists and retrieves todos from localStorage or a backend API * if available. * * They both follow the same API, returning promises for all changes to the * model. */// 这一块是懵逼的...大概就是将数据存储在localStorage中angular.module('todomvc') .factory('todoStorage', function($http, $injector) &#123; 'use strict'; // Detect if an API backend is present. If so, return the API module, else // hand off the localStorage adapter return $http.get('/api') .then(function() &#123; return $injector.get('api'); &#125;, function() &#123; return $injector.get('localStorage'); &#125;); &#125;).factory('api', function($resource) &#123; 'use strict'; var store = &#123; todos: [], api: $resource('/api/todos/:id', null, &#123; update: &#123; method: 'PUT' &#125; &#125;), clearCompleted: function() &#123; var originalTodos = store.todos.slice(0); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); return store.api.delete(function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, delete: function(todo) &#123; var originalTodos = store.todos.slice(0); store.todos.splice(store.todos.indexOf(todo), 1); return store.api.delete(&#123; id: todo.id &#125;, function() &#123;&#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;); &#125;, get: function() &#123; return store.api.query(function(resp) &#123; angular.copy(resp, store.todos); &#125;); &#125;, insert: function(todo) &#123; var originalTodos = store.todos.slice(0); return store.api.save(todo, function success(resp) &#123; todo.id = resp.id; store.todos.push(todo); &#125;, function error() &#123; angular.copy(originalTodos, store.todos); &#125;) .$promise; &#125;, put: function(todo) &#123; return store.api.update(&#123; id: todo.id &#125;, todo) .$promise; &#125; &#125;; return store;&#125;).factory('localStorage', function($q) &#123; 'use strict'; var STORAGE_ID = 'todos-angularjs'; var store = &#123; todos: [], _getFromLocalStorage: function() &#123; return JSON.parse(localStorage.getItem(STORAGE_ID) || '[]'); &#125;, _saveToLocalStorage: function(todos) &#123; localStorage.setItem(STORAGE_ID, JSON.stringify(todos)); &#125;, clearCompleted: function() &#123; var deferred = $q.defer(); var incompleteTodos = store.todos.filter(function(todo) &#123; return !todo.completed; &#125;); angular.copy(incompleteTodos, store.todos); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, delete: function(todo) &#123; var deferred = $q.defer(); store.todos.splice(store.todos.indexOf(todo), 1); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, get: function() &#123; var deferred = $q.defer(); angular.copy(store._getFromLocalStorage(), store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, insert: function(todo) &#123; var deferred = $q.defer(); store.todos.push(todo); store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125;, put: function(todo, index) &#123; var deferred = $q.defer(); store.todos[index] = todo; store._saveToLocalStorage(store.todos); deferred.resolve(store.todos); return deferred.promise; &#125; &#125;; return store;&#125;); todoEscape.js这是一个指令，主要完成按下esc键，恢复再编辑input到原先状态12345678910111213141516171819202122232425/*global angular *//** * Directive that executes an expression when the element it is applied to gets * an `escape` keydown event. */// esc键绑定事件// 当按下Escape键时，执行attrs.todoEscape的表达式。angular.module('todomvc') .directive('todoEscape', function() &#123; 'use strict'; var ESCAPE_KEY = 27; return function(scope, elem, attrs) &#123; // 直接返回一个函数，实际上就是link函数；在link函数中绑定事件 elem.bind('keydown', function(event) &#123; if (event.keyCode === ESCAPE_KEY) &#123; // 按下esc，触发attrs.todoEscape对应的事件 scope.$apply(attrs.todoEscape); &#125; &#125;); scope.$on('$destroy', function() &#123; // 销毁时，解除绑定 elem.unbind('keydown'); &#125;); &#125;; &#125;); todoFocus.js这个指令主要完成再编辑input的显示和聚焦1234567891011121314151617181920/*global angular *//** * Directive that places focus on the element it is applied to when the * expression it binds to evaluates to true */angular.module('todomvc') .directive('todoFocus', function todoFocus($timeout) &#123; 'use strict'; return function(scope, elem, attrs) &#123; // 在二次编辑的input上绑定事件 scope.$watch(attrs.todoFocus, function(newVal, oldVal) &#123; // 当双击时，newVal为true if (newVal) &#123; $timeout(function() &#123; elem[0].focus(); &#125;, 0, false); &#125; &#125;); &#125;; &#125;); todoCtrl.js这是重头性，关键性逻辑全写在这123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/*global angular *//** * The main controller for the app. The controller: * - retrieves and persists the model via the todoStorage service * - exposes the model to the template and provides event handlers */angular.module('todomvc') .controller('TodoCtrl', function TodoCtrl($scope, $routeParams, $filter, store) &#123; 'use strict'; var todos = $scope.todos = store.todos; // 从localStorge中取出所有todo $scope.newTodo = ''; // 用来保存新创建的todo $scope.editedTodo = null; // 用来保存编辑过的todo $scope.$watch('todos', function() &#123; // 深度观察todos的值 $scope.remainingCount = $filter('filter')(todos, &#123; completed: false &#125;).length; // 更新未完成的todo数量 $scope.completedCount = todos.length - $scope.remainingCount; // 更新完成的todo数量 $scope.allChecked = !$scope.remainingCount; // 是否全部完成 &#125;, true); // Monitor the current route for changes and adjust the filter accordingly. $scope.$on('$routeChangeSuccess', function() &#123; // 观察路由跳转，并更新用来过滤的statusFilter var status = $scope.status = $routeParams.status || ''; $scope.statusFilter = (status === 'active') ? &#123; completed: false &#125; : (status === 'completed') ? &#123; completed: true &#125; : &#123;&#125;; &#125;); $scope.addTodo = function() &#123; // 输入框提交时触发 var newTodo = &#123; // 创建新todo title: $scope.newTodo.trim(), //newTodo是绑定在input输入框上 completed: false &#125;; if (!newTodo.title) &#123; // 空值，则不提交 return; &#125; $scope.saving = true; // saving用来标识input的禁用状态，为true则禁用 store.insert(newTodo) // 插入新todo .then(function success() &#123; // 成功则重置newTodo $scope.newTodo = ''; &#125;) .finally(function() &#123; $scope.saving = false; // 最后取消input的禁用状态 &#125;); &#125;; $scope.editTodo = function(todo) &#123; // 已添加的todo上双击时触发，会将双击的todo传入 $scope.editedTodo = todo; // 保存正在编辑的todo // Clone the original todo to restore it on demand. $scope.originalTodo = angular.extend(&#123;&#125;, todo); // 保留原先的todo，以备不时之需 &#125;; $scope.saveEdits = function(todo, event) &#123; // 再编辑input提交或者blur时触发 // Blur events are automatically triggered after the form submit event. // This does some unfortunate logic handling to prevent saving twice. if (event === 'blur' &amp;&amp; $scope.saveEvent === 'submit') &#123; // 提交时，会自动触发一次blur，所以手动阻止 $scope.saveEvent = null; return; &#125; $scope.saveEvent = event; // 保存事件类型(blur或submit) if ($scope.reverted) &#123; // 如果编辑后按esc，取消了编辑，则不保存 // Todo edits were reverted-- don't save. $scope.reverted = null; return; &#125; todo.title = todo.title.trim(); // 保存新编辑title if (todo.title === $scope.originalTodo.title) &#123; // title未发生改变，则不保存 $scope.editedTodo = null; return; &#125; store[todo.title ? 'put' : 'delete'](todo) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复title todo.title = $scope.originalTodo.title; &#125;) .finally(function() &#123; // 最后，重置editedTodo $scope.editedTodo = null; &#125;); &#125;; $scope.revertEdits = function(todo) &#123; // todoEscape时触发，将再编辑input恢复到编辑前的状态，会传入需要恢复的todo todos[todos.indexOf(todo)] = $scope.originalTodo; $scope.editedTodo = null; $scope.originalTodo = null; $scope.reverted = true; &#125;; $scope.removeTodo = function(todo) &#123; // 删除todo store.delete(todo); &#125;; $scope.saveTodo = function(todo) &#123; // 保存todo store.put(todo); &#125;; $scope.toggleCompleted = function(todo, completed) &#123; // 切换完成状态 if (angular.isDefined(completed)) &#123; // 如果completed曾经定义过，则直接使用 todo.completed = completed; &#125; // 更新localStorge上的todo的complete store.put(todo, todos.indexOf(todo)) .then(function success() &#123;&#125;, function error() &#123; // 保存出错，则恢复 todo.completed = !todo.completed; &#125;); &#125;; $scope.clearCompletedTodos = function() &#123; // 清除所有已经完成的todo store.clearCompleted(); &#125;; $scope.markAll = function(completed) &#123; // 将所有todo置为已完成 todos.forEach(function(todo) &#123; if (todo.completed !== completed) &#123; $scope.toggleCompleted(todo, completed); &#125; &#125;); &#125;; &#125;);","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"},{"name":"todoMVC","slug":"todoMVC","permalink":"http://yoursite.com/tags/todoMVC/"}]},{"title":"Maintainable-Javascript","date":"2017-06-30T02:39:31.000Z","path":"2017/06/30/Maintainable-Javascript/","text":"本文为阅读《编写可维护的Javascript》的笔记，记录了一些个人认为重要的点，带有一定个人理解，并未深入展开，如需详细了解可阅读原书籍。这本书，是从可维护性的角度出发，介绍了如何编写可维护性的js代码，读完，还是有收获的，特别是第二部分的编程实践，很基础，但也很实用。综合来看，还是一本不错的书籍，值得一看。PS:本书主要从可维护性的角度出发，有些写法并不一定是最优解，因人而异，取其精华，去其糟粕。本人github上有很多本人学习前端时保存的demo，都带有注释，适合新手入门。如果对大家有帮助。望star~https://github.com/BryanAdamss/SourceSave 《编写可维护的Javascript》笔记编程风格基本格式化 代码缩进 使用4空格代替tab；不同编辑器对于tab的解释不一样，有的是2空格长度，有的是4空格长度； 语句结尾 总是使用分号;结尾 行的长度 单行不超过80个字符 空行 使用空行分隔语义不同的代码段 命名 驼峰命名法 变量 名词开头-&gt;count、myName 函数 动词开头-&gt;(can、has、is、get、set)isEnabled、getName 构造函数 首字母大写123function Person(name)&#123; this.name=name;&#125; 常量 全大写，下划线区分12var MAX_COUNT=10, URL='https://github.com/BryanAdamss/SourceSave'; 直接量 字符串-&gt;单双引号皆可，不过个人推荐用单引号，因为在拼接html字符串时很方便) 数字-&gt;不省略小数点前后的数字 null-&gt;当做对象占位符使用 undefined-&gt;已声明但没有赋值的变量会获得此值 对象直接量 1234567// 不好的写法var book=new Object();book.title='Javascript';// 好的写法var book=&#123; title:'Javascript'&#125;; 数组直接量 1234// 不好的写法var colors=new Array('red','green');// 好的写法var colors=['red','green']; 注释 只在需要注释的时候才添加注释-&gt;只在需要让代码变得更清晰的时候添加注释 逻辑复杂难于理解的代码 可能被误认为错误的代码 语句和表达式 switch语句 js中的switch不同于其他语言，switch的条件和case从句可以是任意类型值，其他语言必须是原始值或者常量 with语句-&gt;不要使用 循环 for-&gt;在初始化中缓存遍历次数 123for(var i=0,len=arr.length;i&lt;len;i++)&#123; doSth();&#125; for-in-&gt;配合hasOwnProperty过滤非实例属性/方法 123456for(var prop in testObj)&#123; if(testObj.hasOwnProperty(prop))&#123; console.log('属性名为:'+prop); console.log('属性名对应的属性值为:'+testObj[prop]); &#125;&#125; forEach-&gt;针对数组用forEach 总结:对象(除数组)用for-in，数组用forEach，其他用for 变量、函数和运算符 变量声明 单var声明 123var a=3, b=4, c=5; 将局部变量的定义做为函数内第一条语句 1234567891011121314151617181920 function getName()&#123; var a=3, b=4, c=5; &#125; ``` - 函数声明 - 先声明再使用 - 函数内声明函数时，可将函数声明放在变量生命之后 ```javascript function getName()&#123; var a=3, b=4, c=5; function getOtherName()&#123; doSth(); &#125; getOtherName(); &#125; 立即调用函数 使用圆括号包裹123var a=(function()&#123; doSth();&#125;)(); 严格模式-&gt;只在局部使用 相等-&gt;使用=== eval-&gt;避免使用 原始包装类型-&gt;避免使用原始包装类型构造函数 编程实践UI层的松耦合 将javascript从css中抽离 禁用css表达式1234/*不好的写法*/.box&#123; width:expression(document.body.offsetWidth+\"px\");&#125; 将css从javascript中抽离 用js控制样式类，而不是直接操纵样式 当需要控制元素位置时，可直接用js操纵样式(top,left…) 将javascript从HTML中抽离 不要在html标签上用onclick=…，改用事件addEventListener 将HTML从javascript中抽离 使用客户端模板引擎，例如handlebars 避免使用全局变量 全局变量带来的问题 命名冲突 代码脆弱性 难以测试 意外的全局变量 未声明直接赋值了 12345function ()&#123; var a=3;// 局部变量 var b;// 局部变量 c=3;// 全局变量&#125; 如何避免 总是使用var来声明变量，即时是声明全局变量 单全局变量 只声明一个全局变量，所有功能全挂载到这个全局变量上 模块 规范CommonJs、AMD、CMD 对应实现NodeJs、RequireJs、SeaJs 零全局变量 使用立即函数包裹123(function(win)&#123; // doSth&#125;)(window); 事件处理 不好的写法 1234567function handleClick(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal';&#125;ele.addEventListener('click',handleClick,false); 事件处理规则1 隔离应用逻辑-&gt;将应用(业务)逻辑从事件处理程序中抽离 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event); &#125;, showPopup:function(event)&#123; var popup=document.getElementById('popup'); popup.style.left=event.clientX+'px'; popup.style.top=event.clientY+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 不要分发事件对象-&gt;只传需要的信息 应用逻辑不应当依赖于event对象来正确完成功能 将event对象做为参数并不能告诉你event的哪些属性是有用的 测试时，需要重建event对象 最佳实践 让事件处理程序使用event对象来处理事件，然后拿到需要的数据传给应用逻辑 1234567891011121314var MyApp=&#123; handleClick:function(event)&#123; this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 让事件处理程序成为接触到event对象的唯一的函数，事件处理程序应当在进入应用逻辑之前针对event对象执行任何必要的操作。包括阻止默认事件和冒泡。 12345678910111213141516var MyApp=&#123; handleClick:function(event)&#123;// 在事件处理程序中针对event进行必要的处理 event.preventDefault(); event.stopPropagation(); this.showPopup(event.clientX,event.clientY);// 只传需要的信息 &#125;, showPopup:function(x,y)&#123; var popup=document.getElementById('popup'); popup.style.left=x+'px'; popup.style.top=y+'px'; popup.className='reveal'; &#125;&#125;;ele.addEventListener('click',function(event)&#123; MyApp.handleClick(event);&#125;,false); 避免空比较 检测原始值的类型 字符串、数字、布尔、undefined-&gt;typeof 1234typeof 'a';// 'string'typeof 3;// 'number'typeof true;// 'boolean'typeof undefined;// 'undefined' null-&gt;一般不用于类型检测，除非null是一种可预期的页面时可用===和!==来判断是否为null值 1234var ele=document.getElementById('my-div');if(ele!==null)&#123;// 如果DOM元素不存在，则ele就为null，此时null是一个可预期的值，所以可以===或!==来判断 // doSth &#125; 检测引用值的类型 使用value instanceof constructor 123456789if(value instance Data)&#123; // doSth&#125;if(value instance RegExp)&#123; // doSth&#125;if(value instance Object)&#123; // doSth &#125; 但函数、数组不能用instanceof来判断，因为存在跨帧问题(cross-frame) 检测函数(判断某一引用值是否是函数(是否是函数类型)) 使用typeof 12function myFn()&#123;&#125;typeof myFn;// 'function' 使用typeof检测IE8及以下DOM元素的方法时，会返回’object’;退而求其次会使用in来判断；因为DOM明确定义，了解到对象成员如果存在则意味着它是一个方法 123if('querySelectorAll' in document)&#123; var imgs=document.querySelectorAll('img');&#125; 检测数组(判断某一引用值是否是数组(是否是数组类型)) 使用ES5的isArray 不支持的则使用Object.prototype.toString.call(value)1234567function isArray(value)&#123; if(typeof Array.isArray==='function')&#123; return Array.isArray(value); &#125;else&#123; return Object.prototype.toString.call(value)==='[object Array]'; &#125;&#125; 检测属性/方法存在性 使用prop in obj 检测属性/方法是否为实例属性-&gt;obj.hasOwnProperty(‘prop’) IE8及以下判断是否为实例属性-&gt;需先判断hasOwnProperty的存在性 总结 判断数据类型 原始值 字符串、数字、布尔、undefined-&gt;typeof 如if(typeof &#39;test&#39;===&#39;string&#39;){...} null-&gt;只有在null是一个可预期的值时，才用来比较，使用===，!== 引用值 自定义、非函数、非数组对象-&gt;使用obj instanceof constructor 如obj instanceof Data 函数/方法 非DOM对象的方法/函数-&gt;typeof 如typeof myFn===&#39;function&#39; DOM对象的方法-&gt;无法使用typeof，只能通过in判断它存在，然后直接使用 数组 支持isArray-&gt;Array.isArray(value) 不支持-&gt;Object.prototype.toString.call(value)===&#39;[object Array]&#39; 判断属性/方法存在性 一般属性/方法-&gt;统一使用in 实例属性存在性-&gt;统一使用hasOwnProperty IE8及以下判断实例属性存在性-&gt;先判断hasOwnProperty的存在性，再调用hasOwnProperty 将配置数据从代码中抽离 配置数据 URL 展现给用户的字符串 重复的值 设置(每页的配置项) 任何可能发生变更的值 抽离 将配置数据抽离成一个对象 1234var config=&#123; MSG_INVALID_VALUE:'不合法的值', URL:'https://github.com/BryanAdamss/SourceSave'&#125;; 将配置数据抽离成一个对象，并放在一个单独的文件中 抛出自定义错误 如果没有通过try-catch语句捕获，抛出任何值都将引发一个错误。如直接throw &#39;message&#39;，会引发一个错误 何时抛出错误 抛出错误最佳的地方是在工具函数中，如addClass()函数，它是通用脚本的一部分，会在很多地方使用。-&gt;在javascript类库中使用 错误类型 Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError 不是你的对象不要动 不要修改原生对象以及一些类库对象 原则：将已经存在的js对象当做工具函数库那样使用 不覆盖方法 不覆盖原对象的方法 不新增方法 不在不属于你的对象上添加方法 不删除方法 不要删除一个不是你的对象上的方法 更好方法 继承原对象，在其基础上扩充 阻止修改(锁定后，将无法解锁) 防止扩展-&gt;无法新增属性和方法，可删除 Object.preventExtension(obj); Object.isExtensible(); 密封对象-&gt;已存在的属性、方法无法被删除，可修改 Object.seal(obj); Object.isSealed(); 冻结对象-&gt;防止扩展+密封，无法删除，无法修改 Object.freeze(obj); Object.isFrozen(); 浏览器嗅探 UA检测 缺点 UA可以被修改 浏览器为了兼容性，都会包含其他浏览器的UA字符串 特性检测-&gt;根据功能(特性)来检测 不要进行特性推断-&gt;不要根据一个特性的是否存在去推断另一个特性是否存在 不要进行浏览器推断-&gt;不要根据一个特性的是否存在去推断是某种浏览器 优先级:特性检测&gt;UA检测 自动化文章第三部分介绍的是前端自动化方面的知识，但用的是Ant(需要JAVA环境)，由于现在用gulp的比较多，所以这一块就只是大概扫了一下。 流程 构建-&gt;验证-&gt;合并、加工-&gt;精简、压缩-&gt;文档化-&gt;自动化测试-&gt;集成","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Angualr-guide","date":"2017-06-07T01:19:44.000Z","path":"2017/06/07/Angualr-guide/","text":"本文为自己学习angular的笔记，带有个人理解。学习的版本为1.2.32对应的源码在https://github.com/BryanAdamss/SourceSave/tree/master/AngularJs本仓库还包含大量本人前端练习用的demo，希望对大家有帮助。望star~ Angular学习笔记Angular适用场景 适合：大量CRUD(增删改查)操作的场景，如后台管理系统 不适合：游戏、大量UI操作的场景 DataBinding 双向：view、model之间会相互同步数据 Controller 在controller中做 设置$scope的初始状态 为$scope添加一些行为 不要在controller中做 手动操作DOM：controller中应该仅包含业务逻辑；如果在controller中添加表现相关逻辑，会严重影响测试；DOM操作应该封装在directives中；另外AngularJs中也封装了一些常用DOM操作指令，如ng-show等。 格式化输入： Use AngularJS form controls instead. 过滤输出： Use AngularJS filters instead. 传递数据或状态： Use AngularJS services instead. 管理其他组件的周期：例如在controller中创建services Services 特点 lazy实例化：只有当某个services被依赖时，它才会被实例化 单例：每个依赖services的component都会得到由service factory产生的service单实例的一个引用（service都是单例的，只要创建了一个Service，那么程序都在使用这唯一的Service) 以$开头的，都是内置服务，eg：$http service可以被用来传递数据、实现代码复用 创建并使用：通过service工厂函数来创建（factory函数）123456789101112131415 angular.module('myServiceModule', []). controller('MyController', ['$scope', 'notify', function($scope, notifyInstance) &#123;//3.这里notyfy被依赖，所以立马被实例化并将2处的匿名函数赋值给了notifyInstance $scope.callNotify = function(msg) &#123; notifyInstance (msg); &#125;; &#125;]).factory('notify', ['$window', function(win) &#123;// 1.这里注册了一个notify的服务，而且还依赖另一个内置服务$winodw，注意这里还只是注册一个notify的构造函数，并没有创建notify的实例 var msgs = []; return function(msg) &#123;// 2.return里的是当服务被加载(依赖时)返回的实例对象或函数 msgs.push(msg); if (msgs.length === 3) &#123; win.alert(msgs.join('\\n')); msgs = []; &#125; &#125;; &#125;]); Scope 特点 它只是一个普通的js对象 它指向了应用的model 它是表达式的执行环境context 它拥有和DOM一样的树形结构 它能监视表达式 它能传播事件 它提供了$watch来观察模型的变化 它提供了$apply来传播模型的变化 它可以嵌套以限制对应用程序组件属性的访问，同时提供对共享模型属性的访问。 它是controller和view间的胶水 层次结构（类似DOM的树形结构） 每个angularApp都有一个根scope，$rootScope，$rootScope有一个或多个子scope 查找某属性时，会像js作用域一样，逐层向上找 angularJs会在每个绑定了scope元素的class上添加ng-scope directive可以创建scope 获取DOM元素上绑定的scope 可以通过angular.element(dom元素).scope() 在chrome中，也可以通过 angular.element($0).scope()或者在选中一个dom元素后直接在控制台中$scope，就能得到相应dom上的$scope 可以通过安装 AngularJS Batarang插件来查看 事件传播 $emit(eventName) 向上传播事件 $broadcast(eventName) 向下传播事件 生命周期： Creation-&gt; Watcher registration-&gt; Model mutation-&gt; Mutation observation-&gt; Scope destruction DependencyInjection(DI) 使用 services、directives、filter、animation可以将”services”、”value”型组件作为依赖注入 123456789angular.module('myModule', []).factory('serviceId', ['depService', function(depService) &#123; // ...&#125;]).directive('directiveName', ['depService', function(depService) &#123; // ...&#125;]).filter('filterName', ['depService', function(depService) &#123; // ...&#125;]); controller可以将”services”、”value”型组件作为依赖注入，但他们还可以注入一些特殊的依赖如$scope 1234567someModule.controller('MyController', ['$scope', 'dep1', 'dep2', function($scope, dep1, dep2) &#123;...$scope.aMethod = function() &#123;...&#125;...&#125;]); 为module提供run、config方法时，可以使用DI config接收一个函数，函数可以注入”provider”、”constant”型组件；不可将”services”、”value”型注入到config中 run接收一个函数，函数可以注入”services”、”value”以及”constant”(常数)型组件；不可将”providers”型注入到run中12345angular.module('myModule', []).config(['depProvider', function(depProvider) &#123;// ...&#125;]).run(['depService', function(depService) &#123;// ...&#125;]); 依赖声明 行内数组声明(推荐、最优) 123someModule.controller('MyController', ['$scope', 'greeter', function($scope, greeter) &#123;// ...&#125;]); 使用$inject(可让controller通过js压缩) 12345var MyController = function($scope, greeter) &#123;// ...&#125;MyController.$inject = ['$scope', 'greeter'];someModule.controller('MyController', MyController); 隐式声明依赖(压缩时，会出错)-&gt;尽量避免用此方法 123someModule.controller('MyController', function($scope, greeter) &#123;// ...&#125;); 通过在ng-app指令所在html元素上添加 ng-strict-di指令，以限制隐式声明的使用(若使用隐式声明 ，会报错) Templates angularJS中的template是由html以及angularJs声明的元素及特性组成。angularJs通过controller组合model中的信息和模板以呈现动态的view给用户 templates中可以使用 directive {{}} filter form controller 1234567891011&lt;html ng-app&gt; &lt;!-- Body tag augmented with ngController directive --&gt; &lt;body ng-controller=\"MyController\"&gt; &lt;input ng-model=\"foo\" value=\"bar\"&gt; &lt;!-- Button tag with ngClick directive, and string expression 'buttonText' wrapped in \"&#123;&#123; &#125;&#125;\" markup --&gt; &lt;button ng-click=\"changeFoo()\"&gt;&#123;&#123;buttonText&#125;&#125;&lt;/button&gt; &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在复杂的app中,可以将不同的模板放在单独的html中，然后通过ng-view来引用 Expressions 主要用在插值绑定(interpolation bindings)中，但也可以直接用在指令中；如ng-click=”functionExpression()”；以下都是合法的 1+2 a+b user.name items[index] 和Js的表达式的异同 context：js中的context一般是全局变量window；angular中表达式的context则是scope js中尝试计算未定义的属性，会报错；angular则不会直接报错，而是转为undefined或null 在angular表达式中可以用filter在展示数据前进行数据格式化 在angular的表达式中没有条件控制相关语句；如if、for等，但三元操作符中可以用 在angular的表达式中不能有函数声明，及时在ng-init指令中 在angular的表达式中不能创建正则表达式 在angular的表达式中不能通过new创建对象 在angular的表达式中不能使用位运算、void、逗号等操作符 如果想解析angularJs表达式，不要用eval，使用$eval 总结：如果想使用复杂js代码，可以将其封装在controller中，然后在view中调用。不推荐直接在表达式中书写大量代码； $event 在执行ng-click、ng-focus等指令时，会在表达式范围内将$event暴露出来，$event是类似jquery Event的对象 one-time绑定(数据只绑定一次) 优势：只绑定一次，可减少监视次数 使用：在变量前添加双冒号；类似{{::name}} 何时( 当表达式被设定后，就不会被改变时 ) 用在插值文本和特性时 1&lt;div name=\"attr: &#123;&#123;::color&#125;&#125;\"&gt;text: &#123;&#123;::name | uppercase&#125;&#125;&lt;/div&gt; 当用directive双向绑定数据并且参数不会改变时 1234567891011someModule.directive('someDirective', function() &#123; return &#123; scope: &#123; name: '=', color: '@' &#125;, template: '&#123;&#123;name&#125;&#125;: &#123;&#123;color&#125;&#125;' &#125;;&#125;);&lt;div some-directive name=\"::myName\" color=\"My color is &#123;&#123;::myColor&#125;&#125;\"&gt;&lt;/div&gt; 指令中包含表达式时 123&lt;ul&gt; &lt;li ng-repeat=\"item in ::items | orderBy:'name'\"&gt;&#123;&#123;item.name&#125;&#125;;&lt;/li&gt;&lt;/ul&gt; Interpolation 针对布尔attr，如disabled、required、selected、checked、readOnly、open，不要使用原生的，使用ng-disabled、ng-required… 使用ng-attr-xxx绑定任意特性，如ng-attr-cx；若为驼峰形式，则用下划线代替，如viewBox，则使用ng-attr-view_box Filters 在view中的语法 正常语法 1&#123;&#123; expression | filterName &#125;&#125; Filter Chain-&gt;用上一个filter的输出作为下一个filter的输入 1&#123;&#123; expression | filter1Name | filter2Name | ... &#125;&#125; 带参数 12&#123;&#123; expression | filterName:argument1:argument2:... &#125;&#125;如 &#123;&#123; 1234 | number:2 &#125;&#125; 当filter用在controller、services、directives上时，需采用Filter形式 需要在controller中使用number过滤器时1234angular.module('numberFilterExample', []).controller('ExampleController', ['numberFilter', function(numFilter) &#123; // ....&#125;]); 创建自定义filter 使用filter函数123456789101112angular.module('myReverseFilterApp', []).filter('reverse', function() &#123; return function(input) &#123;// return 一个函数 input = input || ''; var out = ''; for (var i = 0; i &lt; input.length; i++) &#123; out = input.charAt(i) + out; &#125; return out; &#125;;&#125;)// html中直接&#123;&#123; data | reverse&#125;&#125; 常用filter date日期格式-&gt; {{ now | date:'yyyy-MM-dd hh:mm:ss a' }} currency货币格式化 fiter对数组、字符串、对象等进行筛选显示 1234567891011$scope.city = [&#123; id: \"001\", name: \"上海\" &#125;, &#123; id: \"002\", name: \"北京\"&#125;];// view &#123;&#123;city&#125;&#125; &#123;&#123;city|filter:'上海'&#125;&#125;// 默认筛选出所有value值为'上海'的object &#123;&#123;city|filter:&#123;name:'北京'&#125; &#125;&#125;// 筛选出name为北京的object orderBy排序 {{city |orderBy:'id'}} 默认正序 {{city |orderBy:'-id'}} 反序 json 将对象解析成json，主要用来调试 Forms angularJs对表单域做了增强，添加了很多功能 使用ng-model就可以将表单的值和model进行双向绑定 使用novalidate屏蔽浏览器原生验证 angualrJs会添加一些class类，来标识验证的状态，根据这些验证状态class类，来写不同的样式 ng-valid：model验证通过 ng-invalid：model未验证通过 ng-valid-[ruleName]：ruleName的验证规则已通过 ng-invalid-[ruleName ]：ruleName的验证规则未通过 ng-pristine：这个表单域还没有交互过(未修改过) ng-dirty：这个表单域已经交互过(修改过) ng-touched：这个表单域 失去焦点 ng-untouched：这个表单域未失去焦点 ng-pending：异步验证还未完成 可以根据表单验证的一些状态，来辅助添加帮助信息 通过ng-model-options来设置一些属性 ng-model-options=”{ updateOn: ‘blur’ }” 在blur时更新model 延时更新model ng-model-options=”{ debounce: 500 }” ng-model-options=”{ updateOn: ‘default blur’, debounce: { default: 500, blur: 0 } }” 可通过编写directive来创建自己的验证规则、表单域 可以修改内置的验证规则 相关状态 字段错误信息-&gt;formName.fieldName.$error-&gt;验证通过的规则会显示false，未通过的显示true 字段无效信息-&gt;formName.fieldName.$invalid 字段有效信息-&gt;formName.fieldName.$valid 字段是否更改-&gt;formName.fieldName.$dirty 字段是否未更改-&gt;formName.fieldName.$pristine $scope.formName.$setPristine-&gt;将表单恢复到最初状态，class、$dirty等都被恢复 Directives 匹配 12345678&lt;div ng-controller=\"Controller\"&gt;&lt;!-- 下面这几种形式，都将input和model中name绑定起来了，绑定这个指令就匹配上了 --&gt; Hello &lt;input ng-model='name'&gt; &lt;hr/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;!-- 建议形式 --&gt; &lt;span ng:bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span ng_bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span data-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt; &lt;span x-ng-bind=\"name\"&gt;&lt;/span&gt; &lt;br/&gt;&lt;/div&gt; ng-attr-xxx-&gt;所有ng-attr开头的特性，最后都会转化到原生的特性上，建议不要在原生的特性上绑定值，都用ng-attr开头(因为某些原生特性和ng配合的不好) 123&lt;svg&gt; &lt;circle ng-attr-cx=\"&#123;&#123;cx&#125;&#125;\"&gt;&lt;/circle&gt;&lt;!-- 将&#123;&#123;cx&#125;&#125;绑定到了原生的cx上 --&gt;&lt;/svg&gt; 指令类型 A（attribute）、E（element）、M（comment）、C（class）;M和C不常用，如果需要兼容IE8，建议全部用A 1234&lt;my-dir&gt;&lt;/my-dir&gt;&lt;span my-dir=\"exp\"&gt;&lt;/span&gt;&lt;!-- directive: my-dir exp --&gt;&lt;span class=\"my-dir: exp;\"&gt;&lt;/span&gt; 注意：由于历史原因，浏览器在解析html标签和标签attribute时，会自动忽略大小写，统一使用小写形式；这就导致了，用驼峰形式定义的html标签（&lt;myTag&gt;）和特性会被转换为全小写（&lt;mytag&gt;）；那么用驼峰形式定义的指令在匹配E和A时，就找不到（无法匹配），为了解决这问题，ng会在定义时用的驼峰形式directive(“myTag”,xxx)转换成my-tag，这样在html中my-tag形式的标签和特性就会被匹配到。如果定义时没用驼峰形式(全小写)，则不会转换，直接匹配。驼峰形式的指令名在匹配M和C时不会存在转换-&gt;总结:在定义指令时如果用了驼峰形式匹配EA，则在html中使用时就要转换成短横线连接的形式如myTag转换成my-tag-&gt;最佳实践：ng中指令若用驼峰则html中用短横线连接； 创建指令 module.directive(directiveName,fn); 12345678910angular.module('docsSimpleDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123;// 尽量都返回一个object，不要只返回一个函数 template: 'Name: &#123;&#123;customer.name&#125;&#125; Address: &#123;&#123;customer.address&#125;&#125;' // 除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 &#125;;&#125;); templateUrl-&gt;除非你的模板很小，否则使用templateUrl来引入外部单独的模板html文件 当replace为true时，tpl文件内容必须被包裹在一个标签内，也即tpl文件只能有一个根标签；即不能存在有文本未被标签包裹，也不能存在多个根标签；因为替换的时候ng找不到一个唯一的节点做为替换节点，所以必须得有一个最外层的根节点；template也存在同样情况-&gt;最佳实践，任何情况下，都让模板文件包裹在一个根标签中，这样也方便文件的组织管理 可以在模板中使用$scope中的变量 templateUrl中可以指定type=text/ng-template的script为模板，只需要在templateUrl中写上script模板的id；注意：这个script模板必须在ng-app中，而且，若replact为true，则也需要一个根标签1234567891011angular.module('docsTemplateUrlDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; templateUrl: 'my-customer.html' &#125;;&#125;); restrict-&gt;设置指令的匹配模式(AEMC)；默认是AE（匹配attribute、element类型指令)；M和C不常用 123456789101112131415angular.module('docsRestrictDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.customer = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', templateUrl: 'my-customer.html' &#125;;&#125;);// 什么情况下该用元素名，什么情况下该用属性名？ 当创建一个含有自己模板的组件的时候，建议使用元素名，常见情况是，当你想为你的模板创建一个DSL（特定领域语言）的时候。如果仅仅想为已有的元素添加功能，建议使用属性名.// 当需要创建一个自己的组件时-&gt;创建E型指令// 为已有元素添加新功能-&gt;创建A型指令 isolate scope 存在原因：若无独立作用域，则在一个作用域下，多个指令无法独立执行；使用独立作用域，可以将指令限制在独立的作用域下执行，互不干扰 创建：在创建directive时指定scope属性 1234567891011angular.module('docsIsolateScopeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.naomi = &#123; name: 'Naomi', address: '1600 Amphitheatre' &#125;; $scope.igor = &#123; name: 'Igor', address: '123 Somewhere' &#125;;&#125;]).directive('myCustomer', function() &#123; return &#123; restrict: 'E', scope: &#123; customerInfo: '=info' // 将customerInfo绑定到指令所在元素的info特性上，如果外面的特性也叫customerInfo，则可以直接使用缩写形式\"=\" &#125;, templateUrl: 'my-customer-iso.html' &#125;;&#125;); 独立作用域会隔离除你添加到scope: {} 对象中的数据模型之外的一切东西。 因为它可以阻止除你传入的数据模型之外的一切东西改变你内部数据模型的状态。 如果要使你的组件在应用范围内可重用，那么使用scope选项去创建一个独立作用域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &#123;&#123;books&#125;&#125; &lt;div book-list book-a=\"books\" book-b=\"books\" book-c=\"&#123;&#123;title&#125;&#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive(\"bookList\", function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt;&lt;li ng-repeat=\"book in books\"&gt;&#123;&#123;book.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;', // bookList指令中包含一个booAdd指令 replace: true, // scope: false,// scope为独立作用域，当为false，表示直接使用父级作用域，为true，表示创建一个作用域并继承自父作用域；当scope为一个对象时，则表示创建了一个不继承父作用域的继承链的独立作用域(就是可以访问到父作用域，但是无法访问到父作用域之上的作用域) scope: &#123; // &amp;attr表示作用域将父作用域的属性包装成一个函数，从而以函数的形式读写父作用域的属性；一般用在执行父作用域上的某个事件处理函数；若作用域和父作用域的属性名称一要，则可以使用简写形式&amp;,@和=同理 a: \"&amp;bookA\" // 会查找当前指令匹配的元素上的bookA特性，然后取得值books，并将books做为a调用的返回值进行返回； // =attr会将作用域上的属性和父级的作用域上的属性进行双向绑定，任何一方的修改都会修改另外一方 // b: \"=bookB\" // 会查找当前指令匹配的元素上的bookB特性，会将其值和b进行双向绑定 // @attr代表只能读取父级作用域上的值，单向的，并只能读取简单值，引用值不行，因为他最终得到的只会是简单值； // c: \"@bookC\" &#125;, controller: function($scope) &#123; $scope.books = $scope.a(); console.log($scope.a()); // $scope.books = $scope.b; // $scope.b.push(&#123; // name: \"nodeJs\" // &#125;); // console.log($scope.b); // $scope.title = $scope.c; // console.log($scope.c); &#125;, &#125; &#125;).controller('myController', ['$scope', function($scope) &#123; $scope.books = [&#123; name: \"php\" &#125;, &#123; name: \"js\" &#125;, &#123; name: \"java\" &#125;]; $scope.title = \"书籍\"; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; compile 主要用在DOM渲染之前( link之前) 改变DOM结构，并不需要$scope参数。它必须返回一个link函数，因此如果指令中compile和link都写了，则link会被覆盖-&gt;用的比较少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myController\"&gt; &lt;div ng-repeat=\"user in users\" my-tag my-tag2&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/angularjs.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []).directive('myTag', function() &#123; return &#123; restrict: \"EAMC\", template: '&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;/div&gt;', replace: true, compile: function(tElement, tAttrs, transclude) &#123; // 主要用来在实际渲染之前修改DOM结构，compile必须返回一个link函数 // console.log(tElement); //返回匹配的当前类jQuery对象 // console.log(tAttrs); // 返回tElement上的所有attr // console.log(transclude); // 如果指令中transclue为true，则它返回的就是被transclude的原始数据 console.log(\"myTag 编译阶段\"); // 在实际渲染前变更DOM结构 tElement.append(angular.element(\"&lt;h1&gt;test&lt;/h1&gt;\")); return &#123; // 若在compile中直接return一个函数，则返回的是postLink函数 pre: function(scope, iElement, iAttrs, controller) &#123; // preLink是在compile阶段结束后，link阶段之前触发 console.log(\"myTag preLink\"); &#125;, post: function(scope, iElement, iAttrs, controller) &#123; // postLink是指令link后触发 console.log(\"myTag postLink\"); &#125; &#125; &#125;, link: function(scope, iElement, iAttrs, controller) &#123; // 主要在link中进行绑定事件和操纵DOM；一般定义了compile，就不会定义link了;此处的link其实就是compile中postLink console.log(\"因为上面执行了，compile，所以我不会再被执行了\"); &#125; &#125; &#125;).directive('myTag2', function() &#123; return &#123; restrict: \"EAMC\", compile: function(tElement, tAttrs, transclude) &#123; console.log(\"myTag2 编译阶段\"); return &#123; pre: function() &#123; console.log(\"myTag2 preLink\"); &#125;, post: function() &#123; console.log(\"myTag2 postLink\"); &#125; &#125; &#125; &#125; &#125;).controller(\"myController\", [\"$scope\", function($scope) &#123; $scope.users = [&#123; id: 10, name: \"张三\" &#125;, &#123; id: 20, name: \"李四\" &#125;]; &#125;]); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; link 主要在这里来操作DOM和添加事件 scope-&gt;指令所处的作用域(如果有独立作用域，则为独立作用域，否则值为父级的作用域); element-&gt;指令所匹配的那个元素 attrs-&gt;指令匹配元素的所有特性的集合 controller-&gt;指令需要依赖的controller实例123456789101112131415161718192021222324252627282930angular.module('docsTimeDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.format = 'M/d/yy h:mm:ss a';&#125;]).directive('myCurrentTime', ['$interval', 'dateFilter', function($interval, dateFilter) &#123; function link(scope, element, attrs) &#123; var format, timeoutId; function updateTime() &#123; element.text(dateFilter(new Date(), format)); &#125; scope.$watch(attrs.myCurrentTime, function(value) &#123; format = value; updateTime(); &#125;); element.on('$destroy', function() &#123; $interval.cancel(timeoutId); &#125;); // start the UI update process; save the timeoutId for canceling timeoutId = $interval(function() &#123; updateTime(); // update DOM &#125;, 1000); &#125; return &#123; link: link &#125;;&#125;]); replace-&gt;是否替换匹配的元素 若为true则在找到匹配的元素后，会用指令中的template内容替换匹配的内容(包括被匹配的元素)；默认情况下，指令会在找到匹配的元素时，会将匹配元素的内容替换为指令中template的内容； 一般在匹配E时，会选择将其设置为true，因为一般E型指令都是创建新标签，是不符合规范的，所以会选择将其替换 transclude-&gt;主要用来处理指令嵌套 默认情况下，指令会替换匹配元素内部的内容，这样就无法实现指令的相互嵌套使用(原指令的内容会被新指令全部替换掉)； 当设置transclude为true时，则可以保留原先的指令模板以及对应的作用域；注意，在新指令的模板中要用ng-transclude保留老指令的内容； 123456789101112// jsangular.module('docsTransclusionDirective', []).controller('Controller', ['$scope', function($scope) &#123; $scope.name = 'Tobias';&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, templateUrl: 'my-dialog.html' &#125;;&#125;);// my-dialog.html&lt;h1&gt;新内容&lt;/h1&gt;&lt;div class=\"alert\" ng-transclude&gt;&lt;/div&gt; &lt;!-- 指定ng-transclude --&gt; 仅当你要创建一个包裹任意内容的指令的时候使用transclude: true 创建一个包裹任意内容的dialogBox 12345678910111213141516171819202122232425262728293031323334353637// jsangular.module('docsIsoFnBindExample', []).controller('Controller', ['$scope', '$timeout', function($scope, $timeout) &#123; $scope.name = 'Tobias'; $scope.message = ''; $scope.hideDialog = function(message) &#123; $scope.message = message; $scope.dialogIsHidden = true; $timeout(function() &#123; $scope.message = ''; $scope.dialogIsHidden = false; &#125;, 2000); &#125;;&#125;]).directive('myDialog', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123; 'close': '&amp;onClose' // &amp;prop 用来绑定一个函数到独立作用域，允许独立作用域调用它，同时保留了函数的原来作用域；当你的指令想要开放一个API去绑定特定的行为，在scope选项中使用&amp;prop。 &#125;, templateUrl: 'my-dialog-close.html' &#125;;&#125;);// html&lt;div ng-controller=\"Controller\"&gt; &#123;&#123;message&#125;&#125; &lt;my-dialog ng-hide=\"dialogIsHidden\" on-close=\"hideDialog(message)\"&gt; Check out the contents, &#123;&#123;name&#125;&#125;! &lt;/my-dialog&gt;&lt;/div&gt;// my-dialog-close.html&lt;div class=\"alert\"&gt; &lt;a href class=\"close\" ng-click=\"close(&#123;message: 'closing for now'&#125;)\"&gt;&amp;times;&lt;/a&gt; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;!-- 保留原先指令内容 --&gt;&lt;/div&gt; 创建添加事件的指令 12345678910111213141516171819202122232425262728293031323334353637angular.module('dragModule', []).directive('myDraggable', ['$document', function($document) &#123; return &#123; link: function(scope, element, attr) &#123; // 在link中为指令匹配的元素element绑定事件 var startX = 0, startY = 0, x = 0, y = 0; element.css(&#123; position: 'relative', border: '1px solid red', backgroundColor: 'lightgrey', cursor: 'pointer' &#125;); element.on('mousedown', function(event) &#123; // Prevent default dragging of selected content event.preventDefault(); startX = event.pageX - x; startY = event.pageY - y; $document.on('mousemove', mousemove); $document.on('mouseup', mouseup); &#125;); function mousemove(event) &#123; y = event.pageY - startY; x = event.pageX - startX; element.css(&#123; top: y + 'px', left: x + 'px' &#125;); &#125; function mouseup() &#123; $document.off('mousemove', mousemove); $document.off('mouseup', mouseup); &#125; &#125; &#125;;&#125;]); controller-&gt;指令中的controller属性可以用来完成指令间的相互通信 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// jsangular.module('docsTabsExample', []).directive('myTabs', function() &#123; return &#123; restrict: 'E', transclude: true, scope: &#123;&#125;, controller: ['$scope', function MyTabsController($scope) &#123; var panes = $scope.panes = []; $scope.select = function(pane) &#123; angular.forEach(panes, function(pane) &#123; pane.selected = false; &#125;); pane.selected = true; &#125;; this.addPane = function(pane) &#123;// 这个方法需要暴露给其他指令用 if (panes.length === 0) &#123; $scope.select(pane); &#125; panes.push(pane); &#125;; &#125;], templateUrl: 'my-tabs.html' &#125;;&#125;).directive('myPane', function() &#123; return &#123; require: '^^myTabs', // 依赖一个myTabs控制器，并在指令的父元素上查找这个控制器 restrict: 'E', transclude: true, scope: &#123; title: '@' // 相当于@title &#125;, link: function(scope, element, attrs, tabsCtrl) &#123; tabsCtrl.addPane(scope); &#125;, templateUrl: 'my-pane.html' &#125;;&#125;);// index.html&lt;my-tabs&gt; &lt;my-pane title=\"Hello\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/my-pane&gt; &lt;my-pane title=\"World\"&gt; &lt;em&gt;Mauris elementum elementum enim at suscipit.&lt;/em&gt; &lt;p&gt;&lt;a href ng-click=\"i = i + 1\"&gt;counter: &#123;&#123;i || 0&#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;/my-pane&gt;&lt;/my-tabs&gt;// tabs&lt;div class=\"tabbable\"&gt; &lt;ul class=\"nav nav-tabs\"&gt; &lt;li ng-repeat=\"pane in panes\" ng-class=\"&#123;active:pane.selected&#125;\"&gt; &lt;a href=\"\" ng-click=\"select(pane)\"&gt;&#123;&#123;pane.title&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"tab-content\" ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;// panel&lt;div class=\"tab-pane\" ng-show=\"selected\"&gt; &lt;h4&gt;&#123;&#123;title&#125;&#125;&lt;/h4&gt; &lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt; 当你想暴露一个API给其它的指令调用那就用controller,否则用link。 controllerAs-&gt;给指令中的controller起个别名，并可做controller中的第四个参数传入 priority-&gt;设置指令执行的优先级顺序(权重)；多个指令时，ng必须知道哪个先执行；默认ng-repeat优先级很高，为1000；-&gt;不常用 terminal-&gt;是否设置当前指令的权重priority 为结束界限；若为true，则节点上小于当前指令权重priority的指令不会被执行，相同权重的会执行 require-&gt;可以将其他指令传给自己，有以下值 directiveName-&gt;默认值，会从同一个元素上查找 ^directiveName-&gt;会在父级上查找 ?directiveName-&gt;表示指令是可选的，找不到也不会抛出异常 Animations 可参考https://css-tricks.com/animations-the-angular-way/ 无需引入任何模块，直接利用切换class配合css的过渡，来实现过渡动画-&gt;无法做到全兼容；-&gt;https://codepen.io/bdsimmons/pen/NqYjaV angualr中内置了$animate服务，可以提供简单的动画操作，enter、leave…-&gt;核心方法，ngAnimate模块也依赖这个核心服务 更强大的动画-&gt;引入ngAnimate模块；angualr没有直接包含动画模块(ngAnimate)，需要在引入angular.js后引入angular-animate.js 重点：ngAnimate动画的核心都是基于css，通过变换元素的class类配合过渡和animation进而实现动画，js动画除外 如何使用ngAnimate模块 整个app没有模块，则可以直接指定ng-app=”ngAnimate”来从ngAnimate模块启动app，也能有动画效果；-&gt;不推荐-&gt;http://www.runoob.com/try/try.php?filename=try_ng_animation 当做模块依赖来使用-&gt;var app=angular.module(“myApp”,[“ngAnimate”]); 当引入ngAnimate模块后，就会自动在一些指令执行的特殊时机，为元素添加上对应的class类，可以利用这个配合css实现动画 css过渡动画-&gt;需要设置动画的起点、终点的动画属性值；例如在.ng-enter上设置过渡动画初始值，在.ng-enter-active上设置过渡动画终点值-&gt;https://codepen.io/bdsimmons/pen/OPmNxXs css3Animation-&gt;css3Animtions，无需在2个class上设置动画，只需要在一个class上设置动画，并给定动画时间即可，所以如上面的只需要在.ng-enter上设置一个animation动画即可，无需在ng-enter-active在设置动画-&gt;https://codepen.io/anon/pen/NjJLMZ JS动画-&gt;当引入ngAnimate模块后 就自动在app上添加了animation方法，app.animation()；可以通过animation方法，实现动画-&gt;https://codepen.io/bdsimmons/pen/YXLZEw Module 基本用法 创建模块-&gt;用angular.module(“moduleName”,[“依赖的模块”]); 获取已有模块-&gt;用angular.module(“moduleName”);注意获取时，没有后面的依赖数组 让模块运作起来 声明一个module,然后在ng-app中引用它，即可让app从module中开始运行 模块划分 服务模块 指令模块 过滤器模块 一个应用的模块，依赖于上述的三个模块，而且包含应用的初始化及启动代码12345678910111213141516171819202122232425262728293031323334angular.module('xmpl.service', []) // 服务 .value('greeter', &#123; salutation: 'Hello', localize: function(localization) &#123; this.salutation = localization.salutation; &#125;, greet: function(name) &#123; return this.salutation + ' ' + name + '!'; &#125; &#125;) .value('user', &#123; load: function(name) &#123; this.name = name; &#125; &#125;);angular.module('xmpl.directive', []); // directiveangular.module('xmpl.filter', []);// filterangular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter']) // xmpl依赖service、directive、filter .run(function(greeter, user) &#123; // 初始化 // This is effectively part of the main method initialization code greeter.localize(&#123; salutation: 'Bonjour' &#125;); user.load('World'); &#125;) .controller('XmplController', function($scope, greeter, user)&#123; $scope.greeting = greeter.greet(user.name); &#125;); 模块是配置代码块和运行代码块的集合 配置代码块config-&gt;在 provider 注册和配置阶段执行（注：provider 是 ng 服务的一种）。只有 provider 和 constant 可以被注入配置代码块。这是为了防止服务在完全配置好之前被意外地初始化。-&gt;config为配置 执行代码块run-&gt;在 injector 被创建后执行，被用来启动整个应用。只有服务的实例对象以及 constant 可以被注入到执行代码块。这是为了防止在应用执行期间系统的更进一步的配置。-&gt;run为初始化 123456789angular.module('myModule', []). config(function(injectables) &#123; // provider型注入器 // 这是配置(config)代码块的范例，你可以有任意多个配置代码块 // 配置块中你只能注入Provider类（注意：不是由Provider类生成的实例）以及`constant` &#125;). run(function(injectables) &#123; // instance型注入器 // 这是运行(run)代码块的范例，你可以有任意个运行代码块 // 运行块中你只能注入Provider实例（注意：不是Provider类） &#125;); 配置代码块的快捷方法 123456789101112131415161718192021222324angular.module('myModule', []).value('a', 123).factory('a', function() &#123; return 123; &#125;).directive('directiveName', ...).filter('filterName', ...);// 等同于angular.module('myModule', []).config(function($provide, $compileProvider, $filterProvider) &#123; $provide.value('a', 123); $provide.factory('a', function() &#123; return 123; &#125;); $compileProvider.directive('directiveName', ...); $filterProvider.register('filterName', ...);&#125;);//.config等同于设置module函数的第三个参数angular.module(\"myModule\",[],[\"$provide\",\"$compileProvider\",\"$filterProvier\",function(provide,compileProvier,filterProvider)&#123; provide.value('a', 123); provide.factory('a', function() &#123; return 123; &#125;); compileProvider.directive('directiveName', ...); filterProvider.register('filterName', ...); &#125;]); 配置语句的执行顺序就是根据它们注册的顺序而定的。唯一的例外是 constant 的定义，它会被调整到所有配置块的最前面执行。 执行代码块 执行代码块是 ng 中最接近 main 函数的一个东西。执行代码块是应用启动时运行的代码。它在所有的服务被配置好以及 注入器(injector)被创建好之后执行。通常，执行代码块包含的代码都很难进行单元测试，正因为如此，它通常应该被丢在一个单独的模块中，这样我们可以在单元测试时忽略它。 模块依赖 A依赖B，则A的配置阶段要在B的配置阶段完成后进行，执行阶段同理，A的执行要在B的执行结束后。 注意每个模块只能被加载一次，即使有多个别的模块依赖它。 IE兼容性 1.3及以上不再支持IE8-&gt;所以如果需要支持IE8，请使用ng1.2.x-&gt;1.2的最新版本为1.2.32 IE7及以下不支持JSON.stringify-&gt;使用json2.js 123&lt;!--[if lte IE 7]&gt; &lt;script src=\"/path/to/json2.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 在根元素上添加id=”ng-app”并结合ng-app=”xxModule”来启动app 1234&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt; ...&lt;/html&gt; 不要使用自定义节点 如ng:view，用attribute方式代替如ng-view 如果你由于语义或者第三方的Angular组件需要使用tag的方式的话,那么你必须按照如下步骤 make IE happy 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html xmlns:ng=\"http://angularjs.org\" id=\"ng-app\" ng-app=\"optionalModuleName\"&gt;&lt;head&gt;&lt;!--[if lte IE 8]&gt; &lt;script&gt; document.createElement('ng-include'); document.createElement('ng-pluralize'); document.createElement('ng-view'); // Optionally these for CSS document.createElement('ng:include'); document.createElement('ng:pluralize'); document.createElement('ng:view'); &lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 重要的部分: xmlns:ng- 命名空间 - 你需要为每一个将使用的自定义tag注册一个命名空间(译者注:IE作为严格xml模式解析). document.createElement(yourTagName) - 自定义节点创建 - 由于这只是老版本的IE issues，所以你需要按条件加载这些脚本(IE低版本特有的条件注释)。对于每一个需要使用的没有注册命名空间以及非HTML定义的tag你需要利用它来预申明来make IE happy。 IE在处理关于非标准HTML tag 的问题主要由两类，每种类型又其自己的修复方式. If the tag name starts with my: prefix then it is considered an XML namespace and must have corresponding namespace declaration on 以my:为前缀的tag 考虑到严格的XML命名空间，你必须有相应的命名空间申明,如。 If the tag has no : but it is not a standard HTML tag, then it must be pre-created using document.createElement(‘my-tag’) 没有:的非标准HTML tag, 你需要使用document.createElement(&#39;my-tag&#39;)来预申明改节点(译者注:ie-shv)。 If you are planning on styling the custom tag with CSS selectors, then it must be pre-created using document.createElement(&#39;my-tag&#39;) regardless of XML namespace. 如果你希望采用CSS选择器的方式，那么你需要使用document.createElement(&#39;my-tag&#39;)预申明，忽略XML命名空间。 使用ng-style代替style=;后者在&lt;IE11的版本上无法运行 Angualr会在执行的某些时间点为标签添加上一些标识用的class类 ng-scope样式类会在创建了新作用域(Scope)的HTML元素上生成 ng-binding样式类会在ng-bind 或 绑定了任何数据的元素上生成 ng-invalid、ng-valid样式类会在进行了验证操作的所有input组件元素上生成 ng-pristine、ng-dirty angular的input指令给所有新的、还没有与用户交互的input元素附加上ng-pristine类，当用户有任何输入时，则附加上 ng-dirty. 国际化I18n和本地化L10n 引入特定的语言包 12345678&lt;html ng-app&gt;&lt;head&gt;…. &lt;script src=\"angular.js\"&gt;&lt;/script&gt; &lt;script src=\"i18n/angular-locale_zh-cn.js\"&gt;&lt;/script&gt;….&lt;/head&gt;&lt;/html&gt; 启动即bootstrap(这里bootstrap并非指ui库，bootstrap本身就有启动的意思) 自动启动 在angular要控制的范围最外层元素上添加ng-app指令 若未指定ng-app的具体值，会从默认模块开始启动；若指定了则从指定模块上启动 若需支持IE7，则还上在ng-app除添加id=”ng-app” 若需支持老式ng:风格的指令，则还需要在html上添加xml命名空间 1&lt;html xmlns:ng=\"http://angularjs.org\"&gt; 手动启动 使用angular.bootstrap 1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div ng-controller=\"MyController\"&gt; Hello &#123;&#123;greetMe&#125;&#125;! &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/snapshot/angular.js\"&gt;&lt;/script&gt; &lt;script&gt; angular.module('myApp', []) .controller('MyController', ['$scope', function ($scope) &#123; $scope.greetMe = 'World'; &#125;]); angular.element(document).ready(function() &#123; angular.bootstrap(document, ['myApp']); // 手动启动 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap要在需要的module创建或加载完成后，才能调用 当手动启动app时，就不应当在用ng-app指令了 安全性 不要混用前台和后台的模板 不要使用用户的输入动态生成模板 Do not run user input through $scope.$eval 考虑使用ngCSP模块 Providers injector可以创建两种对象 专有对象-&gt;angular框架提供的，如controller、filter、directives等 服务-&gt;服务的API由开发人员自己制定-&gt;说明服务可以自己定制 injector需要知道如何创建服务，它需要一个”图纸” 图纸provider、factory、service、value、constant 最底层的图纸是provider，其余四种图纸都是基于provider的语法糖（在provider上又封装了一层） value图纸 用来创建可在运行阶段使用的常量 1234567891011var myApp = angular.module('myApp', []);myApp.value('clientId', 'a12345654321x');myApp.controller('DemoController', ['clientId', function DemoController(clientId) &#123; this.clientId = clientId;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125;&lt;/body&gt;&lt;/html&gt; factory图纸 可以创建任何类型的服务 factory图纸相较value图纸增加了下面功能 可以有依赖 服务初始化 延迟/惰性初始化 factory图纸通过一个拥有0～n个参数(参数表示该服务对其他服务的依赖)的函数来创建服务，而函数返回值就是factory图纸创建的服务实例。 123myApp.factory('clientId', function clientIdFactory() &#123; return 'a12345654321x';// 返回的是服务的实例，不过这里clientId是一个常量，所以还是用value靠谱&#125;); 更适合用factory的例子，计算token 12345678910111213myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) &#123;//将工厂方法命名为\"Factory\"是最佳实践（比如，apiTokenFactory）.虽然这种命名方式不是强制性的，但是它有助于浏览代码仓库或者在调试器里跟踪调用堆栈。 var encrypt = function(data1, data2) &#123; // NSA-proof加密算法： return (data1 + ':' + data2).toUpperCase(); &#125;; var secret = window.localStorage.getItem('myApp.secret'); var apiToken = encrypt(clientId, secret); return apiToken;&#125;]);``` service图纸 必须返回引用类型 自定义类型，并携带token 1234567891011function UnicornLauncher(apiToken) &#123; this.launchedCount = 0; this.launch() &#123; // 带上apiToken来发起远程调用 ... this.launchedCount++; &#125;&#125;myApp.factory('unicornLauncher', [\"apiToken\", function(apiToken) &#123;// 使用factory图纸来实现 return new UnicornLauncher(apiToken);&#125;]);myApp.service('unicornLauncher', [\"apiToken\", UnicornLauncher]);// 使用services语法更加简介，在内部还是会像factory一样，new 一下 provider图纸 注意必须实现$get方法 其它图纸的底层都是通过provider实现的，如factory 123function factory(name, factoryFn) &#123; return provider(name, &#123; $get: factoryFn &#125;); &#125; 当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到provider图纸 假设我们的unicornLauncher服务是如此棒，以至于有好多应用都用到它。默认情况下，发射器将独角兽发射到太空中不需要任何保护屏障。但是在某些星球上，由于大气层非常厚，我们在将独角兽送去做星际旅行前必须将它们包裹在铝箔里，不然它们在穿越大气层时就被烧毁了。在一些应用里，需要设置发射器在每次发射时都使用铝箔屏蔽，如果我们能按需配置这一点那就太棒了。我们可以像下面这样让它变得可配置 12345678910111213myApp.provider('unicornLauncher', function UnicornLauncherProvider() &#123; var useTinfoilShielding = false; this.useTinfoilShielding = function(value) &#123; useTinfoilShielding = !!value; &#125;; this.$get = [\"apiToken\", function unicornLauncherFactory(apiToken) &#123; // 这里我们假设UnicornLauncher的构造函数也被改造得支持useTinfoilShielding参数了 return new UnicornLauncher(apiToken, useTinfoilShielding); &#125;];&#125;);myApp.config([\"unicornLauncherProvider\", function(unicornLauncherProvider) &#123; unicornLauncherProvider.useTinfoilShielding(true);&#125;]); constant图纸 用来创建可以在配置阶段使用的图纸 在angular开始创建服务之前，angular会配置和实例化所有provider，此时服务还不能用，因为他们还没有被创建(只是provider被实例化了，由provider创建并返回的服务此时还没有被创建)；一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始；-&gt;所以在配置阶段，没有服务可用，这就导致了一些没有依赖用value写的常量也无法被使用-&gt;使用constant 假设在配置阶段提供了发射独角兽的星球名称，那么我们的unicornLauncher服务就能通过这个名字来标识一个独角兽。星球名是各个应用特有的，并且在应用运行时也会被各个控制器使用。我们可以像下面的代码那样把星球名定义为一个常量 123456myApp.constant('planetName', 'Greasy Giant');myApp.config(['unicornLauncherProvider', 'planetName', function(unicornLauncherProvider, planetName) &#123;// 在配置阶段，使用constant，因为value无法使用 unicornLauncherProvider.useTinfoilShielding(true); unicornLauncherProvider.stampText(planetName);&#125;]);``` value图纸也可以在控制器、模板、指令中使用 1234567891011myApp.controller('DemoController', [\"clientId\", \"planetName\", function DemoController(clientId, planetName) &#123; this.clientId = clientId; this.planetName = planetName;&#125;]);&lt;html ng-app=\"myApp\"&gt; &lt;body ng-controller=\"DemoController as demo\"&gt; Client ID: &#123;&#123;demo.clientId&#125;&#125; &lt;br&gt; Planet Name: &#123;&#123;demo.planetName&#125;&#125; &lt;/body&gt;&lt;/html&gt; 总结 injector用五种图纸来创建服务和专有对象 provider图纸是最底层的方法，其他的图纸都是基于其之上的语法糖 provider是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它 除了控制器，其他所有专用对象都是通过factory图纸来定义的(factory定义的，都是单例对象，而controller不是单例的) factory和service是最常用的图纸。它们之间的唯一区别就是service图纸存在一个new过程，所以最好返回一个构造函数，而factory可以创建任意类型 constant用在配置时，value用在运行时 12* 有直接使用new操作符预先初始化的开销。** 在配置阶段，服务对象是不能被访问的，但Provider实例是可以被访问的。（参见我们上面列举的unicornLauncherProvider例子）。 HTML Compiler HTML compiler 让开发者可以教浏览器一些新的语法技能 Compiler是 Angular 提供的一项服务，用来遍历DOM节点，查找特定的属性。编译过程分为两个阶段： 编译compile：遍历DOM节点，收集所有的指令，返回一个连接函数（link func） 连接link：将上一步收集到的每个指令与其所在的作用域（scope）连接生成一个实时视图。任何作用域中的模型改变都会实时在视图中反映出来，同时任何用户与视图的交互则会映射到作用域的模型中。这样，作用域中的数据模型就成了唯一的数据源。 指令directive 在编译过程中，遇到特定的HTML结构（也就是指令）时，指令所声明的行为操作会被触发 指令其实就是在编译器遍历DOM时碰到就需要执行的函数。 指令是如何被编译的 知道 Angular 的编译是在DOM节点上发生而非字符串上是很重要的。如果你自己手动调用 $compile 时，如果你传给它一个字符串，显然是要报错的。所以，在你传值给 $compile 之前，用 angular.element 将字符串转化为DOM。 编译流程 $compile 遍历DOM节点，匹配指令。 如果编译器发现某个元素匹配一个指令，那么这个指令就被添加到指令列表中（该列表与DOM元素对应）。一个元素可能匹配到多个指令（译注：也就是一个元素里面可能有多个指令）。 当所有指令都匹配到相应的元素时，编译器按照指令的 priority 属性来排列指令的编译顺序。 然后依次执行每个指令的 compile 函数。每个 compile 函数有一次更改该指令所对应的DOM模板的机会。然后，每个 compile 函数返回一个 link 函数。这些函数构成一个“合并的”连接函数，它会调用每个指令返回的 link 函数。 之后，$compile 调用第二步返回的连接函数，将模板和对应的作用域连接。而这又会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchs。 用代码表示大概是下面流程 1234567891011121314151617181920212223var $compile = ...; // 已经存在的编译器var scope = ...;// 作用域var parent = ...; // DOM element where the compiled template can be appended，要被追加内容的DOM元素var html = '&lt;div ng-bind=\"exp\"&gt;&lt;/div&gt;';// 指令模板字符串// Step 1: parse HTML into DOM element，将html字符串解析为DOM，因为如果传给$compile字符串会报错var template = angular.element(html);// Step 2: compile the template，遍历整个template的DOM，找到所有指令，并按priority排序，并依次执行每个指令里的compile函数，每个compile函数会返回一个link函数，以供第三部用var linkFn = $compile(template);// Step 3: link the compiled template with the scope.，$compile会依次调用第二步返回的link函数，将模板和对应的作用域连接，会依次调用连接函数中包含的每个指令对应的 link 函数，进而在各个DOM元素上注册监听器以及在相应的 scope 中设置对应的 $watchesvar element = linkFn(scope);// Step 4: Append to DOM (optional)，可选的将一切就绪的dom追加到html中parent.appendChild(element); 总结：compile(找指令、排序、依次执行指令中compile函数并返回link函数)-&gt;执行每个指令中的link(DOM和作用域进行连接，设置事件监听并添加$watch) ngModel模块 当需要对数据进行深层处理时，可以用ngModel模块-&gt;一般是指令，这个ngModel对应的就是指令匹配元素上的ng-model 主要参考http://docs.ngnice.com/guidehttps://code.angularjs.org/1.2.32/docs/guide小猫杯的angular视频教程大漠穷秋的angular实战","tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Graphviz","date":"2017-03-24T08:55:14.000Z","path":"2017/03/24/Graphviz/","text":"Graphviz的安装以及基本使用介绍Graphviz可通过代码的方式生成图形 安装win下，可在官网http://http://www.graphviz.org/Download_windows.php下载，安装好后，手动将bin文件夹添加到环境变量即可。cmd 下键入dot -version,能出现Graphviz相关信息，则表示安装成功 生成图片12dot 源文件 -T 图片格式 -o 输出文件dot input.dot -T png -o output.png 可利用sublimeText的编译系统，实现图片实时预览 具体可参考这篇文章https://zhuanlan.zhihu.com/p/22820399 新建*.dot文件，然后编写相应代码，再编译就能生成图 基本语法123图类型 图名&#123; //其他&#125; 无向图1234567// 无向图用--表示节点之间的关系graph graphname &#123; a -- b--e; b -- c; b -- d; d -- a;&#125; 有向图123456// 有向图用a-&gt;b表示从a节点指向b节点digraph graphname&#123; a-&gt;b b-&gt;c a-&gt;c&#125; 定义一类节点123456digraph graphname&#123; T [label=&quot;Teacher&quot;,fontcolor=&quot;red&quot;] //定义节点T，并给予属性 P [label=&quot;Pupil&quot;] //定义节点P，并给予属性 T-&gt;P [label=&quot;Instructions&quot;, fontcolor=darkgreen] //定义边T-&gt;P，并给予属性 &#125; 设置属性(样式)12345678910111213141516171819202122232425262728293031323334353637graph G &#123; // 设置当前图和子图的属性 fontname=&quot;Microsoft JhengHei&quot;; fontsize=20; label=&quot;图&quot;; fontcolor=blue; //设置当前大括号范围内所有节点和边的属性，包含子图里面节点和边，类css中标签选择器 node[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; edge[fontname=&quot;Microsoft JhengHei&quot;,fontsize=16]; // 可针对某一类节点设置属性，类css中class选择器 &quot;黑海&quot;[fontcolor=&quot;pink&quot;,style =&quot;filled&quot;,fillcolor = &quot;black&quot;]; &quot;黑海&quot; -- &quot;亚速海&quot;; &quot;黑海&quot; -- &quot;博斯普鲁斯海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;爱琴海&quot;; // 子图，用subgraph声明，并图名字前缀必须是cluster_否则识别失败；子图和父图的类型必须一致，父图是无向则子图也必须是无向，不能是有向 subgraph cluster_T &#123; // 设置子图的label属性，它的颜色继承父图的fontcolor=blue label=&quot;黑海海峡&quot;; &quot;达达尼尔海峡&quot; -- &quot;马尔马拉海&quot; -- &quot;博斯普鲁斯海峡&quot;; &#125; subgraph cluster_M &#123; label=&quot;黑海海峡&quot;; // 一对多，空格分隔 &quot;中部地中海&quot; -- &#123; &quot;爱琴海&quot; &quot;爱奥尼亚海&quot; &quot;西西里海峡&quot; &#125;; // 一对多，并设置每对都有一个label标签说明，并把字体颜色设置为red，线条颜色设置为yellow &quot;西部地中海&quot; -- &#123; &quot;西西里海峡&quot; &quot;第勒尼安海&quot; &quot;利古里亚海&quot; &quot;伊比利海&quot; &quot;阿尔沃兰海&quot; &#125;[label=&quot;标签说明&quot;,fontcolor=&quot;red&quot;,color=&quot;yellow&quot;]; &quot;爱奥尼亚海&quot; -- &quot;亚得里亚海&quot;; &quot;阿尔沃兰海&quot; -- &quot;直布罗陀海峡&quot;; &#125;&#125; 最终生成的 中文乱码保证.dot文件是以UTF-8编码通过设置fontname为中文字体来解决 参考链接 https://zhuanlan.zhihu.com/p/21993254https://zhuanlan.zhihu.com/p/22820399http://blog.csdn.net/xiajian2010/article/details/23748557http://www.tuicool.com/articles/vy2Ajyu","tags":[{"name":"Graphviz","slug":"Graphviz","permalink":"http://yoursite.com/tags/Graphviz/"},{"name":"绘图","slug":"绘图","permalink":"http://yoursite.com/tags/绘图/"}]},{"title":"mock-js","date":"2017-03-24T02:52:19.000Z","path":"2017/03/24/mock-js/","text":"Mock.js的基本用法如何使用123456789101112131415161718192021&lt;script type=\"text/javascript\" src=\"js/jquery-2.2.4.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入Mock.js --&gt;&lt;script type=\"text/javascript\" src=\"js/mock-min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 根据数据模板生成模拟数据。 Mock.mock('http://test.cn', &#123; \"userName\": \"@cname\", \"sex|1\": [\"男\", \"女\"], \"avator\": Mock.Random.image('100x100', '#894FC4', '#FFF', 'png', '头像') &#125;); // 模拟请求 $.ajax(&#123; url: 'http://test.cn', dataType: 'json' &#125;).done(function(data, status, xhr) &#123; // 请求成功，do something console.log(data); &#125;);&lt;/script&gt; 语法规范 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义语法1234&apos;name|rule&apos;:valuename:属性名rule:生成规则vale:属性值 注意 属性名(name)和生成规则(value)之间要用|分隔 生成规则(rule)不是必须的 最终生成值的类型和初始值由属性值(value)确定 属性值(value)中可以包含数据占位符(@占位符) 生成规则有7种格式 ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则的具体含义还要配合属性值(value)的类型来确定 规则 属性值(value)是String ‘name |min-max’:stringValue 通过重复stringValue，生成一个字符串。重复次数在[min,max]区间取值(次数大于等于min，小于等于max) ‘name |count’:stringValue 通过重复stringValue字符串count次，生成一个字符串。 属性值(value)是Number ‘name|+1’: numberValue 属性值自动加 1，初始值为numberValue。 ‘name|min-max’:numberValue 生成一个[min,max]之间的整数，此时属性值numberValue只是用来确定类型。 ‘name|min-max.dmin-dmax’: numberValue 生成一个整数部分在[min,max]间取值,小数保留的位数在[dmin,dmax]间取值的浮点数。同理此时属性值(value)也只是用来确定最终返回的数据的类型。 属性值是Boolean ‘name|1’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 1/2，值为 !booleanValue 的概率同样是 1/2。 ‘name|min-max’: booleanValue 随机生成一个布尔值，值为 booleanValue 的概率是 min / (min + max)，值为 !booleanValue 的概率是 max / (min + max)。此处属性值必须是Boolean类型，若为Number,则意义不同，见2 “test|1-2”:true 生成一个布尔值，为true的概率为1/3，为false概率为2/3 属性值是对象 Object ‘name|count’: object 返回的对象只包含从属性值object中随机选取的count个属性。 ‘name|min-max’: object 返回的对象只包含从属性值object中随机选取的min到max个属性。 属性值是数组 Array ‘name|1’: array 从属性值 array 中随机选取 1 个元素，作为最终值。 ‘name|+1’: array 从属性值 array 中顺序选取 1 个元素，作为最终值。 ‘name|min-max’: array 通过重复属性值array的值生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: array 通过重复属性值array的值生成一个新数组，重复次数为 count。 属性值是函数 Function ‘name’: function 执行函数 function，取其返回值作为最终的属性值，函数的上下文为属性 ‘name’ 所在的对象。 属性值是正则表达式 RegExp ‘name’: regexp 根据正则表达式 regexp 反向生成可以匹配它的字符串。用于生成自定义格式的字符串。 数据占位符定义语法Mock中的占位符和Sass中的placeholder很像。可以直接用在数据模板的属性值中。Mock中提供了很多预先定义的占位符，当然你也可以自定义占位符。 基本调用格式1234@占位符@占位符(参数 [, 参数])或者Mock.Random.占位符(参数 [, 参数]) 注意： 用@来标识其后的字符串是占位符。 占位符引用的是Mock.Random中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符也可以引用数据模板中的属性。 占位符会优先引用数据模板中的属性。 占位符支持相对路径和绝对路径。 预定义的占位符 Basic 提供一些基础占位符，如布尔值、整数、自然数、字符串等 Date 提供日期相关的占位符 Image 提供图片相关的占位符 Color 提供色值相关的占位符 Text 提供文本相关的占位符 Name 提供英文、中文名称相关的占位符 Web 提供了url、IP、protocol等相关的占位符 Address 提供省份、城市等地域相关信息的占位符 Helper 提供一些常用工具如字母转换大小写等相关占位符 Miscellaneous 提供了guid、身份证、自增等相关占位符号 自定义扩展符1234567891011121314Mock.Random.extend(&#123; constellation: function(date) &#123; var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座'] return this.pick(constellations) &#125;&#125;)Mock.Random.constellation()// =&gt; \"水瓶座\"Mock.mock('@CONSTELLATION')// =&gt; \"天蝎座\"Mock.mock(&#123; constellation: '@CONSTELLATION'&#125;)// =&gt; &#123; constellation: \"射手座\" &#125; 更多API请参考 https://github.com/nuysoft/Mock/wiki&#39; 更多实例请参考 http://mockjs.com/examples.html 可以一边看API、一边看实例，很容易就能上手","tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"模拟数据","slug":"模拟数据","permalink":"http://yoursite.com/tags/模拟数据/"}]},{"title":"Markdown-Learning","date":"2017-03-23T03:21:16.000Z","path":"2017/03/23/Markdown-Learning/","text":"Markdown-Github Flavored Markdown常用操作Markdown拥有多种语法风格 标准风格-不支持表格 扩展风格-支持表格 github风格-Github Flavored Markdown它在标准风格上做了很多改进，如对表格的支持，针对不同编程语言实现代码高亮等 因为经常使用github，所以选择了Github Flavored Markdown风格。 Hexo搭建的博客也是使用github风格来解析markdown的。 win上支持Github Flavored Markdown风格的编辑器我常用的有:markdown pad2和typora。typora最让我心动的是支持快捷键创建表格，非常的方便。 标题12345# 一级标题## 二级标题，二级标题自带下划线### 三级标题...###### 六级标题 粗体斜体1234**两个星号为粗体***一个星号为斜体***粗中带 _斜_***内部换行用&lt;br&gt;,第二行* 引用1&gt; 这样引用 无序列表12345- 无序 - 我前面有2个空格，我能缩进 - 无序- 无序- 无序 有序列表12341. 第一行 1. 我前面有2个空格2. 第二行3. 第三行 任务列表123- [x] 我代表选中- [ ] 我没选中- [ ] 我没选中 图片与链接12[链接名](链接地址)![图片alt](图片地址) 代码段1使用`包裹的区域会形成代码段,区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成HTML实体，一般用在行内 代码块1使用三个`会产生格式化好的代码块,而 &amp;、&lt; 和 &gt; 也一样会自动转成HTML实体，一般用于一大段代码 代码块高亮123function show()&#123; console.log(\"我是带语法高亮的代码块，在三个`后添加上语言类型即可高亮\");&#125; 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Markdown中表格生成较为麻烦，建议使用编辑器快速生成,如typora中使用ctrl+t 分割线1***或--- 会产生分割线 还有很多东西因为没用到，所以不做介绍。更多的可以参考这 https://help.github.com/categories/writing-on-github/","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Handlebars-guide","date":"2017-03-17T10:48:09.000Z","path":"2017/03/17/Handlebars-guide/","text":"#HandleBars备忘 表达式{{xxx}} {{{xxxx}}}因为双大括号默认会进行HTML转义,将&lt;转换为&amp;lt;,通过三括号可以避免 Helper默认Helper{{#if a}}如果a为真执行这个{{/if}} {{#else}}否则执行这个{{/else}} {{#unless a}}当a为假的时候执行这个{{/unless}} {{#each obj}}遍历obj的每个属性{{/each}} #each内可以用{{@index}}获取当前遍历的索引值，用{{@key}}获取当前属性的属性名，用{{this}}可以获当前属性的值 如何获取父对象 可以通过{{../父对象某属性}}来获取父对象的某个属性，{{@../index}}获取父对象当前的所引值 {{#with obj}}xxx{{/with}}类似js中with，可改变作作用域，在each中也可通过#with 父对象名 来访问父对象 {{lookup xxx}}一般用来按照索引来找兄弟变量对应的值{{lookup ../父对象某属性 @index}}，查找父对象在当前索引下值 自定义Helper行级Helper语法{{helperName [普通值参数][hash值参数]}} {{customHelper \"My Text\" class=\"my-class\" visible=true counter=4}} Handlebars.registerHelper(&apos;customHelper&apos;, function() { console.log(arguments[0]);//==&gt;&quot;My Text&quot; console.log(arguments[1].hash);//==&gt;{class:&quot;my-class&quot;,visible:true,conter:4} }); 块级Helper语法{{#helperName context [普通值参数][hash值参数]}}xxxxxxxxx{{/helperName}} {{#customHelper nav \"normalValue\" class=\"my-class\" visible=true counter=4}} {{if name}} aaaaaa {{else}} bbbbbbb {{/if}} {{/customHelper}} Handlebars.registerHelper(&apos;customHelper&apos;, function(context,options) { console.log(arguments[0]);//==&gt;context console.log(arguments[1]);//==&gt;normalValue console.log(arguments[2]);//==&gt;options //说明在registerHelper内部,第二个参数匿名函数,只会存在3个实参，第一个为当前使用的上下文，第二个如果有则为一个普通值参数，另外一个就是封装了函数相关信息的options对象，它有hash(封装好一个或多个键值对参数)、fn(传入一个上下文，并在此上下文中执行customHelper模板中的{{#if}}到{{else}}中的模板)、inverse(同fn相反执行{{else}}到{{/if}}之间的)、name、data等属性。 }); 参考:http://cnodejs.org/topic/56a2e8b1cd415452622eed2dhttp://www.cnblogs.com/iyangyuan/archive/2013/12/12/3471227.html","tags":[{"name":"Handlebars","slug":"Handlebars","permalink":"http://yoursite.com/tags/Handlebars/"}]},{"title":"break-word、word-wrap、white-space","date":"2017-03-10T09:04:18.000Z","path":"2017/03/10/break-word-word-wrap-white-space/","text":"white-spacewhite-space的定义是用来设置如何处理元素中的空白。这里的空白指的是空格、tab制表符。 默认情况下，html中连续出现的多个空格会被合并成一个空格，Tab也会被替换成一个空格。回车换行(br换行不在内)会被忽略并将其替换成一个空格。当在容器剩余空间不足以容纳一个单词时，浏览器会在单词结束处自动换行。(默认情况下，是无法在一个单词内进行自动换行的，只能在结尾处换行。) 值 是否合并空白符(空格、tab) 是否忽略回车换行 是否允许自动换行 normal 合并 忽略 允许 nowrap 合并 忽略 不允许 pre 保留 保留 不允许 pre-wrap 保留 保留 允许 pre-line 合并 保留 允许 word-wrapword-wrap的定义是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。既指明是否允许浏览器在单词内进行自动换行 值 解释 normal 在单词结束处换行 break-word 如果行内没有多余空间容纳该单词到行尾，则会强制将单词截断，在单词内进行换行 word-breakword-break指定了怎样在单词内断行 值 解释 normal 默认换行规则 break-all 对于non-CJK (中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 在white-space、word-wrap、word-break都为normal值时，既默认情况下时。一行的剩余空间不足以容纳一个单词时，浏览器会将这个单词挪到下一行显示。挪后如果这个单词比容器还长，则这个单词会直接溢出，因为默认情况下，浏览器是无法在单词内进行换行的。中文会一行空间不足以容纳一个字时，在字后进行换行 此时如果设置word-wrap:break-word，则会将这个长单词进行截断，从截断处进行换行。 可以发现第一行仍然有一点空间没有利用，此时就需要用到word-break:break-all; 可以说word-break:break-all是word-wrap:break-word的升级版本，它不会在剩余空间不够的时候将长单词挪到下一行，它将单词放在原位，并在容器边界处直接将这个长单词进行截断，然后换行。 将这三个属性，组合使用会怎么样 当设置了white-space:nowrap;时，word-wrap:break-word;和word-break:break-all;都将失效。文本将会强制在一行内显示 当同时设置word-wrap:break-word;和word-break:break-all时，word-break:break-all的效果会生效 word-spacing规定英文单词之间的间距 letter-spacing规定英文字符之间的间距 总结: 默认情况下，当一行的剩余空间不足以容纳某一单词时，浏览器会将此单词整体挪到下一行显示。此时，若这个单词超长(长度超出容器的宽度)，则此单词会直接溢出(此时上一行会留下一段空白)。 word-wrap:指明是否允许在长单词中换行，当设置其属性为break-word，则会把超过容器长度的单词进行截断，并换行(上一行留下的空白并不会被清除) word-break:当其设置break-all时，它是word-wrap:break-word的升级版，它能解决上一行留白问题。它会让单词先在当前行显示，当单词某个字符到达容器边界时，会直接在此字符出进行截断，并换行。这样就最大限度的利用了空间。 white-space:指定处理空白符的方式，比较有用的属性为nowrap，设置文本不换行。一般配合其它css实现文本过长省略号 word-spacing:规定英文单词之间的间距 letter-spacing:规定英文单词字符之间的间距 图片引用在自http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]